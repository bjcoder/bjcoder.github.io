<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.0//EN" "http://www.wapforum.org/DTD/xhtml-mobile10.dtd">
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport"content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes"/>
  
  
  <title>  Min‘s blog</title>

 
  
    <link rel="icon" href="/img/favicon.png">
  


  <!-- css -->
  <link rel="stylesheet" href="/css/style.css">  
  <!-- Jquery -->
  <script src="//cdn.staticfile.org/jquery/3.2.1/jquery.min.js"></script> 
  <!-- Add fancyBox -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.1.25/jquery.fancybox.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.1.25/jquery.fancybox.min.js"></script> 
  <script src="/js/gallery.js"></script>
  <!-- javascript --> 
  <script src="/js/mobile.js"></script>  
  <script src="/js/utils.js"></script>    
  <script src="/js/script.js"></script>  
</head> 
  <body> 
    <header class="header">
	
  <nav class="header-nav">       
	
  	<span class="iconfont icon-menu mobile-toggle"></span>  

    <a class="header-logo" href="/"><span>Min&#39;s blog</a>  

    <div class="header-menu">          
              
            

              <a class="header-menu-link" id="header-menu-home" href="/">首页</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-archives" href="/archives">归档</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-categories" href="/categories">分类</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-tags" href="/tags">标签</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-about" href="/about">关于</a>     

            
            
            

              <a class="iconfont icon-menu-search header-menu-link" id="header-menu-search"></a>

            
                
    </div>  
    
  </nav>
</header>

    <div class="container">         
      
        

          <section id="main">  

        

        


<div class="profile sildeUpMin">

		<img class="avatar no-gallery" src="/img/timg.jpeg"  alt="Lose">
					
		<p class="author">Rui Min</p>

		
			<p class="location"><span class="iconfont icon-location"></span>BeiJing CN</p>
		
	
		<div class="social">
   		    	
		<a href="https://github.com/bjcoder" class="iconfont icon-github" target="_blank" title="github"></a>
	        	
		<a href="/" class="iconfont icon-others" target="_blank" title="others"></a>
	    
    	</div>		
</div>

      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2017/11/11/Linux集群资源监控/">Linux集群资源监控</a>  
	       
		 

		 <time>2017-11-11 </time>    
	</div>


    <div class="article-excerpt">	
	
  	

	  

	  	<h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><ul>
<li>Ganglia 监控套件包括三个主要部分 gmond ，gmetad，和网页接口，通常被称为ganglia-web。<br>gmond 是一个守护进程，他运行在每一个需要监测的节点上，收集监测统计，发送和接受在同一个组播或单播通道上的统计信息。</li>
<li>gmetad 也是一个守护进程，他定期检查gmonds ，从那里拉取数据，并将他们的指标存储在RRD存储引擎中。它可以查询多个集群并聚合指标。RRD也被用于生成用户界面的web前端。</li>
<li>ganglia-web 顾名思义，他应该安装在有gmetad运行的机器上，以便读取RRD文件。</li>
</ul>
<p>​    一般来说一个集群的每台机器上都需要安装gmond，只要负责展示web界面的机器安装了gmetad即可。</p>
<h1 id="二-ganglia规划"><a href="#二-ganglia规划" class="headerlink" title="二.ganglia规划"></a>二.ganglia规划</h1><p>​    <strong>主机名</strong>             ip               <strong>规划</strong>                         安装</p>
<p>   hadoop1      10.2.6.250        服务端   ganglia-gmond、ganglia-gmetad、ganglia-web</p>
<p>   hadoop2     10.2.6.246        客户端            ganglia-gmond</p>
<p>   hadoop3     10.2.6.248        客户端            ganglia-gmond</p>
<p>   hadoop4   10.2.6.249        客户端            ganglia-gmond</p>
<p>安装前确保iptables关闭.</p>
<h1 id="三-安装前的准备工作"><a href="#三-安装前的准备工作" class="headerlink" title="三.安装前的准备工作"></a>三.安装前的准备工作</h1><h2 id="3-1加载yum源，在每一台机器上面执行下面两个命令"><a href="#3-1加载yum源，在每一台机器上面执行下面两个命令" class="headerlink" title="3.1加载yum源，在每一台机器上面执行下面两个命令"></a>3.1加载yum源，在每一台机器上面执行下面两个命令</h2><p>rpm -Uvh <a href="http://dl.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm" target="_blank" rel="noopener">http://dl.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm</a></p>
<p>yum  -y  install  httpd-devel  automake  autoconf  libtool  ncurses-devel  libxslt  groff  pcre-devel  pkgconfig</p>
<h2 id="四-主节点服务安装配置"><a href="#四-主节点服务安装配置" class="headerlink" title="四.主节点服务安装配置"></a>四.主节点服务安装配置</h2><h2 id="4-1主节点的服务安装（hadoop1上面的安装配置）安装ganglia-gmetad-和ganglia-web"><a href="#4-1主节点的服务安装（hadoop1上面的安装配置）安装ganglia-gmetad-和ganglia-web" class="headerlink" title="4.1主节点的服务安装（hadoop1上面的安装配置）安装ganglia-gmetad 和ganglia-web"></a>4.1主节点的服务安装（hadoop1上面的安装配置）安装ganglia-gmetad 和ganglia-web</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yum search ganglia     ------------------查看ganglia在epel的安装包,复制进行安装 </span><br><span class="line">如果没有安装包，需要下载EPEL</span><br><span class="line">yum  install epel-release  //扩展包更新包  </span><br><span class="line">yum  update //更新yum源  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">yum -y install ganglia-web.x86_64 ganglia-gmond.x86_64  </span><br><span class="line">yum -y install ganglia-gmetad.x86_64 ----------------------(如果上一步执行了这步不用执行,web包会自动下载该依赖)  </span><br><span class="line">rpm -qa |grep ganglia          --------------------查看安装情况  </span><br><span class="line">rpm -ql ganglia-gmetad.x86_64       ------------- 复制上面命令执行结果的安装名,可查看安装路径</span><br></pre></td></tr></table></figure>
<h3 id="4-1-1配置gmetad"><a href="#4-1-1配置gmetad" class="headerlink" title="4.1.1配置gmetad"></a>4.1.1配置gmetad</h3><p>Shell<strong>代码</strong>   </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ganglia/gmetad.conf  </span><br><span class="line"></span><br><span class="line">data_source "my cluster" 10.2.6.250:8649  ---- Hadoop为cluster名称,后面是需要监控的主机名</span><br></pre></td></tr></table></figure>
<h3 id="4-1-2修改apache设置"><a href="#4-1-2修改apache设置" class="headerlink" title="4.1.2修改apache设置"></a>4.1.2修改apache设置</h3><p>Shell<strong>代码</strong>   </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> vi /etc/httpd/conf.d/ganglia.conf  </span><br><span class="line"></span><br><span class="line">文件内容Deny from all 为 allow from all </span><br><span class="line"></span><br><span class="line">修改后配置如下</span><br><span class="line"></span><br><span class="line">&lt;Location /ganglia&gt;</span><br><span class="line"></span><br><span class="line">    Order deny,allow</span><br><span class="line"></span><br><span class="line">    Allow from all</span><br><span class="line"></span><br><span class="line">    Allow from 127.0.0.1</span><br><span class="line"></span><br><span class="line">    Allow from ::1</span><br><span class="line"></span><br><span class="line">    # Allow from .example.com</span><br><span class="line"></span><br><span class="line">  &lt;/Location&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-3设置启动"><a href="#4-1-3设置启动" class="headerlink" title="4.1.3设置启动"></a>4.1.3设置启动</h3><p>Shell<strong>代码</strong>   </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --add gmetad  </span><br><span class="line"></span><br><span class="line"> chkconfig --add gmond  </span><br><span class="line"></span><br><span class="line"> chkconfig --add httpd</span><br></pre></td></tr></table></figure>
<h3 id="4-1-4打开端口-关闭防火墙"><a href="#4-1-4打开端口-关闭防火墙" class="headerlink" title="4.1.4打开端口/关闭防火墙"></a>4.1.4打开端口/关闭防火墙</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/iptables stop -------------------关闭防火墙,用于测试时,线上最好用打开端口方式</span><br></pre></td></tr></table></figure>
<h3 id="4-1-5关闭SELinux"><a href="#4-1-5关闭SELinux" class="headerlink" title="4.1.5关闭SELinux"></a>4.1.5关闭SELinux</h3><p>1 永久方法 – 需要重启服务器</p>
<p>修改/etc/selinux/config文件中设置SELINUX=disabled ，然后重启服务器。</p>
<p>2 临时方法 – 设置系统参数</p>
<p>使用命令setenforce 0</p>
<p>附：</p>
<p>setenforce 1 设置SELinux 成为enforcing模式</p>
<p>setenforce 0 设置SELinux 成为permissive模式</p>
<h1 id="五-监控节点的安装（每个监控节点，hadoop2，hadoop3，hadoop4都要安装）"><a href="#五-监控节点的安装（每个监控节点，hadoop2，hadoop3，hadoop4都要安装）" class="headerlink" title="五.监控节点的安装（每个监控节点，hadoop2，hadoop3，hadoop4都要安装）"></a>五.监控节点的安装（每个监控节点，hadoop2，hadoop3，hadoop4都要安装）</h1><h2 id="5-1安装ganglia-gmond"><a href="#5-1安装ganglia-gmond" class="headerlink" title="5.1安装ganglia-gmond"></a>5.1安装ganglia-gmond</h2><p>Shell<strong>代码</strong>   </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum search ganglia  </span><br><span class="line"></span><br><span class="line">yum install ganglia-gmond.x86_64</span><br></pre></td></tr></table></figure>
<h2 id="5-2配置gmond"><a href="#5-2配置gmond" class="headerlink" title="5.2配置gmond"></a>5.2配置gmond</h2><p>Shell<strong>代码</strong>   </p>
<p>vi /etc/ganglia/gmond.conf  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">cluster &#123;</span><br><span class="line"></span><br><span class="line">  name = "my cluster"    ------ cluster名称,是你在gmetad.conf里配置的data_source名称 </span><br><span class="line"></span><br><span class="line">  owner = "root"</span><br><span class="line"></span><br><span class="line">  latlong = "unspecified"</span><br><span class="line"></span><br><span class="line">  url = "unspecified"</span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">udp_send_channel &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta"> #</span> mcast_join = 239.2.11.71  ----- 组播  </span><br><span class="line"></span><br><span class="line">  host=10.2.6.250    -------------- 单播 gmeta主机的ip/主机名或者主机ip地址  </span><br><span class="line"></span><br><span class="line">  port = 8649</span><br><span class="line"></span><br><span class="line">ttl = 1</span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">udp_recv_channel &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span>mcast_join = 239.2.11.71  </span><br><span class="line"></span><br><span class="line">  port = 8649</span><br><span class="line"></span><br><span class="line">  bind = 10.2.6.246</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-3配置启动"><a href="#5-3配置启动" class="headerlink" title="5.3配置启动"></a>5.3配置启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chkconfig  --add  gmond</span><br><span class="line"></span><br><span class="line">chkconfig  --list  gmond</span><br></pre></td></tr></table></figure>
<p>此时，如果正确安装，会出现gmond           0:off   1:off   2:off   3:off   4:off   5:off   6:off</p>
<h2 id="5-4配置hosts"><a href="#5-4配置hosts" class="headerlink" title="5.4配置hosts"></a>5.4配置hosts</h2><p> vi /etc/hosts</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10.2.6.250 hadoop1</span><br><span class="line"></span><br><span class="line">10.2.6.246 hadoop2</span><br><span class="line"></span><br><span class="line">10.2.6.248 hadoop3</span><br><span class="line"></span><br><span class="line">10.2.6.249 hadoop4</span><br></pre></td></tr></table></figure>
<p><strong>全部安装完毕后</strong></p>
<p>在主机上</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">service gmetad start</span><br><span class="line"></span><br><span class="line">service gmond start</span><br><span class="line"></span><br><span class="line">service httpd start</span><br><span class="line"></span><br><span class="line">service gmetad status    -------------------验证是否启动成功</span><br><span class="line"></span><br><span class="line">service gmond status   -------------------验证是否启动成功</span><br></pre></td></tr></table></figure>
<p>在监控节点上</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service gmond start  </span><br><span class="line"></span><br><span class="line">service gmond status   -------------------验证是否启动成功</span><br></pre></td></tr></table></figure>
<p>访问<a href="http://10.2.6.250/ganglia" target="_blank" rel="noopener">http://10.2.6.250/ganglia</a></p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>Forbidden错误时,因为对apache有一个设置</p>
<p>修改 /etc/httpd/conf.d/ganglia.conf文件内容Deny from all 为 allow from all</p>
<p>There was an error collecting ganglia data (127.0.0.1:8652):fsockopen error: Permission denied </p>
<p>解决方法</p>
<p>1 永久方法 – 需要重启服务器</p>
<p>修改/etc/selinux/config文件中设置SELINUX=disabled ，然后重启服务器。</p>
<p>2 临时方法 – 设置系统参数</p>
<p>使用命令setenforce 0</p>
<p>附：</p>
<p>setenforce 1 设置SELinux 成为enforcing模式</p>
<p>setenforce 0 设置SELinux 成为permissive模式</p>
<p><strong>There was an error collecting ganglia data (127.0.0.1:8652):fsockopen error: Connection refused **</strong>解决办法**</p>
<p>卸载yum remove ganglia-web ganglia-gmetad</p>
<p>重新安装yum install ganglia-web    —– ganglia-web本身有引用gmetad</p>
<p>重启即可</p>
<p><a href="http://redhatdebian.blog.51cto.com/1197273/828992" target="_blank" rel="noopener">http://redhatdebian.blog.51cto.com/1197273/828992</a></p>
 

	    
</div>

<div class="center">
			

				<span class="post-meta">		
				<span class="iconfont icon-category"></span>
				<a class="category-link" href="/categories/大数据/">大数据</a>
				</span>
		
			

		
				
				<span class="post-meta">
				<span class="iconfont icon-tag"></span>
				<a class="tag-link" href="/tags/集群/">集群</a>
				</span>			
			


		

		<span class="post-words"><span class="iconfont icon-words"></span>
		3477
		</span>		
</div>		

		
    <a class="article-readmore" href="/2017/11/11/Linux集群资源监控/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2017/11/05/Redis使用/">Redis使用</a>  
	       
		 

		 <time>2017-11-05 </time>    
	</div>


    <div class="article-excerpt">	
	
  	

	  

	  	<h1 id="1、Redis五种数据类型"><a href="#1、Redis五种数据类型" class="headerlink" title="1、Redis五种数据类型"></a>1、Redis五种数据类型</h1><pre><code>1、字符串（String）
2、哈希（hash）
3、字符串列表（list）
4、字符串集合（set）
5、有序字符串集合（sorted set）
</code></pre><h1 id="2、字符串类型"><a href="#2、字符串类型" class="headerlink" title="2、字符串类型"></a>2、字符串类型</h1><h2 id="2-1、赋值"><a href="#2-1、赋值" class="headerlink" title="2.1、赋值"></a>2.1、赋值</h2><p>set key value：设定key持有指定的字符串value，如果该key存在则进行覆盖操作。总是返回”OK”<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/set%20key%20value.png" alt="set key value"></p>
<h2 id="2-2、取值"><a href="#2-2、取值" class="headerlink" title="2.2、取值"></a>2.2、取值</h2><p>get key：获取key的value。如果与该key关联的value不是String类型，redis将返回错误信息，因为get命令只能用于获取String value；如果该key不存在，返回(nil)。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/get%20key.png" alt="get key"><br>getset key value：先获取该key的值，然后在设置该key的值。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/getset%20key%20value.png" alt="getset key value"></p>
<h2 id="2-3、删除"><a href="#2-3、删除" class="headerlink" title="2.3、删除"></a>2.3、删除</h2><p>del key ：删除指定key<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/del%20key.png" alt="del key"></p>
<h2 id="2-4、数值增减"><a href="#2-4、数值增减" class="headerlink" title="2.4、数值增减"></a>2.4、数值增减</h2><p>incr key：将指定的key的value原子性的递增1.如果该key不存在，其初始值为0，在incr之后其值为1。如果value的值不能转成整型，如hello，该操作将执行失败并返回相应的错误信息。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/incr%20key.png" alt="incr key"><br>decr key：将指定的key的value原子性的递减1.如果该key不存在，其初始值为0，在incr之后其值为-1。如果value的值不能转成整型，如hello，该操作将执行失败并返回相应的错误信息。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/decr%20key.png" alt="decr key"></p>
<h2 id="2-5、扩展命令"><a href="#2-5、扩展命令" class="headerlink" title="2.5、扩展命令"></a>2.5、扩展命令</h2><p>incrby key increment：将指定的key的value原子性增加increment，如果该key不存在，器初始值为0，在incrby之后，该值为increment。如果该值不能转成整型，如hello则失败并返回错误信息<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/incrby%20key%20increment.png" alt="incrby key increment"><br>decrby key decrement：将指定的key的value原子性减少decrement，如果该key不存在，器初始值为0，在decrby之后，该值为decrement。如果该值不能转成整型，如hello则失败并返回错误信息<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/decrby%20key%20decrement.png" alt="decrby key decrement"><br>append key value：拼凑字符串。如果该key存在，则在原有的value后追加该值；如果该key不存在，则重新创建一个key/value<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/append%20key%20value.png" alt="append key value"></p>
<h1 id="3、hash数据类型"><a href="#3、hash数据类型" class="headerlink" title="3、hash数据类型"></a>3、hash数据类型</h1><h2 id="3-1、概述"><a href="#3-1、概述" class="headerlink" title="3.1、概述"></a>3.1、概述</h2><p>   Redis中的Hash类型可以看成具有String Key和String Value的map容器。所以该类型非常适合于存储值对象的信息。如Username、Password和Age等。如果Hash中包含很少的字段，那么该类型的数据也将仅占用很少的磁盘空间。每一个Hash可以存储4294967295个键值对。</p>
<h2 id="3-2、存值"><a href="#3-2、存值" class="headerlink" title="3.2、存值"></a>3.2、存值</h2><p>hset key field value<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/hset%20key%20field%20value.png" alt="hset key field value"><br>hmset key field value field value<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/hmset%20key%20field%20value%20field%20value.png" alt="hmset key field value field value"></p>
<h2 id="3-3、取值"><a href="#3-3、取值" class="headerlink" title="3.3、取值"></a>3.3、取值</h2><p>hget key field：返回指定的key中的field的值<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/hget%20key%20field.png" alt="hget key field"><br>hmget key fileds：获取key中的多个filed的值<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/hmget%20key%20fileds.png" alt="hmget key fileds"><br>hgetall key：获取key中的所有filed-vaule<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/hgetall%20key.png" alt="hgetall key"></p>
<h2 id="3-4、删除"><a href="#3-4、删除" class="headerlink" title="3.4、删除"></a>3.4、删除</h2><p>hdel key field [field … ] ：可以删除一个或多个字段，返回值是被删除的字段个数<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/hdel%20key%20field%20%5Bfield%20%E2%80%A6%20%5D1.png" alt="hdel key field [field … ]1"><br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/hdel%20key%20field%20%5Bfield%20%E2%80%A6%20%5D2.png" alt="hdel key field [field … ]2"><br>del key ：删除整个内容<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/del%20key%20.png" alt="del key"></p>
<h2 id="3-5、增加数字"><a href="#3-5、增加数字" class="headerlink" title="3.5、增加数字"></a>3.5、增加数字</h2><p>hincrby key field value：为某个key的某个属性增加值<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/hincrby%20key%20field%20value.png" alt="hincrby key field value"></p>
<h2 id="3-6、自学命令"><a href="#3-6、自学命令" class="headerlink" title="3.6、自学命令"></a>3.6、自学命令</h2><p>hexists key field：判断指定的key中的filed是否存在<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/hexists%20key%20field.png" alt="hexists key field"><br>hlen key：获取key所包含的field的数量<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/hlen%20key.png" alt="hlen key"><br>hkeys key ：获得所有的key<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/hkeys%20key.png" alt="hkeys key"><br>hvals key：获得所有的value<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/hvals%20key.png" alt="hvals key"></p>
<h1 id="4、list类型"><a href="#4、list类型" class="headerlink" title="4、list类型"></a>4、list类型</h1><h2 id="4-1、概述"><a href="#4-1、概述" class="headerlink" title="4.1、概述"></a>4.1、概述</h2><p>在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的普通链表一样，我们可以在其头部(left)和尾部(right)添加新的元素。在插入时，如果该键并不存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。List中可以包含的最大元素数量是4294967295。<br>    从元素插入和删除的效率视角来看，如果我们是在链表的两头插入或删除元素，这将会是非常高效的操作，即使链表中已经存储了百万条记录，该操作也可以在常量时间内完成。然而需要说明的是，如果元素插入或删除操作是作用于链表中间，那将会是非常低效的。相信对于有良好数据结构基础的开发者而言，这一点并不难理解。<br>  1、ArrayList使用数组方式存储数据，所以根据索引查询数据速度快，而新增或者删除元素时需要设计到位移操作，所以比较慢。<br>  2、LinkedList使用双向链接方式存储数据，每个元素都记录前后元素的指针，所以插入、删除数据时只是更改前后元素的指针指向即可，速度非常快，然后通过下标查询元素时需要从头开始索引，所以比较慢。<br>  3、双向链表中添加数据<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image39.png" alt="image39"><br>  4、双向链表中删除数据<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image40.png" alt="image40"></p>
<h2 id="4-2、常用命令"><a href="#4-2、常用命令" class="headerlink" title="4.2、常用命令"></a>4.2、常用命令</h2><h3 id="4-2-1、两端添加"><a href="#4-2-1、两端添加" class="headerlink" title="4.2.1、两端添加"></a>4.2.1、两端添加</h3><p>lpush key values[value1 value2…]：在指定的key所关联的list的头部插入所有的values，如果该key不存在，该命令在插入的之前创建一个与该key关联的空链表，之后再向该链表的头部插入数据。插入成功，返回元素的个数。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/lpush%20key%20values%5Bvalue1%20value2%E2%80%A6%5D.png" alt="lpush key values"><br>rpush key values[value1、value2…]：在该list的尾部添加元素。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/rpush%20key%20values%5Bvalue1%E3%80%81value2%E2%80%A6%5D.png" alt="rpush key values"></p>
<h3 id="4-2-2、查看列表"><a href="#4-2-2、查看列表" class="headerlink" title="4.2.2、查看列表"></a>4.2.2、查看列表</h3><p>lrange key start end：获取链表中从start到end的元素的值，start、end从0开始计数；也可为负数，若为-1则表示链表尾部的元素，-2则表示倒数第二个，依次类推…<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/lrange%20key%20start%20end1.png" alt="lrange key start end1"><br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/lrange%20key%20start%20end2.png" alt="lrange key start end2"></p>
<h3 id="4-2-3、两端弹出"><a href="#4-2-3、两端弹出" class="headerlink" title="4.2.3、两端弹出"></a>4.2.3、两端弹出</h3><p>lpop key：返回并弹出指定的key关联的链表中的第一个元素，即头部元素。如果该key不存在，返回nil；若key存在，则返回链表的头部元素。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/lpop%20key.png" alt="lpop key"><br>rpop key：从尾部弹出元素。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/rpop%20key.png" alt="rpop key"></p>
<h3 id="4-2-4、获取列表中元素的个数"><a href="#4-2-4、获取列表中元素的个数" class="headerlink" title="4.2.4、获取列表中元素的个数"></a>4.2.4、获取列表中元素的个数</h3><p>llen key：返回指定的key关联的链表中的元素的数量。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/llen%20key.png" alt="llen key"></p>
<h3 id="4-2-5、扩展命令"><a href="#4-2-5、扩展命令" class="headerlink" title="4.2.5、扩展命令"></a>4.2.5、扩展命令</h3><p>lpushx key value：仅当参数中指定的key存在时，向关联的list的头部插入value。如果不存在，将不进行插入<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/lpushx%20key%20value.png" alt="lpushx key value"><br>rpushx key value：在该list的尾部添加元素<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/rpushx%20key%20value.png" alt="rpushx key value"><br>lrem key count value：删除count个值为value的元素，如果count大于0，从头向尾遍历并删除count个值为value的元素，如果count小于0，则从尾向头遍历并删除。如果count等于0，则删除链表中所有等于value的元素。<br>0)初始化数据<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/lrem%20key%20count%20value.png" alt="lrem key count value"><br> 1) 从头删除，2个数字“3”<br>lrem mylist3 2 3<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/lrem%20mylist3%202%203.png" alt="lrem mylist3 2 3"><br>2) 从尾删除，2个数字“1”<br>lrem mylist3 -2 1<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/lrem%20mylist3%20-2%201.png" alt="lrem mylist3 -2 1"><br>3) 删除所有数字“2”<br>lrem mylist3 0 2<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/lrem%20mylist3%200%202.png" alt="lrem mylist3 0 2"><br>lset key index value：设置链表中的index的脚标的元素值，0代表链表的头元素，-1代表链表的尾元素。操作链表的脚标不存在则抛异常。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/lset%20key%20index%20value.png" alt="lset key index value"><br>linsert key before|after pivot value：在pivot元素前或者后插入value这个元素。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/linsert%20key%20before%7Cafter%20pivot%20value.png" alt="linsert key before|after pivot value"><br>rpoplpush resource destination：将链表中的尾部元素弹出并添加到头部。[循环操作]<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/rpoplpush%20resource%20destination.png" alt="rpoplpush resource destination"><br>1) 将mylist5右端弹出，压入到mylist6左边。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/mylist5.png" alt="mylist5"><br>2) 将mylist6右端数据弹出，压入到左端<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/mylist6.png" alt="mylist6"></p>
<h2 id="4-3、使用场景"><a href="#4-3、使用场景" class="headerlink" title="4.3、使用场景"></a>4.3、使用场景</h2><p>rpoplpush的使用场景：<br>Redis链表经常会被用于消息队列的服务，以完成多程序之间的消息交换。假设一个应用程序正在执行LPUSH操作向链表中添加新的元素，我们通常将这样的程序称之为”生产者(Producer)”，而另外一个应用程序正在执行RPOP操作从链表中取出元素，我们称这样的程序为”消费者(Consumer)”。如果此时，消费者程序在取出消息元素后立刻崩溃，由于该消息已经被取出且没有被正常处理，那么我们就可以认为该消息已经丢失，由此可能会导致业务数据丢失，或业务状态的不一致等现象的发生。然而通过使用RPOPLPUSH命令，消费者程序在从主消息队列中取出消息之后再将其插入到备份队列中，直到消费者程序完成正常的处理逻辑后再将该消息从备份队列中删除。同时我们还可以提供一个守护进程，当发现备份队列中的消息过期时，可以重新将其再放回到主消息队列中，以便其它的消费者程序继续处理。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/rpoplpush%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.png" alt="rpoplpush的使用场景"></p>
<h1 id="5、存储set"><a href="#5、存储set" class="headerlink" title="5、存储set"></a>5、存储set</h1><h2 id="5-1、概述"><a href="#5-1、概述" class="headerlink" title="5.1、概述"></a>5.1、概述</h2><pre><code>在Redis中，我们可以将Set类型看作为没有排序的字符集合，和List类型一样，我们也可以在该类型的数据值上执行添加、删除或判断某一元素是否存在等操作。需要说明的是，这些操作的时间复杂度为O(1)，即常量时间内完成次操作。Set可包含的最大元素数量是4294967295。
和List类型不同的是，Set集合中不允许出现重复的元素，这一点和C++标准库中的set容器是完全相同的。换句话说，如果多次添加相同元素，Set中将仅保留该元素的一份拷贝。和List类型相比，Set类型在功能上还存在着一个非常重要的特性，即在服务器端完成多个Sets之间的聚合计算操作，如unions、intersections和differences。由于这些操作均在服务端完成，因此效率极高，而且也节省了大量的网络IO开销。
</code></pre><h2 id="5-2、常用命令"><a href="#5-2、常用命令" class="headerlink" title="5.2、常用命令"></a>5.2、常用命令</h2><h3 id="5-2-1、添加-删除元素"><a href="#5-2-1、添加-删除元素" class="headerlink" title="5.2.1、添加/删除元素"></a>5.2.1、添加/删除元素</h3><p>sadd key values[value1、value2…]：向set中添加数据，如果该key的值已有则不会重复添加<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/sadd%20key%20values.png" alt="sadd key values"><br>srem key members[member1、member2…]：删除set中指定的成员<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/srem%20key%20members.png" alt="srem key members"></p>
<h3 id="5-2-2、获得集合中的元素"><a href="#5-2-2、获得集合中的元素" class="headerlink" title="5.2.2、获得集合中的元素"></a>5.2.2、获得集合中的元素</h3><p>smembers key：获取set中所有的成员<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/smembers%20key.png" alt="smembers key"><br>sismember key member：判断参数中指定的成员是否在该set中，1表示存在，0表示不存在或者该key本身就不存在。（无论集合中有多少元素都可以极速的返回结果）<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/sismember%20key%20member.png" alt="sismember key member"></p>
<h3 id="5-2-3、集合的差集运算-A-B"><a href="#5-2-3、集合的差集运算-A-B" class="headerlink" title="5.2.3、集合的差集运算 A-B"></a>5.2.3、集合的差集运算 A-B</h3><p>sdiff key1 key2…：返回key1与key2中相差的成员，而且与key的顺序有关。即返回差集。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/sdiff%20key1%20key2_1.png" alt="sdiff key1 key2_1">（属于A并且不属于B的元素构成的集合）<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/sdiff%20key1%20key2_2.png" alt="sdiff key1 key2_2"></p>
<h3 id="5-2-4、集合的交集运算-A-∩-B"><a href="#5-2-4、集合的交集运算-A-∩-B" class="headerlink" title="5.2.4、集合的交集运算 A ∩ B"></a>5.2.4、集合的交集运算 A ∩ B</h3><p>sinter key1 key2 key3…：返回交集。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/sinter%20key1%20key2%20key3.png" alt="sinter key1 key2 key3">（属于A且属于B的元素构成的集合）<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image67.png" alt="image67"></p>
<h3 id="5-2-5、集合的并集运算-A-∪-B"><a href="#5-2-5、集合的并集运算-A-∪-B" class="headerlink" title="5.2.5、集合的并集运算 A ∪ B"></a>5.2.5、集合的并集运算 A ∪ B</h3><p>sunion key1 key2 key3…：返回并集<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/sunion%20key1%20key2%20key3_1.png" alt="sunion key1 key2 key3_1">（属于A或者属于B的元素构成的集合）<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/sunion%20key1%20key2%20key3_2.png" alt="sunion key1 key2 key3_2"></p>
<h3 id="5-2-6、扩展命令"><a href="#5-2-6、扩展命令" class="headerlink" title="5.2.6、扩展命令"></a>5.2.6、扩展命令</h3><p>scard key：获取set中成员的数量<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/scard%20key.png" alt="scard key"><br>srandmember key：随机返回set中的一个成员<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/srandmember%20key.png" alt="srandmember key"><br>sdiffstore destination key1 key2…：将key1、key2相差的成员存储在destination上<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/sdiffstore%20destination%20key1%20key2.png" alt="sdiffstore destination key1 key2"><br>sinterstore destination key[key…]：将返回的交集存储在destination上<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/sinterstore%20destination%20key.png" alt="sinterstore destination key"><br>sunionstore destination key[key…]：将返回的并集存储在destination上<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/sunionstore%20destination%20key.png" alt="sunionstore destination key"></p>
<h2 id="5-3、使用场景"><a href="#5-3、使用场景" class="headerlink" title="5.3、使用场景"></a>5.3、使用场景</h2><p>  1、可以使用Redis的Set数据类型跟踪一些唯一性数据，比如访问某一博客的唯一IP地址信息。对于此场景，我们仅需在每次访问该博客时将访问者的IP存入Redis中，Set数据类型会自动保证IP地址的唯一性。<br>  2、充分利用Set类型的服务端聚合操作方便、高效的特性，可以用于维护数据对象之间的关联关系。比如所有购买某一电子设备的客户ID被存储在一个指定的Set中，而购买另外一种电子产品的客户ID被存储在另外一个Set中，如果此时我们想获取有哪些客户同时购买了这两种商品时，Set的intersections命令就可以充分发挥它的方便和效率的优势了。</p>
<h1 id="6、存储sortedset"><a href="#6、存储sortedset" class="headerlink" title="6、存储sortedset"></a>6、存储sortedset</h1><h2 id="6-1、概述"><a href="#6-1、概述" class="headerlink" title="6.1、概述"></a>6.1、概述</h2><p>  Sorted-Set和Set类型极为相似，它们都是字符串的集合，都不允许重复的成员出现在一个Set中。它们之间的主要差别是Sorted-Set中的每一个成员都会有一个分数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。然而需要额外指出的是，尽管Sorted-Set中的成员必须是唯一的，但是分数(score)却是可以重复的。<br>  在Sorted-Set中添加、删除或更新一个成员都是非常快速的操作，其时间复杂度为集合中成员数量的对数。由于Sorted-Set中的成员在集合中的位置是有序的，因此，即便是访问位于集合中部的成员也仍然是非常高效的。事实上，Redis所具有的这一特征在很多其它类型的数据库中是很难实现的，换句话说，在该点上要想达到和Redis同样的高效，在其它数据库中进行建模是非常困难的。<br>    例如：游戏排名、微博热点话题等使用场景。</p>
<h2 id="6-2、常用命令"><a href="#6-2、常用命令" class="headerlink" title="6.2、常用命令"></a>6.2、常用命令</h2><h3 id="6-2-1、添加元素"><a href="#6-2-1、添加元素" class="headerlink" title="6.2.1、添加元素"></a>6.2.1、添加元素</h3><p>zadd key score member score2 member2 … ：将所有成员以及该成员的分数存放到sorted-set中。如果该元素已经存在则会用新的分数替换原有的分数。返回值是新加入到集合中的元素个数，不包含之前已经存在的元素<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image75.png" alt="image75"><br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image76.png" alt="image76"></p>
<h3 id="6-2-2、获得元素"><a href="#6-2-2、获得元素" class="headerlink" title="6.2.2、获得元素"></a>6.2.2、获得元素</h3><p>zscore key member：返回指定成员的分数<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image77.png" alt="image77"><br>zcard key：获取集合中的成员数量<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image78.png" alt="image78"></p>
<h3 id="6-2-3、删除元素"><a href="#6-2-3、删除元素" class="headerlink" title="6.2.3、删除元素"></a>6.2.3、删除元素</h3><p>zrem key member[member…]：移除集合中指定的成员，可以指定多个成员。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image79.png" alt="image79"></p>
<h3 id="6-2-4、范围查询"><a href="#6-2-4、范围查询" class="headerlink" title="6.2.4、范围查询"></a>6.2.4、范围查询</h3><p>zrange key start end [withscores]：获取集合中脚标为start-end的成员，[withscores]参数表明返回的成员包含其分数<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image80.png" alt="image80"><br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image81.png" alt="image81"><br>zrevrange key start stop [withscores]：照元素分数从大到小的顺序返回索引从start到stop之间的所有元素（包含两端的元素）<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image82.png" alt="image82"><br>zremrangebyrank key start stop: 按照排名范围删除元素<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image83.png" alt="image83"><br>zremrangebyscore key min max：按照分数范围删除元素<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image84.png" alt="image84"></p>
<h3 id="6-2-5、扩展命令"><a href="#6-2-5、扩展命令" class="headerlink" title="6.2.5、扩展命令"></a>6.2.5、扩展命令</h3><p>zrangebyscore key min max [withscores] [limit offset count]：返回分数在[min,max]的成员并按照分数从低到高排序。[withscores]：显示分数；[limit offset count]：offset，表明从脚标为offset的元素开始并返回count个成员。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image85.png" alt="image85"><br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image86.png" alt="image86"><br>zincrby key increment member：设置指定成员的增加的分数。返回值是更改后的分数。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image87.png" alt="image87"><br>zcount key min max：获取分数在[min,max]之间的成员<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image88.png" alt="image88"><br>zrank key member：返回成员在集合中的排名。（从小到大）<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image89.png" alt="image89"><br>zrevrank key member：返回成员在集合中的排名。（从大到小）<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image90.png" alt="image90"></p>
<h2 id="6-3、使用场景"><a href="#6-3、使用场景" class="headerlink" title="6.3、使用场景"></a>6.3、使用场景</h2><p>  1、可以用于一个大型在线游戏的积分排行榜。每当玩家的分数发生变化时，可以执行ZADD命令更新玩家的分数，此后再通过ZRANGE命令获取积分TOPTEN的用户信息。当然我们也可以利用ZRANK命令通过username来获取玩家的排行信息。最后我们将组合使用ZRANGE和ZRANK命令快速的获取和某个玩家积分相近的其他用户的信息。<br>  2、Sorted-Set类型还可用于构建索引数据。</p>
<h1 id="7、keys的通用操作"><a href="#7、keys的通用操作" class="headerlink" title="7、keys的通用操作"></a>7、keys的通用操作</h1><p>keys pattern：获取所有与pattern匹配的key，返回所有与该key匹配的keys。*表示任意一个或多个字符，?表示任意一个字符<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image91.png" alt="image91"><br>del key1 key2…：删除指定的key<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image92.png" alt="image92"><br>exists key：判断该key是否存在，1代表存在，0代表不存在<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image93.png" alt="image93"><br>rename key newkey：为当前的key重命名<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image94.png" alt="image94"><br>expire key ：设置过期时间，单位：秒<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image95.png" alt="image95"><br>ttl key：获取该key所剩的超时时间，如果没有设置超时，返回-1。如果返回-2表示超时不存在。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image96.png" alt="image96"><br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image97.png" alt="image97"><br>type key：获取指定key的类型。该命令将以字符串的格式返回。    返回的字符串为string、list、set、hash和zset，如果key不存在返回none。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image98.png" alt="image98"></p>
 

	    
</div>

<div class="center">
			

				<span class="post-meta">		
				<span class="iconfont icon-category"></span>
				<a class="category-link" href="/categories/redis/">redis</a>
				</span>
		
			

		
				
				<span class="post-meta">
				<span class="iconfont icon-tag"></span>
				<a class="tag-link" href="/tags/redis/">redis</a> <a class="tag-link" href="/tags/命令/">命令</a>
				</span>			
			


		

		<span class="post-words"><span class="iconfont icon-words"></span>
		6313
		</span>		
</div>		

		
    <a class="article-readmore" href="/2017/11/05/Redis使用/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2017/11/05/快速排序/">快速排序</a>  
	       
		 

		 <time>2017-11-05 </time>    
	</div>


    <div class="article-excerpt">	
	
  	

	  

	  	<h2 id="1、垃圾收集器概述"><a href="#1、垃圾收集器概述" class="headerlink" title="1、垃圾收集器概述"></a><strong>1、垃圾收集器概述</strong></h2><blockquote>
<p>​       垃圾收集器是垃圾回收算法（标记-清除算法、复制算法、标记-整理算法、火车算法）的具体实现，不同商家、不同版本的JVM所提供的垃圾收集器可能会有很在差别，本文主要介绍HotSpot虚拟机中的垃圾收集器。</p>
</blockquote>
<h3 id="1-1、垃圾收集器组合"><a href="#1-1、垃圾收集器组合" class="headerlink" title="1-1、垃圾收集器组合"></a><strong>1-1、垃圾收集器组合</strong></h3><blockquote>
<p>​       JDK7/8后，HotSpot虚拟机所有收集器及组合（连线），如下图：</p>
</blockquote>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/java/img1" alt="img"></p>
<blockquote>
<p>（A）、图中展示了<strong>7种</strong>不同分代的收集器：</p>
<p>​       Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1；</p>
<p>（B）、而它们所处区域，则表明其是属于新生代收集器还是老年代收集器：</p>
<p>​      <strong>新生代收集器</strong>：Serial、ParNew、Parallel Scavenge；</p>
<p>​      <strong>老年代收集器</strong>：Serial Old、Parallel Old、CMS；</p>
<p>​      <strong>整堆收集器</strong>：G1；</p>
<p>（C）、两个收集器间有连线，表明它们<strong>可以搭配使用</strong>：</p>
<p>​       Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1；</p>
<p>（D）、其中Serial Old作为CMS出现<strong>“Concurrent Mode Failure”失败</strong>的后备预案（后面介绍）；</p>
</blockquote>
<h3 id="1-2、并发垃圾收集和并行垃圾收集的区别"><a href="#1-2、并发垃圾收集和并行垃圾收集的区别" class="headerlink" title="1-2、并发垃圾收集和并行垃圾收集的区别"></a><strong>1-2、并发垃圾收集和并行垃圾收集的区别</strong></h3><blockquote>
<p><strong>（A）、并行（Parallel）</strong></p>
<p>​       指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；</p>
<p>​       如<strong>ParNew、Parallel Scavenge、Parallel Old</strong>；</p>
<p><strong>（B）、并发（Concurrent）</strong></p>
<p>​       指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行）；</p>
<p>​      用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；    </p>
<p>​       如<strong>CMS、G1</strong>（也有并行）；</p>
</blockquote>
<h3 id="1-3、Minor-GC和Full-GC的区别"><a href="#1-3、Minor-GC和Full-GC的区别" class="headerlink" title="1-3、Minor GC和Full GC的区别"></a><strong>1-3、Minor GC和Full GC的区别</strong></h3><blockquote>
<p><strong>（A）、Minor GC</strong></p>
<p>​       又称<strong>新生代GC</strong>，指发生在新生代的垃圾收集动作；</p>
<p>​       因为Java对象大多是朝生夕灭，所以Minor GC非常频繁，一般回收速度也比较快；</p>
<p><strong>（B）、Full GC</strong></p>
<p>​       又称<strong>Major GC或老年代GC</strong>，指发生在老年代的GC；</p>
<p>​       出现Full GC经常会伴随至少一次的Minor GC（不是绝对，Parallel Sacvenge收集器就可以选择设置Major GC策略）；</p>
<p>​      Major GC速度一般比Minor GC慢10倍以上；</p>
</blockquote>
<p>​        </p>
<blockquote>
<p>下面将介绍这些收集器的特性、基本原理和使用场景，并重点分析CMS和G1这两款相对复杂的收集器；但需要明确一个观点：</p>
<p>​       没有最好的收集器，更没有万能的收集；</p>
<p>​      选择的只能是适合具体应用场景的收集器。</p>
</blockquote>
<h2 id="2、Serial收集器"><a href="#2、Serial收集器" class="headerlink" title="2、Serial收集器"></a><strong>2、Serial收集器</strong></h2><blockquote>
<p>​       Serial（串行）垃圾收集器是最基本、发展历史最悠久的收集器；</p>
<p>​       JDK1.3.1前是HotSpot新生代收集的唯一选择；</p>
<p><strong>1、特点</strong></p>
<p>​      针对新生代；</p>
<p>​      采用复制算法；</p>
<p>​      单线程收集；</p>
<p>​       进行垃圾收集时，必须暂停所有工作线程，直到完成；            </p>
<p>​       即会”Stop The World”；</p>
<p>​      <strong>Serial/Serial Old组合收集器运行示意图如下：</strong></p>
</blockquote>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/java/img2" alt="img"></p>
<blockquote>
<p><strong>2、应用场景</strong></p>
<p>​      依然是HotSpot在Client模式下默认的新生代收集器；</p>
<p>​      也有优于其他收集器的地方：</p>
<blockquote>
<p>​      简单高效（与其他收集器的单线程相比）；</p>
<p>​      对于限定单个CPU的环境来说，Serial收集器没有线程交互（切换）开销，可以获得最高的单线程收集效率；</p>
<p>​      在用户的桌面应用场景中，可用内存一般不大（几十M至一两百M），可以在较短时间内完成垃圾收集（几十MS至一百多MS）,只要不频繁发生，这是可以接受的</p>
</blockquote>
<p><strong>3、设置参数</strong></p>
<p>​      <strong>“-XX:+UseSerialGC”</strong>：添加该参数来显式的使用串行垃圾收集器；</p>
<p><strong>4、Stop TheWorld说明</strong></p>
<p>​      JVM在后台自动发起和自动完成的，在用户不可见的情况下，把用户正常的工作线程全部停掉，即<strong>GC停顿</strong>；</p>
<p>​      会带给用户不良的体验；</p>
<blockquote>
<p>​      从JDK1.3到现在，从Serial收集器-》Parallel收集器-》CMS-》G1，用户线程停顿时间不断缩短，但仍然无法完全消除；</p>
</blockquote>
<p>​      更多”Stop The World”信息请参考：<a href="http://blog.csdn.net/tjiyu/article/details/53982412" target="_blank" rel="noopener">《Java虚拟机垃圾回收(一) 基础》</a>“2-2、可达性分析算法”</p>
<p>更多Serial收集器请参考：</p>
<p>​      《Memory Management in the Java HotSpot™ Virtual Machine》 4.3节 Serial Collector（内存管理白皮书）：<a href="http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf</a></p>
<p>​      《Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide》 第5节 Available Collectors（官方的垃圾收集调优指南）：<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref27" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref27</a></p>
</blockquote>
<h2 id="3、ParNew收集器"><a href="#3、ParNew收集器" class="headerlink" title="3、ParNew收集器"></a><strong>3、ParNew收集器</strong></h2><blockquote>
<p>​      ParNew垃圾收集器是<strong>Serial收集器的多线程版本</strong>。</p>
<p><strong>1、特点</strong></p>
<p>​      除了多线程外，其余的行为、特点和Serial收集器一样；</p>
<p>​      如Serial收集器可用控制参数、收集算法、Stop The World、内存分配规则、回收策略等；</p>
<p>​      两个收集器共用了不少代码；</p>
<p>​      <strong>ParNew/Serial Old组合收集器运行示意图如下：</strong></p>
</blockquote>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/java/img3" alt="img"></p>
<blockquote>
<p><strong>2、应用场景</strong></p>
<p>​      在Server模式下，ParNew收集器是一个非常重要的收集器，因为除Serial外，目前只有它<strong>能与CMS收集器配合工作</strong>；</p>
<p>​      但在单个CPU环境中，不会比Serail收集器有更好的效果，因为存在线程交互开销。</p>
<p><strong>3、设置参数</strong></p>
<p>​      <strong>“-XX:+UseConcMarkSweepGC”</strong>：指定使用CMS后，会默认使用ParNew作为新生代收集器；</p>
<p>​      <strong>“-XX:+UseParNewGC”</strong>：强制指定使用ParNew；    </p>
<p>​      <strong>“-XX:ParallelGCThreads”</strong>：指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相同；</p>
<p><strong>4、为什么只有ParNew能与CMS收集器配合</strong></p>
<p>​      CMS是HotSpot在JDK1.5推出的第一款真正意义上的并发（Concurrent）收集器，第一次实现了让垃圾收集线程与用户线程（基本上）同时工作；</p>
<p>​      CMS作为老年代收集器，但却无法与JDK1.4已经存在的新生代收集器Parallel Scavenge配合工作；</p>
<p>​      因为Parallel Scavenge（以及G1）都没有使用传统的GC收集器代码框架，而另外独立实现；而其余几种收集器则共用了部分的框架代码；</p>
<p>​      关于CMS收集器后面会详细介绍。</p>
</blockquote>
<h2 id="4、Parallel-Scavenge收集器"><a href="#4、Parallel-Scavenge收集器" class="headerlink" title="4、Parallel Scavenge收集器"></a><strong>4、Parallel Scavenge收集器</strong></h2><blockquote>
<p>​      Parallel Scavenge垃圾收集器因为与吞吐量关系密切，也称为<strong>吞吐量收集器（Throughput Collector）</strong>。</p>
<p><strong>1、特点</strong></p>
<blockquote>
<p><strong>（A）、</strong>有一些特点与<strong>ParNew收集器相似</strong></p>
<p>​      新生代收集器；</p>
<p>​      采用复制算法；</p>
<p>​      多线程收集；</p>
<p><strong>（B）、主要特点是：它的关注点与其他收集器不同</strong></p>
<p>​      CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间；</p>
<p>​      而Parallel Scavenge收集器的目标则是<strong>达一个可控制的吞吐量（Throughput）</strong>；</p>
<p>​      <strong>关于吞吐量与收集器关注点说明详见本节后面；</strong></p>
</blockquote>
<p><strong>2、应用场景</strong></p>
<p>​      高吞吐量为目标，即减少垃圾收集时间，让用户代码获得更长的运行时间；</p>
<p>​      当应用程序运行在具有多个CPU上，对暂停时间没有特别高的要求时，即程序主要在<strong>后台进行计算，而不需要与用户进行太多交互</strong>；</p>
<p>​      例如，那些<strong>执行批量处理</strong>、订单处理、工资支付、科学计算的应用程序；</p>
<p><strong>3、设置参数</strong></p>
<p>​      Parallel Scavenge收集器提供两个参数用于精确控制吞吐量：</p>
<blockquote>
<p><strong>（A）、”-XX:MaxGCPauseMillis”</strong></p>
<p>​      控制最大垃圾收集停顿时间，大于0的毫秒数；</p>
<p>​      MaxGCPauseMillis设置得稍小，停顿时间可能会缩短，但也可能会使得吞吐量下降；</p>
<p>​      因为可能导致垃圾收集发生得更频繁；</p>
<p><strong>（B）、”-XX:GCTimeRatio”</strong></p>
<p>​      设置垃圾收集时间占总时间的比率，0&lt;n&lt;100的整数；</p>
<p>​      GCTimeRatio相当于设置吞吐量大小；</p>
<p>​      垃圾收集执行时间占应用程序执行时间的比例的计算方法是：</p>
<blockquote>
<p>​      1 / (1 + n)</p>
<p>​      例如，选项-XX:GCTimeRatio=19，设置了垃圾收集时间占总时间的5%–1/(1+19)；</p>
</blockquote>
<p>​      默认值是1%–1/(1+99)，即n=99；</p>
<p>垃圾收集所花费的时间是年轻一代和老年代收集的总时间；</p>
<p>如果没有满足吞吐量目标，则增加代的内存大小以尽量增加用户程序运行的时间；</p>
</blockquote>
<p>​      此外，还有一个值得关注的参数：</p>
<blockquote>
<p><strong>（C）、”-XX:+UseAdptiveSizePolicy”</strong></p>
<p>​      开启这个参数后，就不用手工指定一些细节参数，如：</p>
<blockquote>
<p>​      新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等；</p>
</blockquote>
<p>​      JVM会根据当前系统运行情况收集性能监控信息，动态调整这些参数，以提供最合适的停顿时间或最大的吞吐量，这种调节方式称为<strong>GC自适应的调节策略（GC Ergonomiscs）</strong>；    </p>
<p>​      <strong>这是一种值得推荐的方式</strong>：</p>
<blockquote>
<p>​      (1)、只需设置好内存数据大小（如”-Xmx”设置最大堆）；</p>
<p>​      (2)、然后使用”-XX:MaxGCPauseMillis”或”-XX:GCTimeRatio”给JVM设置一个优化目标；</p>
<p>​      (3)、那些具体细节参数的调节就由JVM自适应完成；        </p>
</blockquote>
<p>​      这也是Parallel Scavenge收集器与ParNew收集器一个重要区别；    </p>
</blockquote>
<p>​      更多目标调优和GC自适应的调节策略说明请参考：            </p>
<p>​      《Memory Management in the Java HotSpot™ Virtual Machine》 5节 Ergonomics – Automatic Selections and Behavior Tuning：<a href="http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf</a></p>
<p>​      《Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide》 第2节 Ergonomics：<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html%23ergonomics" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html#ergonomics</a></p>
<p><strong>4、吞吐量与收集器关注点说明</strong></p>
<blockquote>
<p><strong>（A）、吞吐量（Throughput）</strong></p>
<p>​      CPU用于运行用户代码的时间与CPU总消耗时间的比值；</p>
<p>​      即<strong>吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）；</strong>    </p>
<p>​      高吞吐量即减少垃圾收集时间，让用户代码获得更长的运行时间；</p>
<p><strong>（B）、垃圾收集器期望的目标（关注点）</strong></p>
<blockquote>
<p><strong>（1）、停顿时间</strong>    </p>
<p>​      停顿时间越短就适合需要与用户交互的程序；</p>
<p>​      良好的响应速度能提升用户体验；</p>
<p><strong>（2）、吞吐量</strong></p>
<p>​      高吞吐量则可以高效率地利用CPU时间，尽快完成运算的任务；</p>
<p>​      主要适合在后台计算而不需要太多交互的任务；</p>
<p><strong>（3）、覆盖区（Footprint）</strong></p>
<p>​      在达到前面两个目标的情况下，尽量减少堆的内存空间；</p>
<p>​      可以获得更好的空间局部性；</p>
</blockquote>
</blockquote>
<p>更多Parallel Scavenge收集器的信息请参考：</p>
<p>​      官方的垃圾收集调优指南 第6节：<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html%23parallel_collector" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html#parallel_collector</a></p>
<p><a href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html%23parallel_collector" target="_blank" rel="noopener">
</a></p>
<p><strong>上面介绍的都是新生代收集器，接下来开始介绍老年代收集器；</strong><a href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html%23parallel_collector" target="_blank" rel="noopener">
</a></p>
</blockquote>
<h2 id="5、Serial-Old收集器"><a href="#5、Serial-Old收集器" class="headerlink" title="5、Serial Old收集器"></a><strong>5、Serial Old收集器</strong></h2><blockquote>
<p>​      Serial Old是 <strong>Serial收集器的老年代版本</strong>；</p>
<p><strong>1、特点</strong></p>
<p>​      针对老年代；</p>
<p>​      采用”标记-整理”算法（还有压缩，Mark-Sweep-Compact）；</p>
<p>​      单线程收集；</p>
<p>​      Serial/Serial Old收集器运行示意图如下：</p>
</blockquote>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/java/img4" alt="img"></p>
<blockquote>
<p><strong>2、应用场景</strong></p>
<p>​      主要用于Client模式；</p>
<p>​      而在Server模式有两大用途：</p>
<blockquote>
<p>​      （A）、在JDK1.5及之前，与Parallel Scavenge收集器搭配使用（JDK1.6有Parallel Old收集器可搭配）；</p>
<p>​      （B）、作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用（后面详解）；</p>
</blockquote>
<p>更多Serial Old收集器信息请参考：</p>
<p>​      内存管理白皮书 4.3.2节：<a href="http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf</a></p>
</blockquote>
<h2 id="6、Parallel-Old收集器"><a href="#6、Parallel-Old收集器" class="headerlink" title="6、Parallel Old收集器"></a><strong>6、Parallel Old收集器</strong></h2><blockquote>
<p>​      Parallel Old垃圾收集器是Parallel Scavenge收集器的老年代版本；</p>
<p>​      JDK1.6中才开始提供；</p>
<p><strong>1、特点</strong></p>
<p>​      针对老年代；</p>
<p>​      采用”标记-整理”算法；</p>
<p>​      多线程收集；</p>
<p>​      <strong>Parallel Scavenge/Parallel Old收集器运行示意图如下：</strong></p>
</blockquote>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/java/img5" alt="img"></p>
<blockquote>
<p><strong>2、应用场景</strong></p>
<p>​      JDK1.6及之后用来代替老年代的Serial Old收集器；</p>
<p>​      特别是在Server模式，多CPU的情况下；</p>
<p>​      这样在注重吞吐量以及CPU资源敏感的场景，就有了Parallel Scavenge加Parallel Old收集器的”给力”应用组合；</p>
<p><strong>3、设置参数</strong></p>
<p>​      <strong>“-XX:+UseParallelOldGC”：指定使用Parallel Old收集器；</strong></p>
<p>更多Parallel Old收集器收集过程介绍请参考：</p>
<p>​      《内存管理白皮书》 4.5.2节：    <a href="https://blog.csdn.net/tjiyu/article/details/53983650" target="_blank" rel="noopener">    http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf</a></p>
</blockquote>
<h2 id="7、CMS收集器"><a href="#7、CMS收集器" class="headerlink" title="7、CMS收集器"></a><strong>7、CMS收集器</strong></h2><blockquote>
<p>​      并发标记清理（Concurrent Mark Sweep，CMS）收集器也称为并发低停顿收集器（Concurrent Low Pause Collector）或低延迟（low-latency）垃圾收集器；</p>
<p>​      在前面ParNew收集器曾简单介绍过其特点；</p>
<p><strong>1、特点</strong></p>
<p>​      针对老年代；</p>
<p>​      基于”标记-清除”算法(不进行压缩操作，产生内存碎片)；            </p>
<p>​      以获取最短回收停顿时间为目标；</p>
<p>​      并发收集、低停顿；</p>
<p>​      需要更多的内存（看后面的缺点）；</p>
<p>​            </p>
<p>​      是HotSpot在JDK1.5推出的第一款真正意义上的并发（Concurrent）收集器；</p>
<p>​      第一次实现了让垃圾收集线程与用户线程（基本上）同时工作；</p>
<p><strong>2、应用场景</strong></p>
<p>​      <strong>与用户交互较多的场景</strong>；        </p>
<p>​      希望系统停顿时间最短，注重服务的响应速度；</p>
<p>​      以给用户带来较好的体验；</p>
<p>​      如<strong>常见WEB、B/S系统的服务器上的应用</strong>；</p>
<p><strong>3、设置参数</strong></p>
<p>​      <strong>“-XX:+UseConcMarkSweepGC”：指定使用CMS收集器；</strong></p>
<p><strong>4、CMS收集器运作过程</strong></p>
<p>​      比前面几种收集器更复杂，可以分为4个步骤:</p>
<blockquote>
<p><strong>（A）、初始标记（CMS initial mark）</strong></p>
<p>​      仅标记一下GC Roots能直接关联到的对象；</p>
<p>​      速度很快；</p>
<p>​      但需要”Stop The World”；</p>
<p><strong>（B）、并发标记（CMS concurrent mark）</strong></p>
<p>​      进行GC Roots Tracing的过程；</p>
<p>​      刚才产生的集合中标记出存活对象；</p>
<p>​      应用程序也在运行；</p>
<p>​      并不能保证可以标记出所有的存活对象；</p>
<p><strong>（C）、重新标记（CMS remark）</strong></p>
<p>​      为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录；</p>
<p>​      需要”Stop The World”，且停顿时间比初始标记稍长，但远比并发标记短；</p>
<p>​      采用多线程并行执行来提升效率；</p>
<p><strong>（D）、并发清除（CMS concurrent sweep）</strong></p>
<p>​      回收所有的垃圾对象；</p>
</blockquote>
<p>​      整个过程中耗时最长的并发标记和并发清除都可以与用户线程一起工作；</p>
<p>​      所以总体上说，CMS收集器的内存回收过程与用户线程一起并发执行；</p>
<p>​      <strong>CMS收集器运行示意图如下：</strong></p>
</blockquote>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/java/img6" alt="img1"></p>
<p>​        <strong>5、CMS收集器3个明显的缺点</strong></p>
<p>​                     <strong>（A）、对CPU资源非常敏感</strong></p>
<blockquote>
<blockquote>
<p>​      并发收集虽然不会暂停用户线程，但因为占用一部分CPU资源，还是会导致应用程序变慢，总吞吐量降低。</p>
<p>​      <strong>CMS的默认收集线程数量是=(CPU数量+3)/4；</strong></p>
<p>​      当CPU数量多于4个，收集线程占用的CPU资源多于25%，对用户程序影响可能较大；不足4个时，影响更大，可能无法接受。</p>
<p>​      <strong>增量式并发收集器：</strong></p>
<blockquote>
<p>​      针对这种情况，曾出现了”增量式并发收集器”（Incremental Concurrent Mark Sweep/i-CMS）；</p>
<p>​      类似使用抢占式来模拟多任务机制的思想，让收集线程和用户线程交替运行，减少收集线程运行时间；</p>
<p>​      但效果并不理想，<strong>JDK1.6后就官方不再提倡用户使用</strong>。</p>
<p>更多请参考：</p>
<p>​      官方的《垃圾收集调优指南》8.8节 Incremental Mode：<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html%23CJAGIIEJ" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#CJAGIIEJ</a></p>
<p>​      《内存管理白皮书》 4.6.3节可以看到一些描述；</p>
</blockquote>
<p><strong>（B）、无法处理浮动垃圾,可能出现”Concurrent Mode Failure”失败</strong></p>
<blockquote>
<p><strong>（1）、浮动垃圾（Floating Garbage）</strong></p>
<p>​      <strong>在并发清除时，用户线程新产生的垃圾</strong>，称为浮动垃圾；</p>
<p>​      这使得并发清除时需要预留一定的内存空间，不能像其他收集器在老年代几乎填满再进行收集；</p>
<p>​      也要可以认为CMS所需要的空间比其他垃圾收集器大；</p>
<p>​      “-XX:CMSInitiatingOccupancyFraction”：设置CMS预留内存空间；</p>
<p>​      JDK1.5默认值为68%；</p>
<p>​      JDK1.6变为大约92%；               </p>
<p><strong>（2）、”Concurrent Mode Failure”失败</strong></p>
<p>​      如果CMS预留内存空间无法满足程序需要，就会出现一次”Concurrent Mode Failure”失败；</p>
<p>​      这时JVM启用后备预案：临时启用Serail Old收集器，而导致另一次Full GC的产生；</p>
<p>​      这样的代价是很大的，所以CMSInitiatingOccupancyFraction不能设置得太大。</p>
</blockquote>
<p><strong>（C）、产生大量内存碎片</strong></p>
<p>​      由于<strong>CMS基于”标记-清除”算法，清除后不进行压缩操作</strong>；</p>
<p>​      前面<a href="http://blog.csdn.net/tjiyu/article/details/53983064" target="_blank" rel="noopener">《Java虚拟机垃圾回收(二) 垃圾回收算法》</a>“标记-清除”算法介绍时曾说过：</p>
<blockquote>
<p>​      产生大量不连续的内存碎片会导致分配大内存对象时，无法找到足够的连续内存，从而需要提前触发另一次Full GC动作。</p>
</blockquote>
<p>​      解决方法：                </p>
<blockquote>
<p><strong>（1）、”-XX:+UseCMSCompactAtFullCollection”</strong></p>
<p>​      使得CMS出现上面这种情况时不进行Full GC，而开启内存碎片的合并整理过程；</p>
<p>​      但合并整理过程无法并发，停顿时间会变长；</p>
<p>​      默认开启（但不会进行，结合下面的CMSFullGCsBeforeCompaction）；</p>
<p><strong>（2）、”-XX:+CMSFullGCsBeforeCompaction”</strong></p>
<p>​      设置执行多少次不压缩的Full GC后，来一次压缩整理；</p>
<p>​      为减少合并整理过程的停顿时间；</p>
<p>​      默认为0，也就是说每次都执行Full GC，不会进行压缩整理；</p>
</blockquote>
<p>​      由于空间不再连续，CMS需要使用可用”空闲列表”内存分配方式，这比简单实用”碰撞指针”分配内存消耗大；</p>
<p>​      更多关于内存分配方式请参考：《<a href="http://blog.csdn.net/tjiyu/article/details/53923392" target="_blank" rel="noopener">Java对象在Java虚拟机中的创建过程</a>》</p>
</blockquote>
<p>​      <strong>总体来看，与Parallel Old垃圾收集器相比，CMS减少了执行老年代垃圾收集时应用暂停的时间；</strong></p>
<p>​      <strong>但却增加了新生代垃圾收集时应用暂停的时间、降低了吞吐量而且需要占用更大的堆空间；</strong></p>
<p>更多CMS收集器信息请参考：</p>
<p>​      《垃圾收集调优指南》 8节 Concurrent Mark Sweep (CMS) Collector：<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html%23concurrent_mark_sweep_cms_collector" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector</a></p>
<p>​      《内存管理白皮书》 4.6节 Concurrent Mark-Sweep (CMS) Collector：<a href="http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf</a></p>
</blockquote>
<h2 id="8、G1收集器"><a href="#8、G1收集器" class="headerlink" title="8、G1收集器"></a><strong>8、G1收集器</strong></h2><blockquote>
<p>​      G1（<strong>Garbage-First</strong>）是<strong>JDK7-u4</strong>才推出商用的收集器；</p>
<p><strong>1、特点</strong></p>
<blockquote>
<p><strong>（A）、并行与并发</strong></p>
<p>​      能充分利用多CPU、多核环境下的硬件优势；</p>
<p>​      可以并行来缩短”Stop The World”停顿时间；</p>
<p>​      也可以并发让垃圾收集与用户程序同时进行；</p>
<p><strong>（B）、分代收集，收集范围包括新生代和老年代</strong>    </p>
<p>​      能独立管理整个GC堆（新生代和老年代），而不需要与其他收集器搭配；</p>
<p>​      能够采用不同方式处理不同时期的对象；</p>
<p>​                </p>
<p>​      虽然保留分代概念，但Java堆的内存布局有很大差别；</p>
<p>​      将整个堆划分为多个大小相等的独立区域（Region）；</p>
<p>​      新生代和老年代不再是物理隔离，它们都是一部分Region（不需要连续）的集合；</p>
<p>​      更多G1内存布局信息请参考：</p>
<blockquote>
<p>​      《垃圾收集调优指南》 9节：<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html%23garbage_first_garbage_collection" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection</a></p>
</blockquote>
<p><strong>（C）、结合多种垃圾收集算法，空间整合，不产生碎片</strong></p>
<p>​      从整体看，是基于标记-整理算法；</p>
<p>​      从局部（两个Region间）看，是基于复制算法；</p>
<p>​      这是一种类似火车算法的实现；</p>
<p>​      都不会产生内存碎片，有利于长时间运行；</p>
<p><strong>（D）、可预测的停顿：低停顿的同时实现高吞吐量</strong></p>
<p>​      G1除了追求低停顿处，还能建立可预测的停顿时间模型；</p>
<p>​      可以明确指定M毫秒时间片内，垃圾收集消耗的时间不超过N毫秒；</p>
</blockquote>
<p><strong>2、应用场景</strong></p>
<p>​      面向服务端应用，针对具有大内存、多处理器的机器；</p>
<p>​      最主要的应用是为需要低GC延迟，并具有大堆的应用程序提供解决方案；</p>
<p>​      如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；</p>
<p>​            </p>
<p>​      用来替换掉JDK1.5中的CMS收集器；</p>
<p>​      <strong>在下面的情况时，使用G1可能比CMS好</strong>：</p>
<blockquote>
<p>​      （1）、超过50％的Java堆被活动数据占用；</p>
<p>​      （2）、对象分配频率或年代提升频率变化很大；</p>
<p>​      （3）、GC停顿时间过长（长于0.5至1秒）。</p>
</blockquote>
<p>​      <strong>是否一定采用G1呢？也未必：</strong></p>
<blockquote>
<p>​      如果现在采用的收集器没有出现问题，不用急着去选择G1；</p>
<p>​      如果应用程序追求低停顿，可以尝试选择G1；</p>
<p>​      是否代替CMS需要实际场景测试才知道。</p>
</blockquote>
<p><strong>3、设置参数</strong></p>
<p>​      <strong>“-XX:+UseG1GC”：指定使用G1收集器；</strong></p>
<p>​      <strong>“-XX:InitiatingHeapOccupancyPercent”：当整个Java堆的占用率达到参数值时，开始并发标记阶段；默认为45；</strong></p>
<p>​      <strong>“-XX:MaxGCPauseMillis”：为G1设置暂停时间目标，默认值为200毫秒；</strong></p>
<p>​      <strong>“-XX:G1HeapRegionSize”：设置每个Region大小，范围1MB到32MB；目标是在最小Java堆时可以拥有约2048个Region；</strong></p>
<p>​      更多关于G1参数设置请参考：</p>
<blockquote>
<p>​      《垃圾收集调优指南》 10.5节：<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html%23important_defaults" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#important_defaults</a></p>
</blockquote>
<p><strong>4、为什么G1收集器可以实现可预测的停顿</strong></p>
<p>​      G1可以建立可预测的停顿时间模型，是因为：</p>
<blockquote>
<p>​      可以有计划地避免在Java堆的进行全区域的垃圾收集；</p>
<p>​      G1跟踪各个Region获得其收集价值大小，在后台维护一个优先列表；</p>
<p>​      每次根据允许的收集时间，优先回收价值最大的Region（名称Garbage-First的由来）；</p>
<p>​      这就保证了在有限的时间内可以获取尽可能高的收集效率；</p>
</blockquote>
<p><strong>5、一个对象被不同区域引用的问题</strong></p>
<p>​      一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</p>
<p>​      在其他的分代收集器，也存在这样的问题（而G1更突出）：</p>
<blockquote>
<p>​      回收新生代也不得不同时扫描老年代？</p>
</blockquote>
<p>​      这样的话会降低Minor GC的效率；</p>
<p>​      <strong>解决方法：</strong></p>
<blockquote>
<p>​      无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描：</p>
<blockquote>
<p>​      每个Region都有一个对应的Remembered Set；</p>
<p>​      每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；</p>
<p>​      然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；</p>
<p>​      如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；</p>
<p>​                    </p>
<p>​      当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；</p>
<p>​      就可以保证不进行全局扫描，也不会有遗漏。</p>
</blockquote>
</blockquote>
<p><strong>6、G1收集器运作过程</strong></p>
<p>​      不计算维护Remembered Set的操作，可以分为4个步骤（与CMS较为相似）。</p>
<blockquote>
<p><strong>（A）、初始标记（Initial Marking）</strong></p>
<p>​      仅标记一下GC Roots能直接关联到的对象；</p>
<p>​      且修改TAMS（Next Top at Mark Start）,让下一阶段并发运行时，用户程序能在正确可用的Region中创建新对象；</p>
<p>​      需要”Stop The World”，但速度很快；</p>
<p><strong>（B）、并发标记（Concurrent Marking）</strong></p>
<p>​      进行GC Roots Tracing的过程；</p>
<p>​      刚才产生的集合中标记出存活对象；</p>
<p>​      耗时较长，但应用程序也在运行；</p>
<p>​      并不能保证可以标记出所有的存活对象；</p>
<p><strong>（C）、最终标记（Final Marking）</strong></p>
<p>​      为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录；</p>
<p>​      上一阶段对象的变化记录在线程的Remembered Set Log；</p>
<p>​      这里把Remembered Set Log合并到Remembered Set中；</p>
<p>​                    </p>
<p>​      需要”Stop The World”，且停顿时间比初始标记稍长，但远比并发标记短；</p>
<p>​      采用多线程并行执行来提升效率；</p>
<p><strong>（D）、筛选回收（Live Data Counting and Evacuation）</strong></p>
<p>​      首先排序各个Region的回收价值和成本；</p>
<p>​      然后根据用户期望的GC停顿时间来制定回收计划；</p>
<p>​      最后按计划回收一些价值高的Region中垃圾对象；</p>
<p>​                    </p>
<p>​      回收时采用”复制”算法，从一个或多个Region复制存活对象到堆上的另一个空的Region，并且在此过程中压缩和释放内存；</p>
<p>​      可以并发进行，降低停顿时间，并增加吞吐量；</p>
</blockquote>
<p>​      <strong>G1收集器运行示意图如下：</strong></p>
</blockquote>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/java/img7" alt="img"></p>
 

	    
</div>

<div class="center">
			

				<span class="post-meta">		
				<span class="iconfont icon-category"></span>
				<a class="category-link" href="/categories/java/">java</a>
				</span>
		
			

		
				
				<span class="post-meta">
				<span class="iconfont icon-tag"></span>
				<a class="tag-link" href="/tags/java/">java</a> <a class="tag-link" href="/tags/复习/">复习</a>
				</span>			
			


		

		<span class="post-words"><span class="iconfont icon-words"></span>
		11400
		</span>		
</div>		

		
    <a class="article-readmore" href="/2017/11/05/快速排序/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2017/04/12/安装 Ruby, Rails 运行环境/">安装 Ruby, Rails 运行环境</a>  
	       
		 

		 <time>2017-04-12 </time>    
	</div>


    <div class="article-excerpt">	
	
  	

	  

	  	<h2 id="步骤1-－-安装-RVM"><a href="#步骤1-－-安装-RVM" class="headerlink" title="步骤1 － 安装 RVM"></a>步骤1 － 安装 RVM</h2><p>直接以如下命令行安装可能会不成功，因为rvm.io站点有时会被墙：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.rvm.io | bash -s stable</span><br><span class="line">#或者</span><br><span class="line">curl -L https://rvm.io | bash -s stable</span><br></pre></td></tr></table></figure>
<p>没关系，我们可以直接从git仓库里下载并安装RVM，首先本地新建文件夹rvm:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir rvm</span><br><span class="line">cd rvm</span><br></pre></td></tr></table></figure>
<p>然后依次执行如下命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Install mpapis public key (might need `gpg2` and or `sudo`)</span><br><span class="line">gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3</span><br><span class="line"></span><br><span class="line"># Download the installer</span><br><span class="line">curl -O https://raw.githubusercontent.com/rvm/rvm/master/binscripts/rvm-installer</span><br><span class="line">curl -O https://raw.githubusercontent.com/rvm/rvm/master/binscripts/rvm-installer.asc</span><br><span class="line"></span><br><span class="line"># Verify the installer signature (might need `gpg2`), and if it validates...</span><br><span class="line">gpg --verify rvm-installer.asc &amp;&amp;</span><br><span class="line"></span><br><span class="line"># Run the installer</span><br><span class="line">bash rvm-installer stable</span><br></pre></td></tr></table></figure>
<p>如果gpg –keyserver命令失败，用如下命令代替:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://rvm.io/mpapis.asc | gpg --import -</span><br></pre></td></tr></table></figure>
<p>如果不出什么错误，RVM已经安装到系统上了，可以使用了。然后，载入 RVM 环境（新开 Termal 就不用这么做了，会自动重新载入的）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source ~/.rvm/scripts/rvm</span><br></pre></td></tr></table></figure>
<p>修改 RVM 下载 Ruby 的源，到 Ruby China 的镜像:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;ruby_url=https://cache.ruby-china.org/pub/ruby&quot; &gt; ~/.rvm/user/db</span><br></pre></td></tr></table></figure>
<p>检查一下是否安装正确</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rvm -v</span><br><span class="line">rvm 1.22.17 (stable) by Wayne E. Seguin &lt;wayneeseguin@gmail.com&gt;, Michal Papis &lt;mpapis@gmail.com&gt; [https://rvm.io/]</span><br></pre></td></tr></table></figure>
<h2 id="步骤2-－-用-RVM-安装-Ruby-环境"><a href="#步骤2-－-用-RVM-安装-Ruby-环境" class="headerlink" title="步骤2 － 用 RVM 安装 Ruby 环境"></a>步骤2 － 用 RVM 安装 Ruby 环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rvm requirements</span><br><span class="line">$ rvm install 2.3.0</span><br></pre></td></tr></table></figure>
<p>同样继续等待漫长的下载，编译过程，完成以后，Ruby, Ruby Gems 就安装好了。</p>
<h2 id="步骤3-－-设置-Ruby-版本"><a href="#步骤3-－-设置-Ruby-版本" class="headerlink" title="步骤3 － 设置 Ruby 版本"></a>步骤3 － 设置 Ruby 版本</h2><p>RVM 装好以后，需要执行下面的命令将指定版本的 Ruby 设置为系统默认版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm use 2.3.0 --default</span><br></pre></td></tr></table></figure>
<p>同样，也可以用其他版本号，前提是你有用 rvm install 安装过那个版本</p>
<p>这个时候你可以测试是否正确</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ruby -v</span><br><span class="line">ruby 2.3.0 ...</span><br><span class="line"></span><br><span class="line">$ gem -v</span><br><span class="line">2.1.6</span><br><span class="line"></span><br><span class="line">$ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/</span><br></pre></td></tr></table></figure>
<h3 id="安装-Bundler"><a href="#安装-Bundler" class="headerlink" title="安装 Bundler"></a>安装 Bundler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install bundler</span><br></pre></td></tr></table></figure>
<h2 id="步骤4-－-安装-Rails-环境"><a href="#步骤4-－-安装-Rails-环境" class="headerlink" title="步骤4 － 安装 Rails 环境"></a>步骤4 － 安装 Rails 环境</h2><p>上面 3 个步骤过后，Ruby 环境就安装好了，接下来安装 Rails</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install rails</span><br></pre></td></tr></table></figure>
<p>然后测试安装是否正确</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rails -v</span><br><span class="line">Rails 4.2.5</span><br></pre></td></tr></table></figure>
<p>转载：</p>
<p><a href="https://yq.aliyun.com/articles/24866" target="_blank" rel="noopener">inux下安装ruby版本管理器RVM</a></p>
<p><a href="https://ruby-china.org/wiki/install_ruby_guide" target="_blank" rel="noopener">如何快速正确的安装 Ruby, Rails 运行环境</a></p>
 

	    
</div>

<div class="center">
			

				<span class="post-meta">		
				<span class="iconfont icon-category"></span>
				<a class="category-link" href="/categories/redis/">redis</a>
				</span>
		
			

		
				
				<span class="post-meta">
				<span class="iconfont icon-tag"></span>
				<a class="tag-link" href="/tags/redis/">redis</a>
				</span>			
			


		

		<span class="post-words"><span class="iconfont icon-words"></span>
		1582
		</span>		
</div>		

		
    <a class="article-readmore" href="/2017/04/12/安装 Ruby, Rails 运行环境/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2017/01/11/jvm虚拟机/">jvm虚拟机</a>  
	       
		 

		 <time>2017-01-11 </time>    
	</div>


    <div class="article-excerpt">	
	
  	

	  

	  	<h1 id="jvm内存概况"><a href="#jvm内存概况" class="headerlink" title="jvm内存概况"></a>jvm内存概况</h1><p>JVM内存包含大致如下：<br><img src="http://i2.51cto.com/images/blog/201802/02/f157091262e858690f68ad993b01e44c.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="jvm内存详解-----详解------详解"></p>
<hr>
<p>Java内存≈Heap(堆内存)+PermGen(方法区)+Thrend(栈)<br>Heap（堆内存）=Young（年轻代）+Old（老年代）</p>
<p>Young（年轻代）=EdenSpace+From Survivor+To Survivor</p>
<h1 id="设置jvm内存关键字"><a href="#设置jvm内存关键字" class="headerlink" title="设置jvm内存关键字"></a>设置jvm内存关键字</h1><table>
<thead>
<tr>
<th>关键字</th>
<th>解释</th>
<th>关键字</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>-Xms</td>
<td>堆内存最小空间</td>
<td>-Xmx</td>
<td>堆内存最大空间</td>
</tr>
<tr>
<td>-XX:NewSize</td>
<td>新生代最小空间</td>
<td>-XX:MaxNewSize</td>
<td>新生代最大空间</td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>永久带最小空间(方法区)</td>
<td>–XX:MaxPermSize</td>
<td>永久带最大空间（方法区）</td>
</tr>
<tr>
<td>-Xss</td>
<td>设置每个线程栈的大小</td>
<td>-XX:SurvivorRatio</td>
<td>Eden和其中一个Survivor的比值</td>
</tr>
<tr>
<td>-XX:InitialTenuringThreshol</td>
<td>晋升到老年代的对象年龄的最小值</td>
<td>-XX:MaxTenuringThreshold</td>
<td>晋升到老年代的对象年龄的最大值</td>
</tr>
</tbody>
</table>
<p>没有直接设置老年代大小的参数，但是可以通过设置堆内存和新生代内存大大小来计算老年代的大小。jvm中新生代和From survivor和To survivor的比例是8：1：1所以<br>老年代内存大小=堆内存-新生代内存大小-（新生代 x 1/5）<br>从更高的维度来看内存之间的关系会得到如下结论，方法去和堆内存都是所有线程共享的内存区域。而java栈是线程私有的内存空间。</p>
<h1 id="Java堆内存（Heap）解释"><a href="#Java堆内存（Heap）解释" class="headerlink" title="Java堆内存（Heap）解释"></a>Java堆内存（Heap）解释</h1><p>对于大多数应用程序来说，Java堆是Java虚拟机所管理的虚拟内存中最大的一块内存，Java堆是被所有线程共享的一块内存区域。在虚拟机启动时创建，此内存唯一目的是存放对象实例。<br>Java对内存垃圾收集器（GC）的主要工作对象。<br>jvm堆内存的最大空间和最小空间的微妙之处</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-Xms指定堆内存初始化分配的空间，如果不指定默认是物理内存的1/64；</span><br><span class="line">-Xmx指定堆内存的最大分配空间，如果不指定默认是无内存的1/4；</span><br><span class="line">默认情况下堆内存可用空间小于40%时候，JVM会增加堆内存到最大内存或物理内存的1/4；</span><br><span class="line">默认情况下堆内存可用空间大于70%时候，JVM会减小堆内存到最小内存或物理内存的1/64;</span><br><span class="line">因此服务器设置的初始化内存和最大内存值为一样，是为了避免GC发生后不断调整堆的大小。建议堆的最大值是可用内存的80%</span><br></pre></td></tr></table></figure>
<p>Java Heap中包括年轻代和老年代，其实还包括一个Permanent。<br>年轻代保存实例化的对象，当该区被填满时，GC会将对象移动到old区。Permanent区负责保存反射对象。</p>
<h2 id="Eden、From-survivor、To-survivor"><a href="#Eden、From-survivor、To-survivor" class="headerlink" title="Eden、From survivor、To survivor"></a>Eden、From survivor、To survivor</h2><p>介绍下堆内存中的Eden、From survivor、To survivor直接微妙的联系</p>
<ol>
<li>我们先来屡屡，为什么需要把堆分代？不分代不能完成他所做的事情么？其实不分代完全可以，分代的唯一理由就是优化GC性能。你先想想，如果没有分代，那我们所有的对象都在一块，GC的时候我们要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而我们的很多对象都是朝生夕死的，如果分代的话，我们把新创建的对象放到某一地方，当GC的时候先把这块存“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</li>
<li>HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1,为啥默认会是这个比例，接下来我们会聊到。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。</li>
</ol>
<p>因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p>
<p>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。<img src="http://i2.51cto.com/images/blog/201802/02/de44f64c1c09f0c69af30571cf645626.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="jvm内存详解-----详解------详解"></p>
<h2 id="一个对象的这一辈子"><a href="#一个对象的这一辈子" class="headerlink" title="一个对象的这一辈子"></a>一个对象的这一辈子</h2><p>我是一个普通的Java对象，我出生在Eden区，在Eden区我还看到和我长的很像的小兄弟，我们在Eden区中玩了挺长时间。有一天Eden区中的人实在是太多了，我就被迫去了Survivor区的“From”区，自从去了Survivor区，我就开始漂了，有时候在Survivor的“From”区，有时候在Survivor的“To”区，居无定所。直到我18岁的时候，爸爸说我成人了，该去社会上闯闯了。于是我就去了年老代那边，年老代里，人很多，并且年龄都挺大的，我在这里也认识了很多人。在年老代里，我生活了20年(每次GC加一岁)，然后被回收。</p>
<h1 id="方法区（PermGen）解释"><a href="#方法区（PermGen）解释" class="headerlink" title="方法区（PermGen）解释"></a>方法区（PermGen）解释</h1><p>各个线程共享的内存区域，用于存储以备虚拟机加载的类信息，常量、静态变量、即时编译器、编译后的代码等数据。又名Non-Heap、永久代。并不是说数据进入永久代就永久存在了。<br>这个区域的回收主要是针对常量池的回收和对类型的写在，一般来说这个区域的回收成绩比较难以令人满意，尤其是类型的卸载条件相当苛刻。<br>jvm非堆内存的最大空间和最小空间的微妙感觉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法区用于存放Class和Meta信息，Class在被Load的时候被放入该区域。它和存放类实例的Heap区域不同，GC不会再主程序运行期间对方法去进行GC操作。</span><br><span class="line">-XX：PermSize设置非堆内存初始值，默认是物理内存的1/64;</span><br><span class="line">-XX:MaxPermSize设置非堆内存最大值，默认是物理内存的1/4;</span><br><span class="line">因为对PermGen区的GC回收条件比较苛刻，所以如果你的APP一次性会LOAD很多Class的话，可能会出现PermGen space错误的。</span><br></pre></td></tr></table></figure>
<h1 id="GC线程"><a href="#GC线程" class="headerlink" title="GC线程"></a>GC线程</h1><p>Jvm有2个GC线程，第一个线程负责回收Heap的Young区。第二个线程在Heap不足时，遍历Heap，使Young区升级为Older区，Older区的大小等于堆内存大小减去新生代大小。不能将堆内存最小值设置过大，因为第二个线程被迫运行会降低jvm的性能。<br>频繁发生GC的原因有如下几个原因：</p>
<ul>
<li><p>程序内调用了System.gc()或Runtime.gc()</p>
</li>
<li><p>一些中间件调用自己的GC方法，此时需要设置参数禁止这些GC。</p>
</li>
<li><p>Java的Heap太小，一般默认的Heap值都很小。</p>
</li>
<li><p>频繁实例化对象，Release对象 此时尽量保存并重用对象，例如使用StringBuffer()和String().<br>如果你发现每次GC后，Heap的剩余空间会是总空间的50%，这表示你的Heap处于健康状态，许多Server端的Java程序每次GC后最好能有65%的剩余空间。<br>——–以下是网友经验之谈——-<br>1.Server端Jvm最好将-Xms和-Xmx设为相同值。为了优化GC，最好让-Xmn（新生代）与等于堆最大内存的1/3。<br>2.一个GUI程序最好每10秒到20秒运行一次GC，每次在半秒之内完成。注意</p>
<p>1.增加Heap的大小虽然会降低GC频率，但也增加了每次GC的时间。并且GC运行时，所有的用户线程将暂停，也就是GC期间，Java应用程序不做任何工作。<br>2.Heap大小并不决定进程的内存使用量。进程的内存使用量要大于-Xmx定义的值，因为Java为其他任务分配内存，例如每个线程的Stack等</p>
<p> 内存溢出</p>
<p>弄java得程序员肯定对内存溢出这个不陌生吧，对我来说确实是一个挺无奈的关键字，之前出现这个问题，直接给jvm加内存，可是治标不治本，因为不知道原理，通过近期的研究算是吧jvm的基本机制弄得明白了，来看看jvm内存溢出的几种情况。</p>
<h2 id="OutOfMemoryError：Java-heap-space"><a href="#OutOfMemoryError：Java-heap-space" class="headerlink" title="OutOfMemoryError：Java heap space"></a>OutOfMemoryError：Java heap space</h2><p>这是jvm的堆内存溢出，在jvm中98%的内存都在等待GC回收，且Heap Size不足2%的可用空间时，将抛出此错误，对应的解决办法增加-xmx和-xms的大小。</p>
<ul>
<li><h2 id="OutOfMemoryError：PermGen-Space"><a href="#OutOfMemoryError：PermGen-Space" class="headerlink" title="OutOfMemoryError：PermGen Space"></a>OutOfMemoryError：PermGen Space</h2><p>这是jvm的非堆内存溢出，可能情况有如下几种</p>
</li>
<li><p>如果web app下用大量的第三方jar，其总大小超过非堆内存的最大值，会抛出此异常</p>
</li>
<li><p>项目拥有太多的class文件，恰好maxPermSize设置的小于class总大小，会抛出此异常</p>
</li>
<li><p>tomcat部署的时候，不会清理前面加载的环境，只会将context更改为新部署的代码，所以非堆内存越来越多OutOfMemoryError：unable to new native thread：</p>
<p>这是jvm无法创建新线程，这个错误比较少见，也比较奇怪。主要是jvm与内存的比例有关。这种怪事因为jvm已经被系统分配了大量的内存。并且它至少占用可用内存的一半空间。可以尝试重启tomcat或加大非堆内存对应的值。</p>
</li>
</ul>
</li>
</ul>
<p>转载：<a href="http://blog.51cto.com/xinsir/2068032" target="_blank" rel="noopener">http://blog.51cto.com/xinsir/2068032</a></p>
 

	    
</div>

<div class="center">
			

				<span class="post-meta">		
				<span class="iconfont icon-category"></span>
				<a class="category-link" href="/categories/java/">java</a>
				</span>
		
			

		
				
				<span class="post-meta">
				<span class="iconfont icon-tag"></span>
				<a class="tag-link" href="/tags/java/">java</a> <a class="tag-link" href="/tags/复习/">复习</a>
				</span>			
			


		

		<span class="post-words"><span class="iconfont icon-words"></span>
		4028
		</span>		
</div>		

		
    <a class="article-readmore" href="/2017/01/11/jvm虚拟机/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2016/10/05/mongoDB文档数据库/">mongoDB文档数据库</a>  
	       
		 

		 <time>2016-10-05 </time>    
	</div>


    <div class="article-excerpt">	
	
  	

	  

	  	<h1 id="1-MongoDB简介"><a href="#1-MongoDB简介" class="headerlink" title="1.MongoDB简介"></a>1.MongoDB简介</h1><h2 id="1-1什么是MongoDB"><a href="#1-1什么是MongoDB" class="headerlink" title="1.1什么是MongoDB"></a>1.1什么是MongoDB</h2><p>​        MongoDB 是一个跨平台的，面向文档的数据库，是当前 NoSQL 数据库产品中最热门的一种。它介于关系数据库和非关系数据库之间，是非关系数据库当中功能最丰富，最像关系数据库的产品。它支持的数据结构非常松散，是类似JSON  的 BSON 格式，因此可以存储比较复杂的数据类型。</p>
<p>MongoDB 的官方网站地址是：<a href="http://www.mongodb.org/" target="_blank" rel="noopener">http://www.mongodb.org/</a></p>
<h2 id="1-2-MongoDB特点"><a href="#1-2-MongoDB特点" class="headerlink" title="1.2 MongoDB特点"></a>1.2 MongoDB特点</h2><p>​       MongoDB 最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。它是一个面向集合的,模式自由的文档型数据库。</p>
<p>具体特点总结如下：</p>
<p>（1）面向集合存储，易于存储对象类型的数据</p>
<p>（2）模式自由</p>
<p>（3）支持动态查询</p>
<p>（4）支持完全索引，包含内部对象</p>
<p>（5）支持复制和故障恢复</p>
<p>（6）使用高效的二进制数据存储，包括大型对象（如视频等）</p>
<p>（7）自动处理碎片，以支持云计算层次的扩展性</p>
<p>（8）支持 Python，PHP，Ruby，Java，C，C#，Javascript，Perl 及 C++语言的驱动程序，社区中也提供了对 Erlang 及.NET 等平台的驱动程序</p>
<p>（9） 文件存储格式为 BSON（一种 JSON 的扩展）</p>
<h2 id="1-3-MongoDB体系结构"><a href="#1-3-MongoDB体系结构" class="headerlink" title="1.3 MongoDB体系结构"></a>1.3 MongoDB体系结构</h2><p>MongoDB 的逻辑结构是一种层次结构。主要由：</p>
<p>文档(document)、集合(collection)、数据库(database)这三部分组成的。逻辑结构是面向用户</p>
<p>的，用户使用 MongoDB 开发应用程序使用的就是逻辑结构。</p>
<p>（1）MongoDB 的文档（document），相当于关系数据库中的一行记录。</p>
<p>（2）多个文档组成一个集合（collection），相当于关系数据库的表。</p>
<p>（3）多个集合（collection），逻辑上组织在一起，就是数据库（database）。</p>
<p>（4）一个 MongoDB 实例支持多个数据库（database）。</p>
<p>文档(document)、集合(collection)、数据库(database)的层次结构如下图:</p>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image4.png" alt="image4"></p>
<p>下表是MongoDB与MySQL数据库逻辑结构概念的对比</p>
<table>
<thead>
<tr>
<th>MongoDb</th>
<th>关系型数据库Mysql</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据库(databases)</td>
<td>数据库(databases)</td>
</tr>
<tr>
<td>集合(collections)</td>
<td>表(table)</td>
</tr>
<tr>
<td>文档(document)</td>
<td>行(row)</td>
</tr>
</tbody>
</table>
<h1 id="2-基本增删改查操作"><a href="#2-基本增删改查操作" class="headerlink" title="2.基本增删改查操作"></a>2.基本增删改查操作</h1><h2 id="2-1选择或创建数据库"><a href="#2-1选择或创建数据库" class="headerlink" title="2.1选择或创建数据库"></a>2.1选择或创建数据库</h2><p>使用use 数据库名称即可选择数据库，如果该数据库不存在会自动创建</p>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image12.png" alt="image12"></p>
<h2 id="2-2插入文档"><a href="#2-2插入文档" class="headerlink" title="2.2插入文档"></a>2.2插入文档</h2><p>文档相当于关系数据库中的记录</p>
<p>首先我们定义一个文档变量，格式为变量名称={}; 例如：</p>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image13.png" alt="image13"></p>
<p>接下来就是将这个变量存入MongoDB </p>
<p>格式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.集合名称.save(变量);</span><br></pre></td></tr></table></figure>
<p>这里的集合就相当于关系数据库中的表。例如：</p>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image14.png" alt="image14"></p>
<p>这样就在student集合中存入文档。如果这个student集合不存在，就会自动创建。</p>
<p>当然，你也可以不用定义变量，直接把变量值放入save方法中也是可以地。</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image15.png" alt="image15"></p>
<p>为了方便后期测试，我们再多加点数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.student.save(&#123;name:<span class="string">"沙和尚"</span>,sex:<span class="string">"男"</span>,age:<span class="number">25</span>,address:<span class="string">"流沙河路11号"</span>&#125;);</span><br><span class="line">db.student.save(&#123;name:<span class="string">"唐僧"</span>,sex:<span class="string">"男"</span>,age:<span class="number">35</span>,address:<span class="string">"东土大唐"</span>&#125;);</span><br><span class="line">db.student.save(&#123;name:<span class="string">"白骨精"</span>,sex:<span class="string">"女"</span>,age:<span class="number">18</span>,address:<span class="string">"白骨洞"</span>&#125;);</span><br><span class="line">db.student.save(&#123;name:<span class="string">"白龙马"</span>,sex:<span class="string">"男"</span>,age:<span class="number">20</span>,address:<span class="string">"西海"</span>&#125;);</span><br><span class="line">db.student.save(&#123;name:<span class="string">"哪吒"</span>,sex:<span class="string">"男"</span>,age:<span class="number">15</span>,address:<span class="string">"莲花湾小区"</span>&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="2-3查询集合"><a href="#2-3查询集合" class="headerlink" title="2.3查询集合"></a>2.3查询集合</h2><p>我们要查询某集合的所有文档，使用find()方法。语法格式为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.集合名称.find();</span><br></pre></td></tr></table></figure>
<p>例如，我们要查询student集合中的所有文档：</p>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image16.png" alt="image16"> </p>
<p>这里你会发现每条文档会有一个叫_id的字段，这个相当于我们原来关系数据库中表的主键，当你在插入文档记录时没有指定该字段，MongDB会自动创建，其类型是ObjectID类型。</p>
<p>如果我们在插入文档记录时指定该字段也可以，其类型可以使ObjectID类型，也可以是MongoDB支持的任意类型. 例如：</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image17.png" alt="image17"></p>
<p>我们再次查询</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image18.png" alt="image18"></p>
<p>如果我想按一定条件来查询，比如我想查询性别为“女”的记录，怎么办？很简单！</p>
<p>只要在find()中添加参数即可，参数也是json格式，如下： </p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image19.png" alt="image19"></p>
<p>为了避免游标可能带来的开销，MongoDB还提供了一个叫findOne()的方法，用来返回结果集的第一条记录。</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image20.png" alt="image20"></p>
<p>性别为男的有很多条，这里只返回了第一条记录。</p>
<p>当我们需要返回查询结果的前几条记录时，可以使用limit方法，例如：</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image21.png" alt="image21"></p>
<h2 id="2-4修改文档"><a href="#2-4修改文档" class="headerlink" title="2.4修改文档"></a>2.4修改文档</h2><p>我们要想修改记录，可以使用update方法 .</p>
<p>例如：我向将姓名为孙悟空的学员文档中的age字段值改为31，执行下列语句，看会发生什么？</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image22.png" alt="image22"></p>
<p>再次查询：</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image23.png" alt="image23"></p>
<p>哦，悲剧了~~ 原来的孙悟空的文档只剩下_id 和age两个字段了。</p>
<p>那如何保留其它字段值呢？</p>
<p>我们需要使用MongoDB提供的修改器$set 来实现，请看下列代码。</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image24.png" alt="image24"></p>
<p>再次查询，会发现“猪八戒”文档中原有的其它字段还保留下来，而更新age字段也成功了。</p>
<h2 id="2-5删除文档"><a href="#2-5删除文档" class="headerlink" title="2.5删除文档"></a>2.5删除文档</h2><p>删除文档使用remove()方法，格式为：</p>
<p>请慎用remove({}), 它会一条不剩地把你的集合所有文档删的干干净净。</p>
<p>我们现在演示一下，删除name为“哪吒”的记录：</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image25.png" alt="image25"></p>
<p>再次查询，会发现哪吒的文档不见了。</p>
<h1 id="3-高级查询"><a href="#3-高级查询" class="headerlink" title="3.高级查询"></a>3.高级查询</h1><h2 id="3-1模糊查询"><a href="#3-1模糊查询" class="headerlink" title="3.1模糊查询"></a>3.1模糊查询</h2><p>MongoDB的模糊查询是通过正则表达式的方式实现的。格式为：</p>
<p>  /模糊查询字符串/</p>
<p>例如，我要查询student集合中address字段中含有“洞”的所有文档，代码如下：</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image26.png" alt="image26"></p>
<p>如果要查询name字段中以“白”开头的，代码如下：</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image27.png" alt="image27"></p>
<h2 id="3-2-Null值处理"><a href="#3-2-Null值处理" class="headerlink" title="3.2 Null值处理"></a>3.2 Null值处理</h2><p>如果我们想找出集合中某字段值为空的文档，如何查询呢？其实和我们之前的条件查询是一样的，条件值写为null就可以了。</p>
<p>我们现在集合中的文档都是没有空值的，为了方便测试，现在我们将数据做些修改：</p>
<p>将“唐僧”的address改为空</p>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image28.png" alt="image28"> </p>
<p>再次查询：</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image29.png" alt="image29"></p>
<p>我们会发现不仅会显示“唐僧”这条文档，之前因为修改导致address字段丢失的那条记录也出现了。也就是说，这种查询会查询出该字段为null的以及不存在该字段的文档记录。</p>
<h2 id="3-3大于小于"><a href="#3-3大于小于" class="headerlink" title="3.3大于小于"></a>3.3大于小于</h2><p>&lt;, &lt;=, &gt;, &gt;= 这个操作符也是很常用的，格式如下</p>
<p>db.collection.find({ “field” : { $gt: value } } ); // 大于: field &gt; value</p>
<p>db.collection.find({ “field” : { $lt: value } } ); // 小于: field &lt; value</p>
<p>db.collection.find({ “field” : { $gte: value } } ); // 大于等于: field &gt;= value</p>
<p>db.collection.find({ “field” : { $lte: value } } ); // 小于等于: field &lt;= value</p>
<p>示例：查询年龄大于等于20岁的学员记录</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image30.png" alt="image30"></p>
<h2 id="3-4不等于"><a href="#3-4不等于" class="headerlink" title="3.4不等于"></a>3.4不等于</h2><p>不等于使用$ne操作符。</p>
<p>示例：查询sex字段不为“男”的文档</p>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image31.png" alt="image31"> </p>
<h2 id="3-5判断字段是否存在"><a href="#3-5判断字段是否存在" class="headerlink" title="3.5判断字段是否存在"></a>3.5判断字段是否存在</h2><p>判断字段是否存在使用$exists操作符。</p>
<p>示例：查询所有含有address字符的文档。</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image32.png" alt="image3"></p>
<p>示例：查询所有不含有address字符的文档。</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image33.png" alt="image33"></p>
<h2 id="3-6包含与不包含"><a href="#3-6包含与不包含" class="headerlink" title="3.6包含与不包含"></a>3.6包含与不包含</h2><p>包含使用$in操作符。</p>
<p>示例：查询student集合中age字段包含20,25,30的文档</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image34.png" alt="image34"></p>
<p>示例：查询student集合中age字段不包含20,25,30的文档</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image35.png" alt="image35"></p>
<h2 id="3-7统计记录条数"><a href="#3-7统计记录条数" class="headerlink" title="3.7统计记录条数"></a>3.7统计记录条数</h2><p>统计记录条件使用count()方法。</p>
<p>示例：查询student集合的文档条数。</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image36.png" alt="image36"></p>
<p>示例：查询student集合中age字段小于等于20的文档条数。</p>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image37.png" alt="image37"> </p>
<h2 id="3-8条件连接–并且"><a href="#3-8条件连接–并且" class="headerlink" title="3.8条件连接–并且"></a>3.8条件连接–并且</h2><p>我们如果需要查询同时满足两个以上条件，需要使用$and操作符将条件进行关联。（相当于SQL的and）</p>
<p>格式为：$and:[ {  },{  },{   } ]</p>
<p>示例：查询student集合中age大于等于20 并且age小于30的文档</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image38.png" alt="image38"></p>
<h2 id="3-9-条件连接–或者"><a href="#3-9-条件连接–或者" class="headerlink" title="3.9 条件连接–或者"></a>3.9 条件连接–或者</h2><p>如果两个以上条件之间是或者的关系，我们使用$or操作符进行关联，与前面$and的使用方式相同</p>
<p>格式为：$or:[ {  },{  },{   } ]</p>
<p>示例：查询student集合中sex为女，或者年龄小于20的文档记录</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image39.png" alt="image39"></p>
<h1 id="4-java连接MongoDB"><a href="#4-java连接MongoDB" class="headerlink" title="4.java连接MongoDB"></a>4.java连接MongoDB</h1><h2 id="4-1查询文档"><a href="#4-1查询文档" class="headerlink" title="4.1查询文档"></a>4.1查询文档</h2><h2 id="4-1-1查询全部记录"><a href="#4-1-1查询全部记录" class="headerlink" title="4.1.1查询全部记录"></a>4.1.1查询全部记录</h2><p>（1）创建maven工程mongoDBDemo ，引入依赖。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mongodb&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.4.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>（2）编写代码，遍历student集合所有数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MongoClient client=<span class="keyword">new</span> MongoClient();<span class="comment">//创建连接对象</span></span><br><span class="line">MongoDatabase database = client.getDatabase(<span class="string">"itcastdb"</span>);<span class="comment">//获取数据库		</span></span><br><span class="line">MongoCollection&lt;Document&gt; collection = database.getCollection(<span class="string">"student"</span>);<span class="comment">//获取集合</span></span><br><span class="line">		</span><br><span class="line">FindIterable&lt;Document&gt; list = collection.find();<span class="comment">//获取文档集合</span></span><br><span class="line"><span class="keyword">for</span>( Document doc: list)&#123;<span class="comment">//遍历集合中的文档输出数据</span></span><br><span class="line">	System.out.println(<span class="string">"name:"</span>+ doc.getString(<span class="string">"name"</span>) );</span><br><span class="line">	System.out.println(<span class="string">"sex:"</span>+ doc.getString(<span class="string">"sex"</span>) );</span><br><span class="line">	System.out.println(<span class="string">"age:"</span>+ doc.getDouble(<span class="string">"age"</span>) );<span class="comment">//默认为浮点型</span></span><br><span class="line">	System.out.println(<span class="string">"address:"</span>+ doc.getString(<span class="string">"address"</span>) );</span><br><span class="line">	System.out.println(<span class="string">"--------------------------"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MongoDB的数字类型默认使用64位浮点型数值。{“x”：3.14}或{“x”：3}。对于整型值，可以使用NumberInt（4字节符号整数），{“x”:NumberInt(“3”)}  或NumberLong（8字节符号整数）{“x”:NumberLong(“3”)}</p>
<h2 id="4-1-2匹配查询"><a href="#4-1-2匹配查询" class="headerlink" title="4.1.2匹配查询"></a>4.1.2匹配查询</h2><p>MongoDB使用BasicDBObject类型封装查询条件，构造方法的参数为key 和value .</p>
<p>示例：查询student集合中name为猪八戒的文档</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建查询条件</span></span><br><span class="line">BasicDBObject bson=<span class="keyword">new</span> BasicDBObject(<span class="string">"name"</span>, <span class="string">"猪八戒"</span>);		</span><br><span class="line">FindIterable&lt;Document&gt; list = collection.find(bson);<span class="comment">//获取文档集合</span></span><br><span class="line"><span class="comment">//....遍历集合</span></span><br></pre></td></tr></table></figure>
<h2 id="4-1-3模糊查询"><a href="#4-1-3模糊查询" class="headerlink" title="4.1.3模糊查询"></a>4.1.3模糊查询</h2><p>构建模糊查询条件是通过正则表达式的方式来实现的</p>
<p>（1）完全匹配Pattern pattern = Pattern.compile(“^name$”);</p>
<p>（2）右匹配Pattern pattern = Pattern.compile(“^.*name$”);</p>
<p>（3）左匹配Pattern pattern = Pattern.compile(“^name.*$”);</p>
<p>（4）模糊匹配Pattern pattern = Pattern.compile(“^.<em>name.</em>$”);</p>
<p>示例：模糊查询student集合中address 中含有洞的文档记录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模糊查询：like %洞%</span></span><br><span class="line">Pattern queryPattern = Pattern.compile(<span class="string">"^.*洞.*$"</span>);</span><br><span class="line">BasicDBObject bson=<span class="keyword">new</span> BasicDBObject(<span class="string">"address"</span>, queryPattern);	</span><br><span class="line">FindIterable&lt;Document&gt; list = collection.find(bson);<span class="comment">//获取文档集合</span></span><br><span class="line"><span class="comment">//....遍历集合</span></span><br></pre></td></tr></table></figure>
<h2 id="4-1-4大于小于"><a href="#4-1-4大于小于" class="headerlink" title="4.1.4大于小于"></a>4.1.4大于小于</h2><p>在MongoDB提示符下条件json字符串为{ age: { $lt :20 } } ，对应的java代码也是BasicDBObject 的嵌套。</p>
<p>示例：查询student集合中age小于20的文档记录 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询年龄小于20的		</span></span><br><span class="line">BasicDBObject bson=<span class="keyword">new</span> BasicDBObject(<span class="string">"age"</span>, <span class="keyword">new</span> BasicDBObject(<span class="string">"$lt"</span>,<span class="number">20</span>));</span><br><span class="line">FindIterable&lt;Document&gt; list = collection.find(bson);<span class="comment">//获取文档集</span></span><br><span class="line"><span class="comment">//....遍历集合</span></span><br></pre></td></tr></table></figure>
<h2 id="4-1-5条件连接–并且"><a href="#4-1-5条件连接–并且" class="headerlink" title="4.1.5条件连接–并且"></a>4.1.5条件连接–并且</h2><p>示例：查询年龄大于等于20并且小于30的文档记录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询年龄大于等于20的			</span></span><br><span class="line">BasicDBObject bson1=<span class="keyword">new</span> BasicDBObject(<span class="string">"age"</span>, <span class="keyword">new</span> BasicDBObject(<span class="string">"$gte"</span>,<span class="number">20</span>));</span><br><span class="line"><span class="comment">//查询年龄小于30的</span></span><br><span class="line">BasicDBObject bson2=<span class="keyword">new</span> BasicDBObject(<span class="string">"age"</span>, <span class="keyword">new</span> BasicDBObject(<span class="string">"$lt"</span>,<span class="number">30</span>));</span><br><span class="line"><span class="comment">//构建查询条件and</span></span><br><span class="line">BasicDBObject bson=<span class="keyword">new</span>  BasicDBObject(<span class="string">"$and"</span>, Arrays.asList(bson1,bson2)  );</span><br></pre></td></tr></table></figure>
<h2 id="4-1-6条件连接–或者"><a href="#4-1-6条件连接–或者" class="headerlink" title="4.1.6条件连接–或者"></a>4.1.6条件连接–或者</h2><p>示例：查询年龄小于等于20或者性别为女的文档记录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BasicDBObject bson1=<span class="keyword">new</span> BasicDBObject(<span class="string">"age"</span>, <span class="keyword">new</span> BasicDBObject(<span class="string">"$lte"</span>,<span class="number">20</span>));		</span><br><span class="line">BasicDBObject bson2=<span class="keyword">new</span> BasicDBObject(<span class="string">"sex"</span>, <span class="string">"女"</span>);</span><br><span class="line"><span class="comment">//构建查询条件or</span></span><br><span class="line">BasicDBObject bson=<span class="keyword">new</span> BasicDBObject(<span class="string">"$or"</span>, Arrays.asList( bson1, bson2 )  );</span><br></pre></td></tr></table></figure>
<h2 id="4-2增加文档"><a href="#4-2增加文档" class="headerlink" title="4.2增加文档"></a>4.2增加文档</h2><p>我们使用insertOne方法来插入文档。</p>
<p>示例：添加文档记录–名称：铁扇公主  性别:女 年龄：28   地址：芭蕉洞</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取连接</span></span><br><span class="line">MongoClient client=<span class="keyword">new</span> MongoClient();</span><br><span class="line"><span class="comment">//得到数据库</span></span><br><span class="line">MongoDatabase database = client.getDatabase(<span class="string">"itcastdb"</span>);</span><br><span class="line"><span class="comment">//得到集合封装对象</span></span><br><span class="line">MongoCollection&lt;Document&gt; collection = database.getCollection(<span class="string">"student"</span>);</span><br><span class="line">Map&lt;String, Object&gt; map=<span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">"name"</span>, <span class="string">"铁扇公主"</span>);</span><br><span class="line">map.put(<span class="string">"sex"</span>, <span class="string">"女"</span>);</span><br><span class="line">map.put(<span class="string">"age"</span>, <span class="number">35.0</span>);</span><br><span class="line">map.put(<span class="string">"address"</span>, <span class="string">"芭蕉洞"</span>);		</span><br><span class="line">Document doc=<span class="keyword">new</span> Document(map);		</span><br><span class="line">collection.insertOne(doc);<span class="comment">//插入一条记录</span></span><br><span class="line"><span class="comment">//collection.insertMany(documents);//一次性插入多条文档</span></span><br></pre></td></tr></table></figure>
<h2 id="4-3删除文档"><a href="#4-3删除文档" class="headerlink" title="4.3删除文档"></a>4.3删除文档</h2><p>示例：将名称为铁扇公主的文档删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取连接</span></span><br><span class="line">MongoClient client=<span class="keyword">new</span> MongoClient();</span><br><span class="line"><span class="comment">//得到数据库</span></span><br><span class="line">MongoDatabase database = client.getDatabase(<span class="string">"itcastdb"</span>);</span><br><span class="line"><span class="comment">//得到集合封装对象</span></span><br><span class="line">MongoCollection&lt;Document&gt; collection = database.getCollection(<span class="string">"student"</span>);</span><br><span class="line">BasicDBObject bson=<span class="keyword">new</span> BasicDBObject(<span class="string">"name"</span>, <span class="string">"铁扇公主"</span>);</span><br><span class="line">collection.deleteOne(bson);<span class="comment">//删除记录（符合条件的第一条记录）</span></span><br><span class="line"><span class="comment">//collection.deleteMany(bson);//删除符合条件的全部记录</span></span><br></pre></td></tr></table></figure>
<h2 id="4-4修改文档"><a href="#4-4修改文档" class="headerlink" title="4.4修改文档"></a>4.4修改文档</h2><p>示例：将红孩儿的地址修改为“南海”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取连接</span></span><br><span class="line">MongoClient client=<span class="keyword">new</span> MongoClient();</span><br><span class="line"><span class="comment">//得到数据库</span></span><br><span class="line">MongoDatabase database = client.getDatabase(<span class="string">"itcastdb"</span>);</span><br><span class="line"><span class="comment">//得到集合封装对象</span></span><br><span class="line">MongoCollection&lt;Document&gt; collection = database.getCollection(<span class="string">"student"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改的条件</span></span><br><span class="line">BasicDBObject bson= <span class="keyword">new</span> BasicDBObject(<span class="string">"name"</span>, <span class="string">"红孩儿"</span>);</span><br><span class="line"><span class="comment">//修改后的值</span></span><br><span class="line">BasicDBObject bson2 = <span class="keyword">new</span> BasicDBObject(<span class="string">"$set"</span>,<span class="keyword">new</span> BasicDBObject(<span class="string">"address"</span>, <span class="string">"南海"</span>));</span><br><span class="line"><span class="comment">//参数1：修改条件  参数2：修改后的值</span></span><br><span class="line">collection.updateOne(bson, bson2);</span><br><span class="line"><span class="comment">//collection.updateMany(filter, update);//修改符合条件的所有记录</span></span><br></pre></td></tr></table></figure>
<p>updateMany方法用于修改符合条件的所有记录</p>
<p>updateOne方法用于修改符合条件的第一条记录</p>
<h1 id="5-MongoDB连接池"><a href="#5-MongoDB连接池" class="headerlink" title="5.MongoDB连接池"></a>5.MongoDB连接池</h1><h2 id="5-1代码实现"><a href="#5-1代码实现" class="headerlink" title="5.1代码实现"></a>5.1代码实现</h2><p>MongoClient 被设计为线程安全的类，也就是我们在使用该类时不需要考虑并发的情况，这样我们可以考虑把MongoClient 做成一个静态变量，为所有线程公用，不必每次都销毁。这样可以极大提高执行效率。实际上，这是MongoDB提供的内置的连接池来实现的。    </p>
<p>​    首先我们先创建一个“管理类”，相当于我们原来的BaseDao </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.haha.demo;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.MongoClient;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.MongoClientOptions;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.MongoClientOptions.Builder;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.WriteConcern;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.client.MongoDatabase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> MongoClient mongoClient=<span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//对mongoClient初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;		</span><br><span class="line">		mongoClient=<span class="keyword">new</span> MongoClient();	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MongoDatabase <span class="title">getDatabase</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(mongoClient==<span class="keyword">null</span>)&#123;</span><br><span class="line">			init();</span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="keyword">return</span> mongoClient.getDatabase(<span class="string">"itcastdb"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    然后我们创建一个StudentDao</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.haha.demo;</span><br><span class="line"><span class="keyword">import</span> org.bson.Document;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.client.MongoCollection;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.client.MongoDatabase;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学员数据访问层</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(String name,String sex,<span class="keyword">double</span> age,String address)</span></span>&#123;</span><br><span class="line">		MongoDatabase database = MongoManager.getDatabase();</span><br><span class="line">		MongoCollection&lt;Document&gt; collection = database.getCollection(<span class="string">"student2"</span>);</span><br><span class="line">		Document docment=<span class="keyword">new</span> Document();</span><br><span class="line">		docment.put(<span class="string">"name"</span>, name);</span><br><span class="line">		docment.put(<span class="string">"sex"</span>, sex);		</span><br><span class="line">		docment.put(<span class="string">"age"</span>, age);</span><br><span class="line">		docment.put(<span class="string">"address"</span>, address);</span><br><span class="line">		collection.insertOne(docment);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在做个测试，循环插入2万条数据，看看执行时间是多长时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.haha.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> startTime = <span class="keyword">new</span> Date().getTime();<span class="comment">//开始时间</span></span><br><span class="line">		</span><br><span class="line">		StudentDao studentDao=<span class="keyword">new</span> StudentDao();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20000</span>;i++)&#123;</span><br><span class="line">			studentDao.save(<span class="string">"测试"</span>+i, <span class="string">"男"</span>, <span class="number">25.0</span>, <span class="string">"测试地址"</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = <span class="keyword">new</span> Date().getTime();<span class="comment">//完成时间</span></span><br><span class="line">		System.out.println(<span class="string">"完成时间："</span>+(endTime-startTime)+<span class="string">"毫秒"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过测试：所用毫秒数为3589 </p>
<h2 id="5-2参数设置"><a href="#5-2参数设置" class="headerlink" title="5.2参数设置"></a>5.2参数设置</h2><p>我们在刚才的代码基础上进行连接池参数的设置</p>
<p>修改MongoManager的init方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对mongoClient初始化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//连接池选项</span></span><br><span class="line">		Builder builder = <span class="keyword">new</span> MongoClientOptions.Builder();<span class="comment">//选项构建者	</span></span><br><span class="line">		builder.connectTimeout(<span class="number">5000</span>);<span class="comment">//设置连接超时时间</span></span><br><span class="line">		builder.socketTimeout(<span class="number">5000</span>);<span class="comment">//读取数据的超时时间</span></span><br><span class="line">		builder.connectionsPerHost(<span class="number">30</span>);<span class="comment">//每个地址最大请求数		</span></span><br><span class="line">		builder.writeConcern(WriteConcern.NORMAL);<span class="comment">//写入策略，仅抛出网络异常</span></span><br><span class="line">		MongoClientOptions options = builder.build();</span><br><span class="line">		mongoClient=<span class="keyword">new</span> MongoClient(<span class="string">"127.0.0.1"</span>,options);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次进行测试：所用的毫秒1544</p>
<p>下面是写入策略。</p>
<p>WriteConcern.NONE:没有异常抛出</p>
<p>WriteConcern.NORMAL:仅抛出网络错误异常，没有服务器错误异常</p>
<p>WriteConcern.SAFE:抛出网络错误异常、服务器错误异常；并等待服务器完成写操作。</p>
<p>WriteConcern.MAJORITY: 抛出网络错误异常、服务器错误异常；并等待一个主服务器完成写操作。</p>
<p>WriteConcern.FSYNC_SAFE: 抛出网络错误异常、服务器错误异常；写操作等待服务器将数据刷新到磁盘。</p>
<p>WriteConcern.JOURNAL_SAFE:抛出网络错误异常、服务器错误异常；写操作等待服务器提交到磁盘的日志文件。</p>
<p>WriteConcern.REPLICAS_SAFE:抛出网络错误异常、服务器错误异常；等待至少2台服务器完成写操作。</p>
<h1 id="6-综合案例-《网站点击日志分析组件》"><a href="#6-综合案例-《网站点击日志分析组件》" class="headerlink" title="6.综合案例-《网站点击日志分析组件》"></a>6.综合案例-《网站点击日志分析组件》</h1><h1 id="6-1需求分析"><a href="#6-1需求分析" class="headerlink" title="6.1需求分析"></a>6.1需求分析</h1><p>《花生二手车》交易网站日访问IP高达2万+ ，每秒点击频率在2000次左右。为了能够对访问用户的行为做进一步的分析，产品部提出需求，用户每次点击浏览二手车都要记录该用户ID、访问IP、访问时间、点击车型、点击商品ID、价格等信息。</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image40.png" alt="image40"></p>
<h2 id="6-2数据库设计"><a href="#6-2数据库设计" class="headerlink" title="6.2数据库设计"></a>6.2数据库设计</h2><p>浏览日志browseLog</p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>字段类型</th>
<th>字段含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>userid</td>
<td>字符</td>
<td>用户ID</td>
</tr>
<tr>
<td>ip</td>
<td>字符</td>
<td>访问IP</td>
</tr>
<tr>
<td>browseTime</td>
<td>时间</td>
<td>访问时间</td>
</tr>
<tr>
<td>model</td>
<td>字符</td>
<td>点击车型</td>
</tr>
<tr>
<td>goodsid</td>
<td>字符</td>
<td>点击商品ID</td>
</tr>
<tr>
<td>price</td>
<td>数值</td>
<td>价格</td>
</tr>
<tr>
<td>remark</td>
<td>字符</td>
<td>备注</td>
</tr>
</tbody>
</table>
<h2 id="6-3日志写入"><a href="#6-3日志写入" class="headerlink" title="6.3日志写入"></a>6.3日志写入</h2><p>（1）创建工程sitelog ，在pom.xml中引入依赖。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.mongodb&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt;</span><br><span class="line">       &lt;version&gt;3.4.1&lt;/version&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line"> &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>（2）在src/main/resources 添加配置文件sitelog.properties</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">host=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">port=<span class="number">27017</span></span><br></pre></td></tr></table></figure>
<p>这个配置文件用于配置主机地址和端口</p>
<p>（3）创建包com.huasheng.sitelog，建立Config 类，用于读取配置文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.huasheng.sitelog;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span>&#123;			</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Properties p=<span class="keyword">new</span> Properties();</span><br><span class="line">			InputStream input=Config.class.getResourceAsStream(<span class="string">"/sitelog.propertis"</span>);</span><br><span class="line">			p.load(input);</span><br><span class="line">			host=p.getProperty(<span class="string">"host"</span>);</span><br><span class="line">			port=Integer.parseInt( p.getProperty(<span class="string">"port"</span>));</span><br><span class="line">			input.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="comment">//加载		</span></span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String host;<span class="comment">//主机地址</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> port;<span class="comment">//端口</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> host;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> port;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）创建管理类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.huasheng.sitelog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mongodb.MongoClient;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.MongoClientOptions;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.MongoClientOptions.Builder;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.ServerAddress;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.WriteConcern;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.client.MongoDatabase;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mongo数据库连接管理类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoManager</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> MongoClient mongoClient=<span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//创建一个选项构造器</span></span><br><span class="line">		Builder builder = <span class="keyword">new</span> MongoClientOptions.Builder();</span><br><span class="line">		builder.connectTimeout(<span class="number">5000</span>);<span class="comment">//设置连接超时时间</span></span><br><span class="line">		builder.socketTimeout(<span class="number">5000</span>);<span class="comment">//读取数据的超时时间</span></span><br><span class="line">		builder.connectionsPerHost(<span class="number">30</span>);<span class="comment">//设置每个地址最大连接数</span></span><br><span class="line">		builder.writeConcern(WriteConcern.NORMAL);<span class="comment">//设置写入策略  ,只有网络异常才会抛出</span></span><br><span class="line">		<span class="comment">//得到选项封装</span></span><br><span class="line">		MongoClientOptions options = builder.build();		</span><br><span class="line">		mongoClient=<span class="keyword">new</span> MongoClient(<span class="keyword">new</span> ServerAddress(Config.getHost(), Config.getPort()),options);		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MongoDatabase <span class="title">getDatabase</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(mongoClient==<span class="keyword">null</span>)&#123;</span><br><span class="line">			init();</span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="keyword">return</span> mongoClient.getDatabase(<span class="string">"itcastdb"</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（5）日志工具类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.huasheng.sitelog;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> org.bson.Document;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.client.MongoCollection;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.client.MongoDatabase;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 站点日志数据工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SiteLogUtil</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 写入日志</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> logname 日志名称</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> map 日志数据</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(String logname,Map&lt;String, Object&gt; map)</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		MongoDatabase database = MongoManager.getDatabase();</span><br><span class="line">		MongoCollection&lt;Document&gt; collection = database.getCollection(logname);</span><br><span class="line">		Document doc=<span class="keyword">new</span> Document(map);		</span><br><span class="line">		collection.insertOne(doc);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（6）编写测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map map=<span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">"userid"</span>, <span class="string">"8888"</span>);</span><br><span class="line">map.put(<span class="string">"ip"</span>, <span class="string">"188.188.200.2"</span>);</span><br><span class="line">map.put(<span class="string">"browseTime"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">map.put(<span class="string">"model"</span>, <span class="string">"大众"</span>);</span><br><span class="line">map.put(<span class="string">"goodsid"</span>, <span class="string">"123123"</span>);</span><br><span class="line">map.put(<span class="string">"price"</span>, <span class="number">15.3</span>);</span><br><span class="line">map.put(<span class="string">"remark"</span>, <span class="string">"八成新，贱卖了"</span>);</span><br><span class="line">SiteLogUtil.save(<span class="string">"browseLog"</span>, map);<span class="comment">//存入日志</span></span><br></pre></td></tr></table></figure>
<h2 id="6-4日志查询"><a href="#6-4日志查询" class="headerlink" title="6.4日志查询"></a>6.4日志查询</h2><h2 id="6-4-1条件查询"><a href="#6-4-1条件查询" class="headerlink" title="6.4.1条件查询"></a>6.4.1条件查询</h2><p>（1）在SiteLogUtil类中添加方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 按条件查询</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> logName</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> map</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FindIterable&lt;Document&gt; <span class="title">list</span><span class="params">(String logName,Map&lt;String, Object&gt; map)</span></span>&#123;</span><br><span class="line">		MongoDatabase database = MongoManager.getDatabase();</span><br><span class="line">		MongoCollection&lt;Document&gt; collection = database.getCollection(logName);</span><br><span class="line">		BasicDBObject bson=<span class="keyword">new</span> BasicDBObject(map);<span class="comment">//构建查询条件			</span></span><br><span class="line">		<span class="keyword">return</span> collection.find(bson);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>（2）编写测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map =<span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">"userid"</span>, <span class="string">"8888"</span>);		</span><br><span class="line">FindIterable&lt;Document&gt; list = SiteLogUtil.list(<span class="string">"browseLog"</span>, map);</span><br><span class="line">String json = JSON.serialize(list);</span><br><span class="line">System.out.println(json);</span><br></pre></td></tr></table></figure>
<h2 id="6-4-2分页查询"><a href="#6-4-2分页查询" class="headerlink" title="6.4.2分页查询"></a>6.4.2分页查询</h2><p>（1）在SiteLogUtil类中添加方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分页查询日志</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> logName 日志名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map 条件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pageIndex 页码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pageSize 页大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,Object&gt; <span class="title">listPage</span><span class="params">(String logName,Map&lt;String, Object&gt; map,<span class="keyword">int</span> pageIndex,<span class="keyword">int</span> pageSize)</span></span>&#123;</span><br><span class="line">	MongoDatabase database = MongoManager.getDatabase();</span><br><span class="line">	MongoCollection&lt;Document&gt; collection = database.getCollection(logName);		</span><br><span class="line">	BasicDBObject bson=<span class="keyword">new</span> BasicDBObject(map);<span class="comment">//构建查询条件			</span></span><br><span class="line">	FindIterable&lt;Document&gt; find = collection.find(bson);</span><br><span class="line">	<span class="keyword">int</span> skip= (pageIndex-<span class="number">1</span>)*pageSize;</span><br><span class="line">	find.skip( skip);<span class="comment">//跳过记录数</span></span><br><span class="line">	find.limit(pageSize);<span class="comment">//一页查询记录数</span></span><br><span class="line">	<span class="comment">//&#123; total:x,rows:[]  &#125;</span></span><br><span class="line">	<span class="keyword">long</span> count = collection.count(bson);</span><br><span class="line">	Map&lt;String,Object&gt; m=<span class="keyword">new</span> HashMap();</span><br><span class="line">	m.put(<span class="string">"total"</span>, count);</span><br><span class="line">	m.put(<span class="string">"rows"</span>, find);</span><br><span class="line">	<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）添加测试数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">	</span><br><span class="line">	Map&lt;String, Object&gt; map=<span class="keyword">new</span> HashMap();</span><br><span class="line">	map.put(<span class="string">"userid"</span>, <span class="string">"900"</span>+i);<span class="comment">//用户ID</span></span><br><span class="line">	map.put(<span class="string">"ip"</span>, <span class="string">"121.211.112.212"</span>);</span><br><span class="line">	map.put(<span class="string">"browseTime"</span>, <span class="keyword">new</span> Date());<span class="comment">//浏览时间</span></span><br><span class="line">	map.put(<span class="string">"model"</span>, <span class="string">"大众"</span>+i);<span class="comment">//型号</span></span><br><span class="line">	map.put(<span class="string">"goodsid"</span>, <span class="string">"123456"</span>);<span class="comment">//商品ID</span></span><br><span class="line">	map.put(<span class="string">"price"</span>, <span class="number">11.8</span>);<span class="comment">//价格</span></span><br><span class="line">	map.put(<span class="string">"remark"</span>, <span class="string">"八成新，快来买吧"</span>);</span><br><span class="line">	</span><br><span class="line">	SiteLogUtil.save(<span class="string">"browseLog"</span>, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）编写测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map=<span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">"goodsid"</span>, <span class="string">"123456"</span>);</span><br><span class="line">Map&lt;String, Object&gt; m = SiteLogUtil.listPage(<span class="string">"browseLog"</span>, map, <span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">String json = JSON.serialize(m);</span><br><span class="line">System.out.println(json);</span><br></pre></td></tr></table></figure>
<p>使用Maven 的package命令进行打包。</p>
<p>创建WEB工程，引入jar包，调用此方法即可实现日志查询。代码略。</p>
 

	    
</div>

<div class="center">
			

				<span class="post-meta">		
				<span class="iconfont icon-category"></span>
				<a class="category-link" href="/categories/数据库/">数据库</a>
				</span>
		
			

		
				
				<span class="post-meta">
				<span class="iconfont icon-tag"></span>
				<a class="tag-link" href="/tags/mongoDB/">mongoDB</a>
				</span>			
			


		

		<span class="post-words"><span class="iconfont icon-words"></span>
		15463
		</span>		
</div>		

		
    <a class="article-readmore" href="/2016/10/05/mongoDB文档数据库/">阅读更多</a> 
    	
</article>     
     	
  

 

  <nav class="paginator">
    <a class="extend prev" rel="prev" href="/page/2/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>
  

</section> 

    </div>        

    
    <div class="mask"> </div>
    <div class="back-to-top iconfont icon-backtotop fadeIn"></div> 

    


<script src="/js/search.js"></script>     
          
          <div class="search-container sildeUpMin">
            <input type="text" placeholder="输入你想搜索的" id="search-input" class="search-input">  
              <span class="search-cancel iconfont icon-cancel"></span>
              <div id="search-result" class="search-result"></div>
          </div>
 

     <div class="mobile-menu">      

      
      <img class="mobile-menu-icon no-gallery" src= /img/favicon.png >   
      

         
            

            <a class="mobile-menu-link" href="/">首页
            </a>
            
         
            

            <a class="mobile-menu-link" href="/archives">归档
            </a>
            
         
            

            <a class="mobile-menu-link" href="/categories">分类
            </a>
            
         
            

            <a class="mobile-menu-link" href="/tags">标签
            </a>
            
         
            

            <a class="mobile-menu-link" href="/about">关于
            </a>
            
         
                          

            <a class="mobile-menu-link mobile-menu-search" href="#">搜索 </a>                 
            
         
</div>     
    

<footer id="footer">
	   
   	 <div>	
	   	    	
   	 </div>
   
   	 
	 <div>
	 	&copy;
		2018
		Rui Min	 

	 </div>


   
   	 <div>
	
	 <a href="http://hexo.io/" target="_blank">Hexo</a>

	 Theme

	 <a href="https://github.com/Lemonreds/hexo-theme-Nayo" target="_blank">Nayo</a> 

	 </div>	


	
	
</footer> 
    

<!-- Baidu Analytics -->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?636802045446222199ae541e32c8133e"; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




 
  </body>   
  <script src="/js/animation.js"></script>   
</html>