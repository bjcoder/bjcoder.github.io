<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.0//EN" "http://www.wapforum.org/DTD/xhtml-mobile10.dtd">
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport"content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes"/>
  
  
  <title>  Min‘s blog</title>

 
  
    <link rel="icon" href="/img/favicon.png">
  


  <!-- css -->
  <link rel="stylesheet" href="/css/style.css">  
  <!-- Jquery -->
  <script src="//cdn.staticfile.org/jquery/3.2.1/jquery.min.js"></script> 
  <!-- Add fancyBox -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.1.25/jquery.fancybox.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.1.25/jquery.fancybox.min.js"></script> 
  <script src="/js/gallery.js"></script>
  <!-- javascript --> 
  <script src="/js/mobile.js"></script>  
  <script src="/js/utils.js"></script>    
  <script src="/js/script.js"></script>  
</head> 
  <body> 
    <header class="header">
	
  <nav class="header-nav">       
	
  	<span class="iconfont icon-menu mobile-toggle"></span>  

    <a class="header-logo" href="/"><span>Min&#39;s blog</a>  

    <div class="header-menu">          
              
            

              <a class="header-menu-link" id="header-menu-home" href="/">首页</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-archives" href="/archives">归档</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-categories" href="/categories">分类</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-tags" href="/tags">标签</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-about" href="/about">关于</a>     

            
            
            

              <a class="iconfont icon-menu-search header-menu-link" id="header-menu-search"></a>

            
                
    </div>  
    
  </nav>
</header>

    <div class="container">         
      
        

          <section id="main">  

        

        


<div class="profile sildeUpMin">

		<img class="avatar no-gallery" src="/img/timg.jpeg"  alt="Lose">
					
		<p class="author">Rui Min</p>

		
			<p class="location"><span class="iconfont icon-location"></span>BeiJing CN</p>
		
	
		<div class="social">
   		    	
		<a href="https://github.com/bjcoder" class="iconfont icon-github" target="_blank" title="github"></a>
	        	
		<a href="/" class="iconfont icon-others" target="_blank" title="others"></a>
	    
    	</div>		
</div>

      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2017/11/11/支持多文件监控和断点续传/">支持多文件监控和断点续传</a>  
	       
		 

		 <time>2017-11-11 </time>    
	</div>


    <div class="article-excerpt">	
	
  	

	  

	  	<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h1><p>但是官方的 taildirSource 组件貌似是支持nginx 日志，对于log4j 日志好像不太管用。<br>因为log4j 日志会自动切分，log4j 切分日志其实就是新建一个文件，然后把原来的日志文件都改名。但是 taildirSource 组件时不支持文件改名的。如果文件改名会认为是新文件，就会重新读取，这就导致了日志文件重读。</p>
<hr>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a><strong>解决</strong></h1><p>为了解决这个问题，我去读了 taildirSource 的源码。</p>
<p>发现了两个地方 需要修改</p>
<h1 id="1-修改-ReliableTaildirEventReader"><a href="#1-修改-ReliableTaildirEventReader" class="headerlink" title="1.修改 ReliableTaildirEventReader"></a>1.修改 ReliableTaildirEventReader</h1><p>修改ReliableTaildirEventReader 类的 updateTailFiles 方法。</p>
<p>将其中的 tf.getPath().equals(f.getAbsolutePath()) 判断条件去除。<br>只用判断文件不为空即可，不用判断文件的名字，因为log4j 日志切分文件被重命名了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//        if (tf == null || !tf.getPath().equals(f.getAbsolutePath())) &#123;</span><br><span class="line">                if (tf == null) &#123;//文件不存在 position 中则全读。123</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="2-修改TailFile"><a href="#2-修改TailFile" class="headerlink" title="2.修改TailFile"></a>2.修改TailFile</h1><p>修改TailFile 类的 updatePos 方法</p>
<p>此处同样的原因，inode 已经能够确定唯一的 文件了，所以不用加 path 作为判定条件了。所以去掉该条件就支持了文件重命名情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   //     if (this.inode == inode &amp;&amp; this.path.equals(path)) </span><br><span class="line">          if (this.inode == inode) </span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<p>修改这两个地方就支持了文件重命名 的问题，实现了目录下多文件监控，断点续传。</p>
<hr>
<p>添加自定义source入口，也就是将源码拷贝过来，然后将修改过的代码打包为自定义source的jar 包运行flume 。</p>
<p>参考 ： <a href="http://blog.csdn.net/u012373815/article/details/54352177" target="_blank" rel="noopener">flume自定义组件的 jar 包管理</a></p>
<hr>
<h1 id="3-配置文件"><a href="#3-配置文件" class="headerlink" title="3.配置文件"></a>3.配置文件</h1><p>提供 taildirsource 的配置文件如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a1.sources = r1</span><br><span class="line"></span><br><span class="line">a1.sources.r1.type = com.xx.xx.source.taildir.TaildirSource</span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sources.r1.positionFile = /opt/apps/log4j/taildir_position.json</span><br><span class="line">a1.sources.r1.filegroups = f1</span><br><span class="line">a1.sources.r1.filegroups.f1 = /opt/apps/log4j/logs/*.log.*</span><br><span class="line">a1.sources.r1.fileHeader = true12345678</span><br></pre></td></tr></table></figure>
<p>通过这些修改就 实现了多文件监控和断点续传。支持log4j 日志监控。</p>
<h1 id="4-监控多个文件夹下的多个文件"><a href="#4-监控多个文件夹下的多个文件" class="headerlink" title="4. 监控多个文件夹下的多个文件"></a>4. 监控多个文件夹下的多个文件</h1><p>监控多个文件夹下的多个文件，只用 配置多个filegroups 即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a1.sources = r1</span><br><span class="line"></span><br><span class="line">a1.sources.r1.type = com.xx.xx.source.taildir.TaildirSource</span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sources.r1.positionFile = /opt/apps/log4j/taildir_position.json</span><br><span class="line"></span><br><span class="line">a1.sources.r1.filegroups = f1 f2</span><br><span class="line">a1.sources.r1.filegroups.f1=/opt/apps/log4j/test*.log</span><br><span class="line">a1.sources.r1.filegroups.f2=/opt/apps/log4j2/test*.log</span><br><span class="line">a1.sources.r1.fileHeader = true</span><br><span class="line"></span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure>
<p>参考： <a href="http://blog.csdn.net/test103/article/details/55096786#reply" target="_blank" rel="noopener">http://blog.csdn.net/test103/article/details/55096786#reply</a></p>
 

	    
</div>

<div class="center">
			

				<span class="post-meta">		
				<span class="iconfont icon-category"></span>
				<a class="category-link" href="/categories/大数据/">大数据</a>
				</span>
		
			

		
				
				<span class="post-meta">
				<span class="iconfont icon-tag"></span>
				<a class="tag-link" href="/tags/集群/">集群</a>
				</span>			
			


		

		<span class="post-words"><span class="iconfont icon-words"></span>
		1608
		</span>		
</div>		

		
    <a class="article-readmore" href="/2017/11/11/支持多文件监控和断点续传/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2017/11/11/Linux集群资源监控/">Linux集群资源监控</a>  
	       
		 

		 <time>2017-11-11 </time>    
	</div>


    <div class="article-excerpt">	
	
  	

	  

	  	<h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><ul>
<li>Ganglia 监控套件包括三个主要部分 gmond ，gmetad，和网页接口，通常被称为ganglia-web。<br>gmond 是一个守护进程，他运行在每一个需要监测的节点上，收集监测统计，发送和接受在同一个组播或单播通道上的统计信息。</li>
<li>gmetad 也是一个守护进程，他定期检查gmonds ，从那里拉取数据，并将他们的指标存储在RRD存储引擎中。它可以查询多个集群并聚合指标。RRD也被用于生成用户界面的web前端。</li>
<li>ganglia-web 顾名思义，他应该安装在有gmetad运行的机器上，以便读取RRD文件。</li>
</ul>
<p>​    一般来说一个集群的每台机器上都需要安装gmond，只要负责展示web界面的机器安装了gmetad即可。</p>
<h1 id="二-ganglia规划"><a href="#二-ganglia规划" class="headerlink" title="二.ganglia规划"></a>二.ganglia规划</h1><p>​    <strong>主机名</strong>             ip               <strong>规划</strong>                         安装</p>
<p>   hadoop1      10.2.6.250        服务端   ganglia-gmond、ganglia-gmetad、ganglia-web</p>
<p>   hadoop2     10.2.6.246        客户端            ganglia-gmond</p>
<p>   hadoop3     10.2.6.248        客户端            ganglia-gmond</p>
<p>   hadoop4   10.2.6.249        客户端            ganglia-gmond</p>
<p>安装前确保iptables关闭.</p>
<h1 id="三-安装前的准备工作"><a href="#三-安装前的准备工作" class="headerlink" title="三.安装前的准备工作"></a>三.安装前的准备工作</h1><h2 id="3-1加载yum源，在每一台机器上面执行下面两个命令"><a href="#3-1加载yum源，在每一台机器上面执行下面两个命令" class="headerlink" title="3.1加载yum源，在每一台机器上面执行下面两个命令"></a>3.1加载yum源，在每一台机器上面执行下面两个命令</h2><p>rpm -Uvh <a href="http://dl.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm" target="_blank" rel="noopener">http://dl.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm</a></p>
<p>yum  -y  install  httpd-devel  automake  autoconf  libtool  ncurses-devel  libxslt  groff  pcre-devel  pkgconfig</p>
<h2 id="四-主节点服务安装配置"><a href="#四-主节点服务安装配置" class="headerlink" title="四.主节点服务安装配置"></a>四.主节点服务安装配置</h2><h2 id="4-1主节点的服务安装（hadoop1上面的安装配置）安装ganglia-gmetad-和ganglia-web"><a href="#4-1主节点的服务安装（hadoop1上面的安装配置）安装ganglia-gmetad-和ganglia-web" class="headerlink" title="4.1主节点的服务安装（hadoop1上面的安装配置）安装ganglia-gmetad 和ganglia-web"></a>4.1主节点的服务安装（hadoop1上面的安装配置）安装ganglia-gmetad 和ganglia-web</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yum search ganglia     ------------------查看ganglia在epel的安装包,复制进行安装 </span><br><span class="line">如果没有安装包，需要下载EPEL</span><br><span class="line">yum  install epel-release  //扩展包更新包  </span><br><span class="line">yum  update //更新yum源  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">yum -y install ganglia-web.x86_64 ganglia-gmond.x86_64  </span><br><span class="line">yum -y install ganglia-gmetad.x86_64 ----------------------(如果上一步执行了这步不用执行,web包会自动下载该依赖)  </span><br><span class="line">rpm -qa |grep ganglia          --------------------查看安装情况  </span><br><span class="line">rpm -ql ganglia-gmetad.x86_64       ------------- 复制上面命令执行结果的安装名,可查看安装路径</span><br></pre></td></tr></table></figure>
<h3 id="4-1-1配置gmetad"><a href="#4-1-1配置gmetad" class="headerlink" title="4.1.1配置gmetad"></a>4.1.1配置gmetad</h3><p>Shell<strong>代码</strong>   </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ganglia/gmetad.conf  </span><br><span class="line"></span><br><span class="line">data_source "my cluster" 10.2.6.250:8649  ---- Hadoop为cluster名称,后面是需要监控的主机名</span><br></pre></td></tr></table></figure>
<h3 id="4-1-2修改apache设置"><a href="#4-1-2修改apache设置" class="headerlink" title="4.1.2修改apache设置"></a>4.1.2修改apache设置</h3><p>Shell<strong>代码</strong>   </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> vi /etc/httpd/conf.d/ganglia.conf  </span><br><span class="line"></span><br><span class="line">文件内容Deny from all 为 allow from all </span><br><span class="line"></span><br><span class="line">修改后配置如下</span><br><span class="line"></span><br><span class="line">&lt;Location /ganglia&gt;</span><br><span class="line"></span><br><span class="line">    Order deny,allow</span><br><span class="line"></span><br><span class="line">    Allow from all</span><br><span class="line"></span><br><span class="line">    Allow from 127.0.0.1</span><br><span class="line"></span><br><span class="line">    Allow from ::1</span><br><span class="line"></span><br><span class="line">    # Allow from .example.com</span><br><span class="line"></span><br><span class="line">  &lt;/Location&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-3设置启动"><a href="#4-1-3设置启动" class="headerlink" title="4.1.3设置启动"></a>4.1.3设置启动</h3><p>Shell<strong>代码</strong>   </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --add gmetad  </span><br><span class="line"></span><br><span class="line"> chkconfig --add gmond  </span><br><span class="line"></span><br><span class="line"> chkconfig --add httpd</span><br></pre></td></tr></table></figure>
<h3 id="4-1-4打开端口-关闭防火墙"><a href="#4-1-4打开端口-关闭防火墙" class="headerlink" title="4.1.4打开端口/关闭防火墙"></a>4.1.4打开端口/关闭防火墙</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/iptables stop -------------------关闭防火墙,用于测试时,线上最好用打开端口方式</span><br></pre></td></tr></table></figure>
<h3 id="4-1-5关闭SELinux"><a href="#4-1-5关闭SELinux" class="headerlink" title="4.1.5关闭SELinux"></a>4.1.5关闭SELinux</h3><p>1 永久方法 – 需要重启服务器</p>
<p>修改/etc/selinux/config文件中设置SELINUX=disabled ，然后重启服务器。</p>
<p>2 临时方法 – 设置系统参数</p>
<p>使用命令setenforce 0</p>
<p>附：</p>
<p>setenforce 1 设置SELinux 成为enforcing模式</p>
<p>setenforce 0 设置SELinux 成为permissive模式</p>
<h1 id="五-监控节点的安装（每个监控节点，hadoop2，hadoop3，hadoop4都要安装）"><a href="#五-监控节点的安装（每个监控节点，hadoop2，hadoop3，hadoop4都要安装）" class="headerlink" title="五.监控节点的安装（每个监控节点，hadoop2，hadoop3，hadoop4都要安装）"></a>五.监控节点的安装（每个监控节点，hadoop2，hadoop3，hadoop4都要安装）</h1><h2 id="5-1安装ganglia-gmond"><a href="#5-1安装ganglia-gmond" class="headerlink" title="5.1安装ganglia-gmond"></a>5.1安装ganglia-gmond</h2><p>Shell<strong>代码</strong>   </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum search ganglia  </span><br><span class="line"></span><br><span class="line">yum install ganglia-gmond.x86_64</span><br></pre></td></tr></table></figure>
<h2 id="5-2配置gmond"><a href="#5-2配置gmond" class="headerlink" title="5.2配置gmond"></a>5.2配置gmond</h2><p>Shell<strong>代码</strong>   </p>
<p>vi /etc/ganglia/gmond.conf  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">cluster &#123;</span><br><span class="line"></span><br><span class="line">  name = "my cluster"    ------ cluster名称,是你在gmetad.conf里配置的data_source名称 </span><br><span class="line"></span><br><span class="line">  owner = "root"</span><br><span class="line"></span><br><span class="line">  latlong = "unspecified"</span><br><span class="line"></span><br><span class="line">  url = "unspecified"</span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">udp_send_channel &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta"> #</span> mcast_join = 239.2.11.71  ----- 组播  </span><br><span class="line"></span><br><span class="line">  host=10.2.6.250    -------------- 单播 gmeta主机的ip/主机名或者主机ip地址  </span><br><span class="line"></span><br><span class="line">  port = 8649</span><br><span class="line"></span><br><span class="line">ttl = 1</span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">udp_recv_channel &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span>mcast_join = 239.2.11.71  </span><br><span class="line"></span><br><span class="line">  port = 8649</span><br><span class="line"></span><br><span class="line">  bind = 10.2.6.246</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-3配置启动"><a href="#5-3配置启动" class="headerlink" title="5.3配置启动"></a>5.3配置启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chkconfig  --add  gmond</span><br><span class="line"></span><br><span class="line">chkconfig  --list  gmond</span><br></pre></td></tr></table></figure>
<p>此时，如果正确安装，会出现gmond           0:off   1:off   2:off   3:off   4:off   5:off   6:off</p>
<h2 id="5-4配置hosts"><a href="#5-4配置hosts" class="headerlink" title="5.4配置hosts"></a>5.4配置hosts</h2><p> vi /etc/hosts</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10.2.6.250 hadoop1</span><br><span class="line"></span><br><span class="line">10.2.6.246 hadoop2</span><br><span class="line"></span><br><span class="line">10.2.6.248 hadoop3</span><br><span class="line"></span><br><span class="line">10.2.6.249 hadoop4</span><br></pre></td></tr></table></figure>
<p><strong>全部安装完毕后</strong></p>
<p>在主机上</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">service gmetad start</span><br><span class="line"></span><br><span class="line">service gmond start</span><br><span class="line"></span><br><span class="line">service httpd start</span><br><span class="line"></span><br><span class="line">service gmetad status    -------------------验证是否启动成功</span><br><span class="line"></span><br><span class="line">service gmond status   -------------------验证是否启动成功</span><br></pre></td></tr></table></figure>
<p>在监控节点上</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service gmond start  </span><br><span class="line"></span><br><span class="line">service gmond status   -------------------验证是否启动成功</span><br></pre></td></tr></table></figure>
<p>访问<a href="http://10.2.6.250/ganglia" target="_blank" rel="noopener">http://10.2.6.250/ganglia</a></p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>Forbidden错误时,因为对apache有一个设置</p>
<p>修改 /etc/httpd/conf.d/ganglia.conf文件内容Deny from all 为 allow from all</p>
<p>There was an error collecting ganglia data (127.0.0.1:8652):fsockopen error: Permission denied </p>
<p>解决方法</p>
<p>1 永久方法 – 需要重启服务器</p>
<p>修改/etc/selinux/config文件中设置SELINUX=disabled ，然后重启服务器。</p>
<p>2 临时方法 – 设置系统参数</p>
<p>使用命令setenforce 0</p>
<p>附：</p>
<p>setenforce 1 设置SELinux 成为enforcing模式</p>
<p>setenforce 0 设置SELinux 成为permissive模式</p>
<p><strong>There was an error collecting ganglia data (127.0.0.1:8652):fsockopen error: Connection refused **</strong>解决办法**</p>
<p>卸载yum remove ganglia-web ganglia-gmetad</p>
<p>重新安装yum install ganglia-web    —– ganglia-web本身有引用gmetad</p>
<p>重启即可</p>
<p><a href="http://redhatdebian.blog.51cto.com/1197273/828992" target="_blank" rel="noopener">http://redhatdebian.blog.51cto.com/1197273/828992</a></p>
 

	    
</div>

<div class="center">
			

				<span class="post-meta">		
				<span class="iconfont icon-category"></span>
				<a class="category-link" href="/categories/大数据/">大数据</a>
				</span>
		
			

		
				
				<span class="post-meta">
				<span class="iconfont icon-tag"></span>
				<a class="tag-link" href="/tags/集群/">集群</a>
				</span>			
			


		

		<span class="post-words"><span class="iconfont icon-words"></span>
		3477
		</span>		
</div>		

		
    <a class="article-readmore" href="/2017/11/11/Linux集群资源监控/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2017/11/05/Switch能否用string做参数/">Switch能否用string做参数</a>  
	       
		 

		 <time>2017-11-05 </time>    
	</div>


    <div class="article-excerpt">	
	
  	

	  

	  	<p>在jdk 7 之前，switch 只能支持 byte、short、char、int 这几个基本数据类型和其对应的封装类型。switch后面的括号里面只能放int类型的值，但由于byte，short，char类型，它们会 自动 转换为int类型（精精度小的向大的转化），所以它们也支持。</p>
<p>为什么jdk1.7后又可以用string类型作为switch参数呢？</p>
<p>其实，jdk1.7并没有新的指令来处理switch string，而是通过调用switch中string.hashCode,将string转换为int从而进行判断。</p>
 

	    
</div>

<div class="center">
			

				<span class="post-meta">		
				<span class="iconfont icon-category"></span>
				<a class="category-link" href="/categories/java/">java</a>
				</span>
		
			

		
				
				<span class="post-meta">
				<span class="iconfont icon-tag"></span>
				<a class="tag-link" href="/tags/java/">java</a> <a class="tag-link" href="/tags/复习/">复习</a>
				</span>			
			


		

		<span class="post-words"><span class="iconfont icon-words"></span>
		253
		</span>		
</div>		

		
    <a class="article-readmore" href="/2017/11/05/Switch能否用string做参数/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2017/11/05/TreeMap、HashMap、LindedHashMap的区别/">TreeMap、HashMap、LindedHashMap的区别</a>  
	       
		 

		 <time>2017-11-05 </time>    
	</div>


    <div class="article-excerpt">	
	
  	

	  

	  	<p>Map主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重复。<br>Hashmap 是一个最常用的Map,它根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。<br>Hashtable与 HashMap类似,它继承自Dictionary类，不同的是:它不允许记录的键或者值为空;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢。<br>LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。<br>TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。</p>
<p>一般情况下，我们用的最多的是HashMap,HashMap里面存入的键值对在取出的时候是随机的,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。<br>TreeMap取出来的是排序后的键值对。但如果您要<strong>按自然顺序或自定义顺序遍历键</strong>，那么TreeMap会更好。<br>LinkedHashMap 是HashMap的一个子类，如果需要<strong>输出的顺序和输入的相同</strong>,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列，像连接池中可以应用。</p>
<p>\1. HashSet是通过HashMap实现的,TreeSet是通过TreeMap实现的,只不过Set用的只是Map的key<br>\2. Map的key和Set都有一个共同的特性就是集合的唯一性.TreeMap更是多了一个排序的功能.<br>\3. hashCode和equal()是HashMap用的, 因为无需排序所以只需要关注定位和唯一性即可.<br>   a. hashCode是用来计算hash值的,hash值是用来确定hash表索引的.<br>   b. hash表中的一个索引处存放的是一张链表, 所以还要通过equal方法循环比较链上的每一个对象<br>       才可以真正定位到键值对应的Entry.<br>   c. put时,如果hash表中没定位到,就在链表前加一个Entry,如果定位到了,则更换Entry中的value,并返回旧value<br>\4. 由于TreeMap需要排序,所以需要一个Comparator为键值进行大小比较.当然也是用Comparator定位的.<br>   a. Comparator可以在创建TreeMap时指定<br>   b. 如果创建时没有确定,那么就会使用key.compareTo()方法,这就要求key必须实现Comparable接口.<br>   c. TreeMap是使用Tree数据结构实现的,所以使用compare接口就可以完成定位了.</p>
<p>注意：<br>1、Collection没有get()方法来取得某个元素。只能通过iterator()遍历元素。<br>2、Set和Collection拥有一模一样的接口。<br>3、List，可以通过get()方法来一次取出一个元素。使用数字来选择一堆对象中的一个，get(0)…。(add/get)<br>4、一般使用ArrayList。用LinkedList构造堆栈stack、队列queue。<br>5、Map用 put(k,v) / get(k)，还可以使用containsKey()/containsValue()来检查其中是否含有某个key/value。<br>      HashMap会利用对象的hashCode来快速找到key。 </p>
<pre><code>*     hashing 
      哈希码就是将对象的信息经过一些转变形成一个独一无二的int值，这个值存储在一个array中。 
      我们都知道所有存储结构中，array查找速度是最快的。所以，可以加速查找。 
      发生碰撞时，让array指向多个values。即，数组每个位置上又生成一个梿表。 
</code></pre><p>6、Map中元素，可以将key序列、value序列单独抽取出来。<br>使用keySet()抽取key序列，将map中的所有keys生成一个Set。<br>使用values()抽取value序列，将map中的所有values生成一个Collection。<br>为什么一个生成Set，一个生成Collection？那是因为，key总是独一无二的，value允许重复。 </p>
 

	    
</div>

<div class="center">
			

				<span class="post-meta">		
				<span class="iconfont icon-category"></span>
				<a class="category-link" href="/categories/java/">java</a>
				</span>
		
			

		
				
				<span class="post-meta">
				<span class="iconfont icon-tag"></span>
				<a class="tag-link" href="/tags/java/">java</a> <a class="tag-link" href="/tags/复习/">复习</a>
				</span>			
			


		

		<span class="post-words"><span class="iconfont icon-words"></span>
		2096
		</span>		
</div>		

		
    <a class="article-readmore" href="/2017/11/05/TreeMap、HashMap、LindedHashMap的区别/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2017/11/05/Collection包结构，与Collections的区别/">Collection包结构，与Collections的区别</a>  
	       
		 

		 <time>2017-11-05 </time>    
	</div>


    <div class="article-excerpt">	
	
  	

	  

	  	<ol>
<li>Collection是集合类的一个顶级接口，其直接继承接口有List与Set</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">而Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</span><br><span class="line"></span><br><span class="line">Collection是个java.util下的接口，它是各种集合结构的父接口。</span><br><span class="line"></span><br><span class="line">Collections是个java.util下的类，它包含有各种有关集合操作的静态方法。</span><br><span class="line"></span><br><span class="line">Collection 层次结构中的根接口。Collection 表示一组对象，这些对象也称为 collection的*元素*。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。JDK 不提供此接口的任何*直接* 实现：它提供更具体的子接口（如 `Set` 和 `List`）实现。此接口通常用来传递 collection，并在需要最大普遍性的地方操作这些 collection。</span><br><span class="line"></span><br><span class="line">Collection   </span><br><span class="line">├List   </span><br><span class="line">│├LinkedList   </span><br><span class="line">│├ArrayList   </span><br><span class="line">│└Vector   </span><br><span class="line">│　└Stack   </span><br><span class="line">└Set </span><br><span class="line"></span><br><span class="line">collections 此类完全由在 collection 上进行操作或返回 collection 的静态方法组成。它包含在 collection 上操作的多态算法，即“包装器”，包装器返回由指定 collection 支持的新 collection，以及少数其他内容。 如果为此类的方法所提供的 collection 或类对象为 null，则这些方法都会抛出 `NullPointerException`。</span><br></pre></td></tr></table></figure>
<p>​    </p>
 

	    
</div>

<div class="center">
			

				<span class="post-meta">		
				<span class="iconfont icon-category"></span>
				<a class="category-link" href="/categories/java/">java</a>
				</span>
		
			

		
				
				<span class="post-meta">
				<span class="iconfont icon-tag"></span>
				<a class="tag-link" href="/tags/java/">java</a> <a class="tag-link" href="/tags/复习/">复习</a>
				</span>			
			


		

		<span class="post-words"><span class="iconfont icon-words"></span>
		678
		</span>		
</div>		

		
    <a class="article-readmore" href="/2017/11/05/Collection包结构，与Collections的区别/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2017/11/05/Interface与abstract类的区别/">Interface与abstract类的区别</a>  
	       
		 

		 <time>2017-11-05 </time>    
	</div>


    <div class="article-excerpt">	
	
  	

	  

	  	<ol>
<li>含有abstract修饰符的class即为抽象类，abstract 类不能创建的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。**接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final**。</span><br></pre></td></tr></table></figure>
<p>​     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">下面比较一下两者的语法区别：</span><br><span class="line"></span><br><span class="line">1.抽象类可以有构造方法，接口中不能有构造方法。</span><br><span class="line"></span><br><span class="line">2.抽象类中可以有普通成员变量，接口中没有普通成员变量</span><br><span class="line"></span><br><span class="line">3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。</span><br><span class="line"></span><br><span class="line">\4. 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然</span><br><span class="line"></span><br><span class="line">eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。</span><br><span class="line"></span><br><span class="line">\5. 抽象类中可以包含静态方法，接口中不能包含静态方法</span><br><span class="line"></span><br><span class="line">\6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。</span><br><span class="line"></span><br><span class="line">\7. 一个类可以实现多个接口，但只能继承一个抽象类。</span><br></pre></td></tr></table></figure>
<p>​     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">下面接着再说说两者在应用上的区别：</span><br><span class="line"></span><br><span class="line">　　接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码。</span><br></pre></td></tr></table></figure>
 

	    
</div>

<div class="center">
			

				<span class="post-meta">		
				<span class="iconfont icon-category"></span>
				<a class="category-link" href="/categories/java/">java</a>
				</span>
		
			

		
				
				<span class="post-meta">
				<span class="iconfont icon-tag"></span>
				<a class="tag-link" href="/tags/java/">java</a> <a class="tag-link" href="/tags/复习/">复习</a>
				</span>			
			


		

		<span class="post-words"><span class="iconfont icon-words"></span>
		972
		</span>		
</div>		

		
    <a class="article-readmore" href="/2017/11/05/Interface与abstract类的区别/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2017/11/05/equals与==的区别/">equals与==的区别</a>  
	       
		 

		 <time>2017-11-05 </time>    
	</div>


    <div class="article-excerpt">	
	
  	

	  

	  	<p><strong>== 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。</strong></p>
<p>1、比较的是操作符两端的操作数是否是同一个对象。<br>2、两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。<br>3、比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如：<br>int a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。</p>
<h2 id="equals："><a href="#equals：" class="headerlink" title="equals："></a><strong>equals：</strong></h2><p>　　<strong>equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。</strong></p>
<p>　　String s=”abce”是一种非常特殊的形式,和new 有本质的区别。它是java中唯一不需要new 就可以产生对象的途径。以String s=”abce”;形式赋值在java中叫直接量,它是在常量池中而不是象new一样放在压缩堆中。这种形式的字符串，在JVM内部发生字符串拘留，即当声明这样的一个字符串后，JVM会在常量池中先查找有有没有一个值为”abcd”的对象,如果有,就会把它赋给当前引用.即原来那个引用和现在这个引用指点向了同一对象,如果没有,则在常量池中新创建一个”abcd”,下一次如果有String s1 = “abcd”;又会将s1指向”abcd”这个对象,即以这形式声明的字符串,只要值相等,任何多个引用都指向同一对象.<br>　　而String s = new String(“abcd”);和其它任何对象一样.每调用一次就产生一个对象，只要它们调用。</p>
<p>　　也可以这么理解: String str = “hello”; 先在内存中找是不是有”hello”这个对象,如果有，就让str指向那个”hello”.如果内存里没有”hello”，就创建一个新的对象保存”hello”. String str=new String (“hello”) 就是不管内存里是不是已经有”hello”这个对象，都新建一个对象保存”hello”。</p>
 

	    
</div>

<div class="center">
			

				<span class="post-meta">		
				<span class="iconfont icon-category"></span>
				<a class="category-link" href="/categories/java/">java</a>
				</span>
		
			

		
				
				<span class="post-meta">
				<span class="iconfont icon-tag"></span>
				<a class="tag-link" href="/tags/java/">java</a> <a class="tag-link" href="/tags/复习/">复习</a>
				</span>			
			


		

		<span class="post-words"><span class="iconfont icon-words"></span>
		913
		</span>		
</div>		

		
    <a class="article-readmore" href="/2017/11/05/equals与==的区别/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2017/11/05/java多态的实现原理/">java多态的实现原理</a>  
	       
		 

		 <time>2017-11-05 </time>    
	</div>


    <div class="article-excerpt">	
	
  	

	  

	  	<p><strong>1．Java多态概述</strong></p>
<p>多态是面向对象编程语言的重要特性，它允许基类的指针或引用指向派生类的对象，而在具体访问时实现方法的动态绑定。Java 对于方法调用动态绑定的实现主要依赖于方法表，但通过类引用调用(invokevitual)和接口引用调用(invokeinterface)的实现则有所不同。</p>
<p>类引用调用的大致过程为：Java编译器将Java源代码编译成class文件，在编译过程中，会根据静态类型将调用的符号引用写到class文件中。在执行时，JVM根据class文件找到调用方法的符号引用，然后在静态类型的方法表中找到偏移量，然后根据this指针确定对象的实际类型，使用实际类型的方法表，偏移量跟静态类型中方法表的偏移量一样，如果在实际类型的方法表中找到该方法，则直接调用，否则，认为没有重写父类该方法。按照继承关系从下往上搜索。 </p>
<p>接口引用调用后面再说吧。</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/java/d1" alt="img"></p>
<p>从上图可以看出，当程序运行时，需要某个类时，类载入子系统会将相应的class文件载入到JVM中，并在内部建立该类的类型信息（这个类型信息其实就是class文件在JVM中存储的一种数据结构），包含java类定义的所有信息，包括方法代码，类变量、成员变量、以及本博文要重点讨论的方法表。这个类型信息就存储在方法区。<br>注意，这个方法区中的类型信息跟在堆中存放的class对象是不同的。在方法区中，这个class的类型信息只有唯一的实例（所以是各个线程共享的内存区域），而在堆中可以有多个该class对象。可以通过堆中的class对象访问到方法区中类型信息。就像在java反射机制那样，通过class对象可以访问到该类的所有信息一样。</p>
<p>【重点】 </p>
<p>方法表是实现动态调用的核心。上面讲过方法表存放在方法区中的类型信息中。为了优化对象调用方法的速度，方法区的类型信息会增加一个指针，该指针指向一个记录该类方法的方法表，方法表中的每一个项都是对应方法的指针。<br>这些方法中包括从父类继承的所有方法以及自身重写（override）的方法。</p>
<p>【拓展】</p>
<p>方法区：方法区和JAVA堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>运行时常量池：它是方法区的一部分，Class文件中除了有类的版本、方法、字段等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分信息在类加载时进入方法区的运行时常量池中。<br>方法区的内存回收目标是针对常量池的回收及对类型的卸载。</p>
<p><strong>3**</strong>．<strong>**Java</strong> <strong>的方法调用方式（拓展知识，可以不看）</strong></p>
<p>Java 的方法调用有两类，动态方法调用与静态方法调用。</p>
<p>静态方法调用是指对于类的静态方法的调用方式，是静态绑定的；而动态方法调用需要有方法调用所作用的对象，是动态绑定的。</p>
<p>类调用 (invokestatic) 是在编译时就已经确定好具体调用方法的情况。</p>
<p>实例调用 (invokevirtual)则是在调用的时候才确定具体的调用方法，这就是动态绑定，也是多态要解决的核心问题。</p>
<p>JVM 的方法调用指令有四个，分别是 invokestatic，invokespecial，invokesvirtual 和 invokeinterface。前两个是静态绑定，后两个是动态绑定的。本文也可以说是对于JVM后两种调用实现的考察。</p>
<p><strong>4．方法表与方法调用</strong></p>
<p>如有类定义 Person, Girl, Boy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public String toString()&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return &quot;I&apos;m a person.&quot;;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public void eat()&#123;&#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public void speak()&#123;&#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> class Boy extends Person&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public String toString()&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return &quot;I&apos;m a boy&quot;;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public void speak()&#123;&#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public void fight()&#123;&#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> class Girl extends Person&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public String toString()&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return &quot;I&apos;m a girl&quot;;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public void speak()&#123;&#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public void sing()&#123;&#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>当这三个类被载入到</p>
<p> Java </p>
<p>虚拟机之后，方法区中就包含了各自的类的信息。</p>
<p>Girl </p>
<p>和</p>
<p> Boy </p>
<p>在方法区中的方法表可表示如下：</p>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/java/d2" alt="img"></p>
<p>可以看到，Girl 和 Boy 的方法表包含继承自 Object 的方法，继承自直接父类 Person 的方法及各自新定义的方法。注意方法表条目指向的具体的方法地址，如 Girl 继承自 Object 的方法中，只有 toString() 指向自己的实现（Girl 的方法代码），其余皆指向 Object 的方法代码；其继承自于 Person 的方法 eat() 和 speak() 分别指向 Person 的方法实现和本身的实现。</p>
<p>如果子类改写了父类的方法，那么子类和父类的那些同名的方法共享一个方法表项。</p>
<p>因此，方法表的偏移量总是固定的。所有继承父类的子类的方法表中，其父类所定义的方法的偏移量也总是一个定值。<br>Person 或 Object中的任意一个方法，在它们的方法表和其子类 Girl 和 Boy 的方法表中的位置 (index) 是一样的。这样 JVM 在调用实例方法其实只需要指定调用方法表中的第几个方法即可。</p>
<p>如调用如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Party&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void happyHour()&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person girl = new Girl();   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">girl.speak(); &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当编译 Party 类的时候，生成 girl.speak()的方法调用假设为：</p>
<p>Invokevirtual #12</p>
<p>设该调用代码对应着 girl.speak(); #12 是 Party 类的常量池的索引。JVM 执行该调用指令的过程如下所示：</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/java/d3" alt="img"></p>
<p>（1）</p>
<p>在常量池（这里有个错误，上图为ClassReference常量池而非Party的常量池）中找到方法</p>
<p>调用的符号引用</p>
<p>。</p>
<p>（2）查看</p>
<p>Person的方法表，</p>
<p>得到</p>
<p>speak</p>
<p>方法在该方法表的偏移量</p>
<p>（假设为15），这样就得到该方法的直接引用。 </p>
<p>（3）根据this指针得到</p>
<p>具体的对象</p>
<p>（即 girl 所指向的位于堆中的对象）。</p>
<p>（4）</p>
<p>根据对象得到该对象对应的方法表</p>
<p>，根据偏移量15查看有无重写（override）该方法，</p>
<p>如果重写，则可以直接调用（</p>
<p>Girl</p>
<p>的方法表的</p>
<p>speak</p>
<p>项指向自身的方法而非父类）；如果没有重写，则需要拿到按照继承关系从下往上的基类（这里是</p>
<p>Person</p>
<p>类）的方法表，同样按照这个偏移量</p>
<p>15</p>
<p>查看有无该方法。</p>
<p><strong>5．接口调用</strong></p>
<p>因为 Java 类是可以同时实现多个接口的，而当用接口引用调用某个方法的时候，情况就有所不同了。</p>
<p>Java 允许一个类实现多个接口，从某种意义上来说相当于多继承，这样同样的方法在基类和派生类的方法表的位置就可能不一样了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">interface IDance&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   void dance();   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> class Person &#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public String toString()&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   return &quot;I&apos;m a person.&quot;;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public void eat()&#123;&#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public void speak()&#123;&#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> class Dancer extends Person   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> implements IDance &#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public String toString()&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   return &quot;I&apos;m a dancer.&quot;;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public void dance()&#123;&#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> class Snake implements IDance&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public String toString()&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   return &quot;A snake.&quot;;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public void dance()&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> //snake dance   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，由于接口的介入，继承自于接口 IDance 的方法 dance()在类 Dancer 和 Snake 的方法表中的位置已经不一样了，显然我们无法仅根据偏移量来进行方法的调用。</p>
<p>Java 对于接口方法的调用是采用搜索方法表的方式，如，要在Dancer的方法表中找到dance()方法，必须搜索Dancer的整个方法表。</p>
<p>因为每次接口调用都要搜索方法表，所以从效率上来说，接口方法的调用总是慢于类方法的调用的。</p>
 

	    
</div>

<div class="center">
			

				<span class="post-meta">		
				<span class="iconfont icon-category"></span>
				<a class="category-link" href="/categories/java/">java</a>
				</span>
		
			

		
				
				<span class="post-meta">
				<span class="iconfont icon-tag"></span>
				<a class="tag-link" href="/tags/java/">java</a> <a class="tag-link" href="/tags/复习/">复习</a>
				</span>			
			


		

		<span class="post-words"><span class="iconfont icon-words"></span>
		4065
		</span>		
</div>		

		
    <a class="article-readmore" href="/2017/11/05/java多态的实现原理/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2017/11/05/Java的四种引用，强弱软虚，用到的场景/">Java的四种引用，强弱软虚，用到的场景</a>  
	       
		 

		 <time>2017-11-05 </time>    
	</div>


    <div class="article-excerpt">	
	
  	

	  

	  	<p>我们知道java语言提供了4种引用类型：强引用、软引用(SoftReference)、弱引用（WeakReference）和幽灵引用（PhantomReference），与引用密切相关的，还有一个引用队列ReferenceQueue。引用和引用队列的关系，对于垃圾回收来说非常重要，学习垃圾回收机制，必须要先了解引用和引用队列的使用方法。本文主要参考网上的一些理论，同时配合自己的一些测试代码，更好的理解这些概念。这篇博客也解决了 <strong>System.gc()和-XX:+DisableExplicitGC启动参数，以及DirectByteBuffer的内存释放</strong> 中遗留的幽灵引用的问题。</p>
<p><strong>1、强引用</strong></p>
<p>强引用不会被GC回收，并且在java.lang.ref里也没有实际的对应类型，平时工作接触的最多的就是强引用。<br>　 Object obj = new Object();这里的obj引用便是一个强引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，<strong>垃圾回收器绝不会回收它</strong>。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<p><strong>2、软引用</strong></p>
<p>如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果<strong>内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存</strong>。只 要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p>/<em>* </em> 只有当内存不够的时候，才回收这类内存，因此在内存足够的时候，它们通常不被回收 <em> </em></p>
<p>* 无论是否发送GC,执行结果都是: <em> java.lang.Object@f9f9d8 </em> null <em> java.lang.Object@f9f9d8 </em> null *</p>
<p>* <em> 可以看到:只有发送了GC,将对于从内存中释放的时候,JVM才会将reference假如引用队列 </em>/ public static void soft() throws Exception { Object obj = new Object(); ReferenceQueue refQueue = new ReferenceQueue(); SoftReference softRef = new SoftReference(obj, refQueue); System.out.println(softRef.get()); // java.lang.Object@f9f9d8 System.out.println(refQueue.poll());// null // 清除强引用,触发GC obj = null; System.gc(); System.out.println(softRef.get()); Thread.sleep(200); System.out.println(refQueue.poll()); }</p>
<p>这里有几点需要说明：</p>
<p>1、System.gc()告诉JVM这是一个执行GC的好时机，但具体执不执行由JVM决定（事实上这段代码一般都会执行GC)</p>
<p>2、Thread.sleep(200); 这是因为从对象被回收到JVM将引用加入refQueue队列，需要一定的时间。而且poll并不是一个阻塞方法，如果没有数据会返回null，所以我们选择等待一段时间。</p>
<p><strong>3、弱引用</strong></p>
<p>如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，<strong>一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存</strong>。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回 收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p>/<em>* </em> 弱引用: 当发生GC的时候,Weak引用对象总是会内回收回收。因此Weak引用对象会更容易、更快被GC回收。 <em> Weak引用对象常常用于Map数据结构中，引用占用内存空间较大的对象 </em> *</p>
<p>* 如果不发生垃圾回收： <em> java.lang.Object@f9f9d8 </em> null <em> java.lang.Object@f9f9d8 </em> null <em> </em> 如果发生垃圾回收: <em> java.lang.Object@f9f9d8 </em> null <em> null </em> java.lang.ref.WeakReference@422ede <em> </em></p>
<p>*/ public static void weak() throws Exception { Object obj = new Object(); ReferenceQueue refQueue = new ReferenceQueue(); WeakReference weakRef = new WeakReference(obj, refQueue); System.out.println(weakRef.get()); // java.lang.Object@f9f9d8 System.out.println(refQueue.poll());// null // 清除强引用,触发GC obj = null; System.gc(); System.out.println(weakRef.get()); // 这里特别注意:poll是非阻塞的,remove是阻塞的. // JVM将弱引用放入引用队列需要一定的时间,所以这里先睡眠一会儿 // System.out.println(refQueue.poll());// 这里有可能是null Thread.sleep(200); System.out.println(refQueue.poll()); // System.out.println(refQueue.poll());//这里一定是null,因为已经从队列中移除 // System.out.println(refQueue.remove()); }</p>
<p>这里需要注意下：</p>
<p>1、remove这是一个阻塞方法，类似于J.U.C并发包下的阻塞队列，如果没有队列没有数据，那么当前线程一直等待。<br>2、如果队列有数据，那么remove和pool都会将第一个元素出队。</p>
<p><strong>4、幽灵引用(虚引用)</strong><br>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果<strong>发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列</strong>中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。由于Object.finalize()方法的不安全性、低效性，常常使用虚引用完成对象回收前的资源释放工作。参考我的另一篇博客：<strong>解释为什么finalize是不安全的，不建议使用</strong> </p>
<p>/<em>* </em> 当GC一但发现了虚引用对象，将会将PhantomReference对象插入ReferenceQueue队列. <em> 而此时PhantomReference所指向的对象并没有被GC回收，而是要等到ReferenceQueue被你真正的处理后才会被回收. </em> *</p>
<p>这里特别需要注意：当JVM将虚引用插入到引用队列的时候，虚引用执行的对象内存还是存在的。但是PhantomReference并没有暴露API返回对象。所以如果我想做清理工作，需要继承PhantomReference类，以便访问它指向的对象。如NIO直接内存的自动回收，就使用到了sun.misc.Cleaner</p>
 

	    
</div>

<div class="center">
			

				<span class="post-meta">		
				<span class="iconfont icon-category"></span>
				<a class="category-link" href="/categories/java/">java</a>
				</span>
		
			

		
				
				<span class="post-meta">
				<span class="iconfont icon-tag"></span>
				<a class="tag-link" href="/tags/java/">java</a> <a class="tag-link" href="/tags/复习/">复习</a>
				</span>			
			


		

		<span class="post-words"><span class="iconfont icon-words"></span>
		3203
		</span>		
</div>		

		
    <a class="article-readmore" href="/2017/11/05/Java的四种引用，强弱软虚，用到的场景/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2017/11/05/ArrayList、LinkedList、Vector的区别。/">ArrayList、LinkedList、Vector的区别。</a>  
	       
		 

		 <time>2017-11-05 </time>    
	</div>


    <div class="article-excerpt">	
	
  	

	  

	  	<p>1.这三个类都实现了List接口（List接口继承了Collection接口），但是也有以下区别</p>
<p>ArrayList和Vector</p>
<p>1&gt;.他们都是有序集合，即存储在这两个集合中的元素的位置都是有顺序即连续的，相当于一种动态的数组，我们以后可以按位置索引号取出某个元素，，并且其中的数据是允许重复的。</p>
<p>2&gt;.简单的说是ArrayList 和Vector 的底层数据是数组的结构</p>
<p><strong>ArrayList**</strong>和<strong>**Vector、LinkList</strong></p>
<p>3&gt;.LinkList<strong>即存储在这两个集合中的元素的位置是不连续的，底层数据结构是列表结构</strong></p>
<p>4&gt;.ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，查询速度快，</p>
<p>但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢</p>
<p>5&gt;.LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入,修改，删除 速度较快.</p>
<p>6&gt;.Vector是同步处理,性能较低；ArrayList是使用异步处理，性能高。</p>
<p>7&gt;.Vector是线程安全的，ArrayList是非线程安全。<strong>LinkedList是非线程安全</strong></p>
<p><strong>8&gt;.</strong>一般情况都用ArrayList，ArrayList占据内存小</p>
<p>2.还有数据方面（<strong>但是很少用到</strong>）的区别：</p>
<p>1&gt;.ArrayList与Vector都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加ArrayList与Vector的存储空间(每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡);</p>
<p>2&gt;.Vector默认增长为原来两倍，而ArrayList的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的1.5倍）</p>
<p>3&gt;.ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法</p>
 

	    
</div>

<div class="center">
			

				<span class="post-meta">		
				<span class="iconfont icon-category"></span>
				<a class="category-link" href="/categories/java/">java</a>
				</span>
		
			

		
				
				<span class="post-meta">
				<span class="iconfont icon-tag"></span>
				<a class="tag-link" href="/tags/java/">java</a> <a class="tag-link" href="/tags/复习/">复习</a>
				</span>			
			


		

		<span class="post-words"><span class="iconfont icon-words"></span>
		890
		</span>		
</div>		

		
    <a class="article-readmore" href="/2017/11/05/ArrayList、LinkedList、Vector的区别。/">阅读更多</a> 
    	
</article>     
     	
  

 

  <nav class="paginator">
    <a class="extend prev" rel="prev" href="/page/2/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">下一页</a>
  </nav>
  

</section> 

    </div>        

    
    <div class="mask"> </div>
    <div class="back-to-top iconfont icon-backtotop fadeIn"></div> 

    


<script src="/js/search.js"></script>     
          
          <div class="search-container sildeUpMin">
            <input type="text" placeholder="输入你想搜索的" id="search-input" class="search-input">  
              <span class="search-cancel iconfont icon-cancel"></span>
              <div id="search-result" class="search-result"></div>
          </div>
 

     <div class="mobile-menu">      

      
      <img class="mobile-menu-icon no-gallery" src= /img/favicon.png >   
      

         
            

            <a class="mobile-menu-link" href="/">首页
            </a>
            
         
            

            <a class="mobile-menu-link" href="/archives">归档
            </a>
            
         
            

            <a class="mobile-menu-link" href="/categories">分类
            </a>
            
         
            

            <a class="mobile-menu-link" href="/tags">标签
            </a>
            
         
            

            <a class="mobile-menu-link" href="/about">关于
            </a>
            
         
                          

            <a class="mobile-menu-link mobile-menu-search" href="#">搜索 </a>                 
            
         
</div>     
    

<footer id="footer">
	   
   	 <div>	
	   	    	
   	 </div>
   
   	 
	 <div>
	 	&copy;
		2018
		Rui Min	 

	 </div>


   
   	 <div>
	
	 <a href="http://hexo.io/" target="_blank">Hexo</a>

	 Theme

	 <a href="https://github.com/Lemonreds/hexo-theme-Nayo" target="_blank">Nayo</a> 

	 </div>	


	
	
</footer> 
    

<!-- Baidu Analytics -->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?636802045446222199ae541e32c8133e"; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




 
  </body>   
  <script src="/js/animation.js"></script>   
</html>