<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.0//EN" "http://www.wapforum.org/DTD/xhtml-mobile10.dtd">
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport"content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes"/>
  
  
  <title>  Min‘s blog</title>

 
  
    <link rel="icon" href="/img/favicon.png">
  


  <!-- css -->
  <link rel="stylesheet" href="/css/style.css">  
  <!-- Jquery -->
  <script src="//cdn.staticfile.org/jquery/3.2.1/jquery.min.js"></script> 
  <!-- Add fancyBox -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.1.25/jquery.fancybox.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.1.25/jquery.fancybox.min.js"></script> 
  <script src="/js/gallery.js"></script>
  <!-- javascript --> 
  <script src="/js/mobile.js"></script>  
  <script src="/js/utils.js"></script>    
  <script src="/js/script.js"></script>  
</head> 
  <body> 
    <header class="header">
	
  <nav class="header-nav">       
	
  	<span class="iconfont icon-menu mobile-toggle"></span>  

    <a class="header-logo" href="/"><span>Min&#39;s blog</a>  

    <div class="header-menu">          
              
            

              <a class="header-menu-link" id="header-menu-home" href="/">首页</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-archives" href="/archives">归档</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-categories" href="/categories">分类</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-tags" href="/tags">标签</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-about" href="/about">关于</a>     

            
            
            

              <a class="iconfont icon-menu-search header-menu-link" id="header-menu-search"></a>

            
                
    </div>  
    
  </nav>
</header>

    <div class="container">         
      
        

          <section id="main">  

        

        


<div class="profile sildeUpMin">

		<img class="avatar no-gallery" src="/img/timg.jpeg"  alt="Lose">
					
		<p class="author">Rui Min</p>

		
			<p class="location"><span class="iconfont icon-location"></span>BeiJing CN</p>
		
	
		<div class="social">
   		    	
		<a href="https://github.com/bjcoder" class="iconfont icon-github" target="_blank" title="github"></a>
	        	
		<a href="/" class="iconfont icon-others" target="_blank" title="others"></a>
	    
    	</div>		
</div>

      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2017/11/05/Hashcode的作用/">Hashcode的作用</a>  
	       
		 

		 <time>2017-11-05 </time>    
	</div>


    <div class="article-excerpt">	
	
  	

	  

	  	<p><strong>Hash</strong></p>
<p>先用一张图看下什么是Hash</p>
<p><img src="http://images2015.cnblogs.com/blog/801753/201509/801753-20150927112453678-436094926.jpg" alt="img"></p>
<p>Hash是散列的意思，就是把任意长度的输入，通过散列算法变换成固定长度的输出，该输出就是散列值。关于散列值，有以下几个关键结论：</p>
<p>1、如果散列表中存在和散列原始输入K相等的记录，那么K必定在f(K)的存储位置上</p>
<p>2、<strong>不同关键字经过散列算法变换后可能得到同一个散列地址，这种现象称为碰撞</strong></p>
<p>3、<strong>如果两个Hash值不同（前提是同一Hash算法），那么这两个Hash值对应的原始输入必定不同</strong></p>
<p><strong>HashCode</strong></p>
<p>然后讲下什么是HashCode，总结几个关键点：</p>
<p>1、HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的</p>
<p>2、如果两个对象equals相等，那么这两个对象的HashCode一定也相同</p>
<p>3、如果对象的equals方法被重写，那么对象的HashCode方法也尽量重写</p>
<p>4、如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置</p>
<p><strong>HashCode有什么用</strong></p>
<p>回到最关键的问题，HashCode有什么用？不妨举个例子：</p>
<p>1、假设内存中有0 1 2 3 4 5 6 7 8这8个位置，如果我有个字段叫做ID，那么我要把这个字段存放在以上8个位置之一，如果不用HashCode而任意存放，那么当查找时就需要到8个位置中去挨个查找</p>
<p>2、使用HashCode则效率会快很多，把ID的HashCode%8，然后把ID存放在取得余数的那个位置，然后每次查找该类的时候都可以通过ID的HashCode%8求余数直接找到存放的位置了</p>
<p>3、如果ID的HashCode%8算出来的位置上本身已经有数据了怎么办？这就取决于算法的实现了，比如ThreadLocal中的做法就是从算出来的位置向后查找第一个为空的位置，放置数据；HashMap的做法就是通过链式结构连起来。反正，只要保证放的时候和取的时候的算法一致就行了。</p>
<p>4、如果ID的HashCode%8相等怎么办（这种对应的是第三点说的链式结构的场景）？这时候就需要定义equals了。先通过HashCode%8来判断类在哪一个位置，再通过equals来在这个位置上寻找需要的类。对比两个类的时候也差不多，先通过HashCode比较，假如HashCode相等再判断equals。<strong>如果两个类的HashCode都不相同，那么这两个类必定是不同的</strong>。</p>
<p>举个实际的例子Set。我们知道Set里面的元素是不可以重复的，那么如何做到？Set是根据equals()方法来判断两个元素是否相等的。比方说Set里面已经有1000个元素了，那么第1001个元素进来的时候，最多可能调用1000次equals方法，如果equals方法写得复杂，对比的东西特别多，那么效率会大大降低。使用HashCode就不一样了，比方说HashSet，底层是基于HashMap实现的，先通过HashCode取一个模，这样一下子就固定到某个位置了，如果这个位置上没有元素，那么就可以肯定HashSet中必定没有和新添加的元素equals的元素，就可以直接存放了，都不需要比较；如果这个位置上有元素了，逐一比较，比较的时候先比较HashCode，HashCode都不同接下去都不用比了，肯定不一样，HashCode相等，再equals比较，没有相同的元素就存，有相同的元素就不存。如果原来的Set里面有相同的元素，只要HashCode的生成方式定义得好（不重复），不管Set里面原来有多少元素，只需要执行一次的equals就可以了。这样一来，实际调用equals方法的次数大大降低，提高了效率。</p>
 

	    
</div>

<div class="center">
			

				<span class="post-meta">		
				<span class="iconfont icon-category"></span>
				<a class="category-link" href="/categories/java/">java</a>
				</span>
		
			

		
				
				<span class="post-meta">
				<span class="iconfont icon-tag"></span>
				<a class="tag-link" href="/tags/java/">java</a> <a class="tag-link" href="/tags/复习/">复习</a>
				</span>			
			


		

		<span class="post-words"><span class="iconfont icon-words"></span>
		1505
		</span>		
</div>		

		
    <a class="article-readmore" href="/2017/11/05/Hashcode的作用/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2017/11/05/快速排序/">快速排序</a>  
	       
		 

		 <time>2017-11-05 </time>    
	</div>


    <div class="article-excerpt">	
	
  	

	  

	  	<h1 id="图解快速排序"><a href="#图解快速排序" class="headerlink" title="图解快速排序"></a>图解快速排序</h1><p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/idea/WechatIMG9.jpeg" alt="kspx"></p>
<h1 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> _left,<span class="keyword">int</span> _right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = _left;</span><br><span class="line">        <span class="keyword">int</span> right = _right;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(left &lt;= right)&#123;   <span class="comment">//待排序的元素至少有两个的情况</span></span><br><span class="line">            temp = arr[left];  <span class="comment">//待排序的第一个元素作为基准元素</span></span><br><span class="line">            <span class="keyword">while</span>(left != right)&#123;   <span class="comment">//从左右两边交替扫描，直到left = right</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(right &gt; left &amp;&amp; arr[right] &gt;= temp)  </span><br><span class="line">                     right --;        <span class="comment">//从右往左扫描，找到第一个比基准元素小的元素</span></span><br><span class="line">                  arr[left] = arr[right];  <span class="comment">//找到这种元素arr[right]后与arr[left]交换</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt;= temp)</span><br><span class="line">                     left ++;         <span class="comment">//从左往右扫描，找到第一个比基准元素大的元素</span></span><br><span class="line">                  arr[right] = arr[left];  <span class="comment">//找到这种元素arr[left]后，与arr[right]交换</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            arr[right] = temp;    <span class="comment">//基准元素归位</span></span><br><span class="line">            quickSort(arr,_left,left-<span class="number">1</span>);  <span class="comment">//对基准元素左边的元素进行递归排序</span></span><br><span class="line">            quickSort(arr, right+<span class="number">1</span>,_right);  <span class="comment">//对基准元素右边的进行递归排序</span></span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> array[] = &#123;<span class="number">10</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"排序之前："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> element : array)&#123;</span><br><span class="line">            System.out.print(element+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        quickSort(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"\n排序之后："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> element : array)&#123;</span><br><span class="line">            System.out.print(element+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 

	    
</div>

<div class="center">
			

				<span class="post-meta">		
				<span class="iconfont icon-category"></span>
				<a class="category-link" href="/categories/java/">java</a>
				</span>
		
			

		
				
				<span class="post-meta">
				<span class="iconfont icon-tag"></span>
				<a class="tag-link" href="/tags/java/">java</a> <a class="tag-link" href="/tags/复习/">复习</a>
				</span>			
			


		

		<span class="post-words"><span class="iconfont icon-words"></span>
		1036
		</span>		
</div>		

		
    <a class="article-readmore" href="/2017/11/05/快速排序/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2017/11/05/Static class 与non static class的区别/">Static class 与non static class的区别</a>  
	       
		 

		 <time>2017-11-05 </time>    
	</div>


    <div class="article-excerpt">	
	
  	

	  

	  	<table>
<thead>
<tr>
<th>static class</th>
<th>non static class</th>
</tr>
</thead>
<tbody>
<tr>
<td>1、用static修饰的是内部类，此时这个内部类变为静态内部类；对测试有用；2、内部静态类不需要有指向外部类的引用；3、静态类只能访问外部类的静态成员，不能访问外部类的非静态成员；</td>
<td>1、非静态内部类需要持有对外部类的引用；2、非静态内部类能够访问外部类的静态和非静态成员；3、一个非静态内部类不能脱离外部类实体被创建；4、一个非静态内部类可以访问外部类的数据和方法；</td>
</tr>
</tbody>
</table>
 

	    
</div>

<div class="center">
			

				<span class="post-meta">		
				<span class="iconfont icon-category"></span>
				<a class="category-link" href="/categories/java/">java</a>
				</span>
		
			

		
				
				<span class="post-meta">
				<span class="iconfont icon-tag"></span>
				<a class="tag-link" href="/tags/java/">java</a> <a class="tag-link" href="/tags/复习/">复习</a>
				</span>			
			


		

		<span class="post-words"><span class="iconfont icon-words"></span>
		221
		</span>		
</div>		

		
    <a class="article-readmore" href="/2017/11/05/Static class 与non static class的区别/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2017/11/05/Redis使用/">Redis使用</a>  
	       
		 

		 <time>2017-11-05 </time>    
	</div>


    <div class="article-excerpt">	
	
  	

	  

	  	<h1 id="1、Redis五种数据类型"><a href="#1、Redis五种数据类型" class="headerlink" title="1、Redis五种数据类型"></a>1、Redis五种数据类型</h1><pre><code>1、字符串（String）
2、哈希（hash）
3、字符串列表（list）
4、字符串集合（set）
5、有序字符串集合（sorted set）
</code></pre><h1 id="2、字符串类型"><a href="#2、字符串类型" class="headerlink" title="2、字符串类型"></a>2、字符串类型</h1><h2 id="2-1、赋值"><a href="#2-1、赋值" class="headerlink" title="2.1、赋值"></a>2.1、赋值</h2><p>set key value：设定key持有指定的字符串value，如果该key存在则进行覆盖操作。总是返回”OK”<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/set%20key%20value.png" alt="set key value"></p>
<h2 id="2-2、取值"><a href="#2-2、取值" class="headerlink" title="2.2、取值"></a>2.2、取值</h2><p>get key：获取key的value。如果与该key关联的value不是String类型，redis将返回错误信息，因为get命令只能用于获取String value；如果该key不存在，返回(nil)。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/get%20key.png" alt="get key"><br>getset key value：先获取该key的值，然后在设置该key的值。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/getset%20key%20value.png" alt="getset key value"></p>
<h2 id="2-3、删除"><a href="#2-3、删除" class="headerlink" title="2.3、删除"></a>2.3、删除</h2><p>del key ：删除指定key<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/del%20key.png" alt="del key"></p>
<h2 id="2-4、数值增减"><a href="#2-4、数值增减" class="headerlink" title="2.4、数值增减"></a>2.4、数值增减</h2><p>incr key：将指定的key的value原子性的递增1.如果该key不存在，其初始值为0，在incr之后其值为1。如果value的值不能转成整型，如hello，该操作将执行失败并返回相应的错误信息。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/incr%20key.png" alt="incr key"><br>decr key：将指定的key的value原子性的递减1.如果该key不存在，其初始值为0，在incr之后其值为-1。如果value的值不能转成整型，如hello，该操作将执行失败并返回相应的错误信息。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/decr%20key.png" alt="decr key"></p>
<h2 id="2-5、扩展命令"><a href="#2-5、扩展命令" class="headerlink" title="2.5、扩展命令"></a>2.5、扩展命令</h2><p>incrby key increment：将指定的key的value原子性增加increment，如果该key不存在，器初始值为0，在incrby之后，该值为increment。如果该值不能转成整型，如hello则失败并返回错误信息<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/incrby%20key%20increment.png" alt="incrby key increment"><br>decrby key decrement：将指定的key的value原子性减少decrement，如果该key不存在，器初始值为0，在decrby之后，该值为decrement。如果该值不能转成整型，如hello则失败并返回错误信息<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/decrby%20key%20decrement.png" alt="decrby key decrement"><br>append key value：拼凑字符串。如果该key存在，则在原有的value后追加该值；如果该key不存在，则重新创建一个key/value<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/append%20key%20value.png" alt="append key value"></p>
<h1 id="3、hash数据类型"><a href="#3、hash数据类型" class="headerlink" title="3、hash数据类型"></a>3、hash数据类型</h1><h2 id="3-1、概述"><a href="#3-1、概述" class="headerlink" title="3.1、概述"></a>3.1、概述</h2><p>   Redis中的Hash类型可以看成具有String Key和String Value的map容器。所以该类型非常适合于存储值对象的信息。如Username、Password和Age等。如果Hash中包含很少的字段，那么该类型的数据也将仅占用很少的磁盘空间。每一个Hash可以存储4294967295个键值对。</p>
<h2 id="3-2、存值"><a href="#3-2、存值" class="headerlink" title="3.2、存值"></a>3.2、存值</h2><p>hset key field value<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/hset%20key%20field%20value.png" alt="hset key field value"><br>hmset key field value field value<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/hmset%20key%20field%20value%20field%20value.png" alt="hmset key field value field value"></p>
<h2 id="3-3、取值"><a href="#3-3、取值" class="headerlink" title="3.3、取值"></a>3.3、取值</h2><p>hget key field：返回指定的key中的field的值<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/hget%20key%20field.png" alt="hget key field"><br>hmget key fileds：获取key中的多个filed的值<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/hmget%20key%20fileds.png" alt="hmget key fileds"><br>hgetall key：获取key中的所有filed-vaule<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/hgetall%20key.png" alt="hgetall key"></p>
<h2 id="3-4、删除"><a href="#3-4、删除" class="headerlink" title="3.4、删除"></a>3.4、删除</h2><p>hdel key field [field … ] ：可以删除一个或多个字段，返回值是被删除的字段个数<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/hdel%20key%20field%20%5Bfield%20%E2%80%A6%20%5D1.png" alt="hdel key field [field … ]1"><br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/hdel%20key%20field%20%5Bfield%20%E2%80%A6%20%5D2.png" alt="hdel key field [field … ]2"><br>del key ：删除整个内容<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/del%20key%20.png" alt="del key"></p>
<h2 id="3-5、增加数字"><a href="#3-5、增加数字" class="headerlink" title="3.5、增加数字"></a>3.5、增加数字</h2><p>hincrby key field value：为某个key的某个属性增加值<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/hincrby%20key%20field%20value.png" alt="hincrby key field value"></p>
<h2 id="3-6、自学命令"><a href="#3-6、自学命令" class="headerlink" title="3.6、自学命令"></a>3.6、自学命令</h2><p>hexists key field：判断指定的key中的filed是否存在<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/hexists%20key%20field.png" alt="hexists key field"><br>hlen key：获取key所包含的field的数量<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/hlen%20key.png" alt="hlen key"><br>hkeys key ：获得所有的key<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/hkeys%20key.png" alt="hkeys key"><br>hvals key：获得所有的value<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/hvals%20key.png" alt="hvals key"></p>
<h1 id="4、list类型"><a href="#4、list类型" class="headerlink" title="4、list类型"></a>4、list类型</h1><h2 id="4-1、概述"><a href="#4-1、概述" class="headerlink" title="4.1、概述"></a>4.1、概述</h2><p>在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的普通链表一样，我们可以在其头部(left)和尾部(right)添加新的元素。在插入时，如果该键并不存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。List中可以包含的最大元素数量是4294967295。<br>    从元素插入和删除的效率视角来看，如果我们是在链表的两头插入或删除元素，这将会是非常高效的操作，即使链表中已经存储了百万条记录，该操作也可以在常量时间内完成。然而需要说明的是，如果元素插入或删除操作是作用于链表中间，那将会是非常低效的。相信对于有良好数据结构基础的开发者而言，这一点并不难理解。<br>  1、ArrayList使用数组方式存储数据，所以根据索引查询数据速度快，而新增或者删除元素时需要设计到位移操作，所以比较慢。<br>  2、LinkedList使用双向链接方式存储数据，每个元素都记录前后元素的指针，所以插入、删除数据时只是更改前后元素的指针指向即可，速度非常快，然后通过下标查询元素时需要从头开始索引，所以比较慢。<br>  3、双向链表中添加数据<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image39.png" alt="image39"><br>  4、双向链表中删除数据<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image40.png" alt="image40"></p>
<h2 id="4-2、常用命令"><a href="#4-2、常用命令" class="headerlink" title="4.2、常用命令"></a>4.2、常用命令</h2><h3 id="4-2-1、两端添加"><a href="#4-2-1、两端添加" class="headerlink" title="4.2.1、两端添加"></a>4.2.1、两端添加</h3><p>lpush key values[value1 value2…]：在指定的key所关联的list的头部插入所有的values，如果该key不存在，该命令在插入的之前创建一个与该key关联的空链表，之后再向该链表的头部插入数据。插入成功，返回元素的个数。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/lpush%20key%20values%5Bvalue1%20value2%E2%80%A6%5D.png" alt="lpush key values"><br>rpush key values[value1、value2…]：在该list的尾部添加元素。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/rpush%20key%20values%5Bvalue1%E3%80%81value2%E2%80%A6%5D.png" alt="rpush key values"></p>
<h3 id="4-2-2、查看列表"><a href="#4-2-2、查看列表" class="headerlink" title="4.2.2、查看列表"></a>4.2.2、查看列表</h3><p>lrange key start end：获取链表中从start到end的元素的值，start、end从0开始计数；也可为负数，若为-1则表示链表尾部的元素，-2则表示倒数第二个，依次类推…<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/lrange%20key%20start%20end1.png" alt="lrange key start end1"><br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/lrange%20key%20start%20end2.png" alt="lrange key start end2"></p>
<h3 id="4-2-3、两端弹出"><a href="#4-2-3、两端弹出" class="headerlink" title="4.2.3、两端弹出"></a>4.2.3、两端弹出</h3><p>lpop key：返回并弹出指定的key关联的链表中的第一个元素，即头部元素。如果该key不存在，返回nil；若key存在，则返回链表的头部元素。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/lpop%20key.png" alt="lpop key"><br>rpop key：从尾部弹出元素。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/rpop%20key.png" alt="rpop key"></p>
<h3 id="4-2-4、获取列表中元素的个数"><a href="#4-2-4、获取列表中元素的个数" class="headerlink" title="4.2.4、获取列表中元素的个数"></a>4.2.4、获取列表中元素的个数</h3><p>llen key：返回指定的key关联的链表中的元素的数量。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/llen%20key.png" alt="llen key"></p>
<h3 id="4-2-5、扩展命令"><a href="#4-2-5、扩展命令" class="headerlink" title="4.2.5、扩展命令"></a>4.2.5、扩展命令</h3><p>lpushx key value：仅当参数中指定的key存在时，向关联的list的头部插入value。如果不存在，将不进行插入<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/lpushx%20key%20value.png" alt="lpushx key value"><br>rpushx key value：在该list的尾部添加元素<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/rpushx%20key%20value.png" alt="rpushx key value"><br>lrem key count value：删除count个值为value的元素，如果count大于0，从头向尾遍历并删除count个值为value的元素，如果count小于0，则从尾向头遍历并删除。如果count等于0，则删除链表中所有等于value的元素。<br>0)初始化数据<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/lrem%20key%20count%20value.png" alt="lrem key count value"><br> 1) 从头删除，2个数字“3”<br>lrem mylist3 2 3<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/lrem%20mylist3%202%203.png" alt="lrem mylist3 2 3"><br>2) 从尾删除，2个数字“1”<br>lrem mylist3 -2 1<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/lrem%20mylist3%20-2%201.png" alt="lrem mylist3 -2 1"><br>3) 删除所有数字“2”<br>lrem mylist3 0 2<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/lrem%20mylist3%200%202.png" alt="lrem mylist3 0 2"><br>lset key index value：设置链表中的index的脚标的元素值，0代表链表的头元素，-1代表链表的尾元素。操作链表的脚标不存在则抛异常。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/lset%20key%20index%20value.png" alt="lset key index value"><br>linsert key before|after pivot value：在pivot元素前或者后插入value这个元素。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/linsert%20key%20before%7Cafter%20pivot%20value.png" alt="linsert key before|after pivot value"><br>rpoplpush resource destination：将链表中的尾部元素弹出并添加到头部。[循环操作]<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/rpoplpush%20resource%20destination.png" alt="rpoplpush resource destination"><br>1) 将mylist5右端弹出，压入到mylist6左边。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/mylist5.png" alt="mylist5"><br>2) 将mylist6右端数据弹出，压入到左端<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/mylist6.png" alt="mylist6"></p>
<h2 id="4-3、使用场景"><a href="#4-3、使用场景" class="headerlink" title="4.3、使用场景"></a>4.3、使用场景</h2><p>rpoplpush的使用场景：<br>Redis链表经常会被用于消息队列的服务，以完成多程序之间的消息交换。假设一个应用程序正在执行LPUSH操作向链表中添加新的元素，我们通常将这样的程序称之为”生产者(Producer)”，而另外一个应用程序正在执行RPOP操作从链表中取出元素，我们称这样的程序为”消费者(Consumer)”。如果此时，消费者程序在取出消息元素后立刻崩溃，由于该消息已经被取出且没有被正常处理，那么我们就可以认为该消息已经丢失，由此可能会导致业务数据丢失，或业务状态的不一致等现象的发生。然而通过使用RPOPLPUSH命令，消费者程序在从主消息队列中取出消息之后再将其插入到备份队列中，直到消费者程序完成正常的处理逻辑后再将该消息从备份队列中删除。同时我们还可以提供一个守护进程，当发现备份队列中的消息过期时，可以重新将其再放回到主消息队列中，以便其它的消费者程序继续处理。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/rpoplpush%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.png" alt="rpoplpush的使用场景"></p>
<h1 id="5、存储set"><a href="#5、存储set" class="headerlink" title="5、存储set"></a>5、存储set</h1><h2 id="5-1、概述"><a href="#5-1、概述" class="headerlink" title="5.1、概述"></a>5.1、概述</h2><pre><code>在Redis中，我们可以将Set类型看作为没有排序的字符集合，和List类型一样，我们也可以在该类型的数据值上执行添加、删除或判断某一元素是否存在等操作。需要说明的是，这些操作的时间复杂度为O(1)，即常量时间内完成次操作。Set可包含的最大元素数量是4294967295。
和List类型不同的是，Set集合中不允许出现重复的元素，这一点和C++标准库中的set容器是完全相同的。换句话说，如果多次添加相同元素，Set中将仅保留该元素的一份拷贝。和List类型相比，Set类型在功能上还存在着一个非常重要的特性，即在服务器端完成多个Sets之间的聚合计算操作，如unions、intersections和differences。由于这些操作均在服务端完成，因此效率极高，而且也节省了大量的网络IO开销。
</code></pre><h2 id="5-2、常用命令"><a href="#5-2、常用命令" class="headerlink" title="5.2、常用命令"></a>5.2、常用命令</h2><h3 id="5-2-1、添加-删除元素"><a href="#5-2-1、添加-删除元素" class="headerlink" title="5.2.1、添加/删除元素"></a>5.2.1、添加/删除元素</h3><p>sadd key values[value1、value2…]：向set中添加数据，如果该key的值已有则不会重复添加<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/sadd%20key%20values.png" alt="sadd key values"><br>srem key members[member1、member2…]：删除set中指定的成员<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/srem%20key%20members.png" alt="srem key members"></p>
<h3 id="5-2-2、获得集合中的元素"><a href="#5-2-2、获得集合中的元素" class="headerlink" title="5.2.2、获得集合中的元素"></a>5.2.2、获得集合中的元素</h3><p>smembers key：获取set中所有的成员<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/smembers%20key.png" alt="smembers key"><br>sismember key member：判断参数中指定的成员是否在该set中，1表示存在，0表示不存在或者该key本身就不存在。（无论集合中有多少元素都可以极速的返回结果）<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/sismember%20key%20member.png" alt="sismember key member"></p>
<h3 id="5-2-3、集合的差集运算-A-B"><a href="#5-2-3、集合的差集运算-A-B" class="headerlink" title="5.2.3、集合的差集运算 A-B"></a>5.2.3、集合的差集运算 A-B</h3><p>sdiff key1 key2…：返回key1与key2中相差的成员，而且与key的顺序有关。即返回差集。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/sdiff%20key1%20key2_1.png" alt="sdiff key1 key2_1">（属于A并且不属于B的元素构成的集合）<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/sdiff%20key1%20key2_2.png" alt="sdiff key1 key2_2"></p>
<h3 id="5-2-4、集合的交集运算-A-∩-B"><a href="#5-2-4、集合的交集运算-A-∩-B" class="headerlink" title="5.2.4、集合的交集运算 A ∩ B"></a>5.2.4、集合的交集运算 A ∩ B</h3><p>sinter key1 key2 key3…：返回交集。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/sinter%20key1%20key2%20key3.png" alt="sinter key1 key2 key3">（属于A且属于B的元素构成的集合）<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image67.png" alt="image67"></p>
<h3 id="5-2-5、集合的并集运算-A-∪-B"><a href="#5-2-5、集合的并集运算-A-∪-B" class="headerlink" title="5.2.5、集合的并集运算 A ∪ B"></a>5.2.5、集合的并集运算 A ∪ B</h3><p>sunion key1 key2 key3…：返回并集<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/sunion%20key1%20key2%20key3_1.png" alt="sunion key1 key2 key3_1">（属于A或者属于B的元素构成的集合）<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/sunion%20key1%20key2%20key3_2.png" alt="sunion key1 key2 key3_2"></p>
<h3 id="5-2-6、扩展命令"><a href="#5-2-6、扩展命令" class="headerlink" title="5.2.6、扩展命令"></a>5.2.6、扩展命令</h3><p>scard key：获取set中成员的数量<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/scard%20key.png" alt="scard key"><br>srandmember key：随机返回set中的一个成员<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/srandmember%20key.png" alt="srandmember key"><br>sdiffstore destination key1 key2…：将key1、key2相差的成员存储在destination上<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/sdiffstore%20destination%20key1%20key2.png" alt="sdiffstore destination key1 key2"><br>sinterstore destination key[key…]：将返回的交集存储在destination上<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/sinterstore%20destination%20key.png" alt="sinterstore destination key"><br>sunionstore destination key[key…]：将返回的并集存储在destination上<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/sunionstore%20destination%20key.png" alt="sunionstore destination key"></p>
<h2 id="5-3、使用场景"><a href="#5-3、使用场景" class="headerlink" title="5.3、使用场景"></a>5.3、使用场景</h2><p>  1、可以使用Redis的Set数据类型跟踪一些唯一性数据，比如访问某一博客的唯一IP地址信息。对于此场景，我们仅需在每次访问该博客时将访问者的IP存入Redis中，Set数据类型会自动保证IP地址的唯一性。<br>  2、充分利用Set类型的服务端聚合操作方便、高效的特性，可以用于维护数据对象之间的关联关系。比如所有购买某一电子设备的客户ID被存储在一个指定的Set中，而购买另外一种电子产品的客户ID被存储在另外一个Set中，如果此时我们想获取有哪些客户同时购买了这两种商品时，Set的intersections命令就可以充分发挥它的方便和效率的优势了。</p>
<h1 id="6、存储sortedset"><a href="#6、存储sortedset" class="headerlink" title="6、存储sortedset"></a>6、存储sortedset</h1><h2 id="6-1、概述"><a href="#6-1、概述" class="headerlink" title="6.1、概述"></a>6.1、概述</h2><p>  Sorted-Set和Set类型极为相似，它们都是字符串的集合，都不允许重复的成员出现在一个Set中。它们之间的主要差别是Sorted-Set中的每一个成员都会有一个分数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。然而需要额外指出的是，尽管Sorted-Set中的成员必须是唯一的，但是分数(score)却是可以重复的。<br>  在Sorted-Set中添加、删除或更新一个成员都是非常快速的操作，其时间复杂度为集合中成员数量的对数。由于Sorted-Set中的成员在集合中的位置是有序的，因此，即便是访问位于集合中部的成员也仍然是非常高效的。事实上，Redis所具有的这一特征在很多其它类型的数据库中是很难实现的，换句话说，在该点上要想达到和Redis同样的高效，在其它数据库中进行建模是非常困难的。<br>    例如：游戏排名、微博热点话题等使用场景。</p>
<h2 id="6-2、常用命令"><a href="#6-2、常用命令" class="headerlink" title="6.2、常用命令"></a>6.2、常用命令</h2><h3 id="6-2-1、添加元素"><a href="#6-2-1、添加元素" class="headerlink" title="6.2.1、添加元素"></a>6.2.1、添加元素</h3><p>zadd key score member score2 member2 … ：将所有成员以及该成员的分数存放到sorted-set中。如果该元素已经存在则会用新的分数替换原有的分数。返回值是新加入到集合中的元素个数，不包含之前已经存在的元素<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image75.png" alt="image75"><br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image76.png" alt="image76"></p>
<h3 id="6-2-2、获得元素"><a href="#6-2-2、获得元素" class="headerlink" title="6.2.2、获得元素"></a>6.2.2、获得元素</h3><p>zscore key member：返回指定成员的分数<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image77.png" alt="image77"><br>zcard key：获取集合中的成员数量<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image78.png" alt="image78"></p>
<h3 id="6-2-3、删除元素"><a href="#6-2-3、删除元素" class="headerlink" title="6.2.3、删除元素"></a>6.2.3、删除元素</h3><p>zrem key member[member…]：移除集合中指定的成员，可以指定多个成员。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image79.png" alt="image79"></p>
<h3 id="6-2-4、范围查询"><a href="#6-2-4、范围查询" class="headerlink" title="6.2.4、范围查询"></a>6.2.4、范围查询</h3><p>zrange key start end [withscores]：获取集合中脚标为start-end的成员，[withscores]参数表明返回的成员包含其分数<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image80.png" alt="image80"><br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image81.png" alt="image81"><br>zrevrange key start stop [withscores]：照元素分数从大到小的顺序返回索引从start到stop之间的所有元素（包含两端的元素）<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image82.png" alt="image82"><br>zremrangebyrank key start stop: 按照排名范围删除元素<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image83.png" alt="image83"><br>zremrangebyscore key min max：按照分数范围删除元素<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image84.png" alt="image84"></p>
<h3 id="6-2-5、扩展命令"><a href="#6-2-5、扩展命令" class="headerlink" title="6.2.5、扩展命令"></a>6.2.5、扩展命令</h3><p>zrangebyscore key min max [withscores] [limit offset count]：返回分数在[min,max]的成员并按照分数从低到高排序。[withscores]：显示分数；[limit offset count]：offset，表明从脚标为offset的元素开始并返回count个成员。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image85.png" alt="image85"><br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image86.png" alt="image86"><br>zincrby key increment member：设置指定成员的增加的分数。返回值是更改后的分数。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image87.png" alt="image87"><br>zcount key min max：获取分数在[min,max]之间的成员<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image88.png" alt="image88"><br>zrank key member：返回成员在集合中的排名。（从小到大）<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image89.png" alt="image89"><br>zrevrank key member：返回成员在集合中的排名。（从大到小）<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image90.png" alt="image90"></p>
<h2 id="6-3、使用场景"><a href="#6-3、使用场景" class="headerlink" title="6.3、使用场景"></a>6.3、使用场景</h2><p>  1、可以用于一个大型在线游戏的积分排行榜。每当玩家的分数发生变化时，可以执行ZADD命令更新玩家的分数，此后再通过ZRANGE命令获取积分TOPTEN的用户信息。当然我们也可以利用ZRANK命令通过username来获取玩家的排行信息。最后我们将组合使用ZRANGE和ZRANK命令快速的获取和某个玩家积分相近的其他用户的信息。<br>  2、Sorted-Set类型还可用于构建索引数据。</p>
<h1 id="7、keys的通用操作"><a href="#7、keys的通用操作" class="headerlink" title="7、keys的通用操作"></a>7、keys的通用操作</h1><p>keys pattern：获取所有与pattern匹配的key，返回所有与该key匹配的keys。*表示任意一个或多个字符，?表示任意一个字符<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image91.png" alt="image91"><br>del key1 key2…：删除指定的key<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image92.png" alt="image92"><br>exists key：判断该key是否存在，1代表存在，0代表不存在<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image93.png" alt="image93"><br>rename key newkey：为当前的key重命名<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image94.png" alt="image94"><br>expire key ：设置过期时间，单位：秒<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image95.png" alt="image95"><br>ttl key：获取该key所剩的超时时间，如果没有设置超时，返回-1。如果返回-2表示超时不存在。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image96.png" alt="image96"><br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image97.png" alt="image97"><br>type key：获取指定key的类型。该命令将以字符串的格式返回。    返回的字符串为string、list、set、hash和zset，如果key不存在返回none。<br><img src="http://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/no-sql/redis%E4%BD%BF%E7%94%A8/image98.png" alt="image98"></p>
 

	    
</div>

<div class="center">
			

				<span class="post-meta">		
				<span class="iconfont icon-category"></span>
				<a class="category-link" href="/categories/redis/">redis</a>
				</span>
		
			

		
				
				<span class="post-meta">
				<span class="iconfont icon-tag"></span>
				<a class="tag-link" href="/tags/redis/">redis</a> <a class="tag-link" href="/tags/命令/">命令</a>
				</span>			
			


		

		<span class="post-words"><span class="iconfont icon-words"></span>
		6313
		</span>		
</div>		

		
    <a class="article-readmore" href="/2017/11/05/Redis使用/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2017/11/05/String、StringBuffer与StringBuilder的区别/">String、StringBuffer与StringBuilder的区别</a>  
	       
		 

		 <time>2017-11-05 </time>    
	</div>


    <div class="article-excerpt">	
	
  	

	  

	  	<ol>
<li>首先说运行速度，或者说是执行速度，<strong>在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String</strong></li>
</ol>
<p>　　<strong>String最慢的原因：</strong></p>
<p>　　<strong>String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。</strong>以下面一段代码为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 String str=&quot;abc&quot;;</span><br><span class="line">2 System.out.println(str);</span><br><span class="line">3 str=str+&quot;de&quot;;</span><br><span class="line">4 System.out.println(str);</span><br></pre></td></tr></table></figure>
<p>　　如果运行这段代码会发现先输出“abc”，然后又输出“abcde”，好像是str这个对象被更改了，其实，这只是一种假象罢了，JVM对于这几行代码是这样处理的，首先创建一个String对象str，并把“abc”赋值给str，然后在第三行中，其实JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了，所以，str实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了。所以，Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。</p>
<p>　　而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。</p>
<p>　　另外，有时候我们会这样对字符串进行赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 String str=&quot;abc&quot;+&quot;de&quot;;</span><br><span class="line">2 StringBuilder stringBuilder=new StringBuilder().append(&quot;abc&quot;).append(&quot;de&quot;);</span><br><span class="line">3 System.out.println(str);</span><br><span class="line">4 System.out.println(stringBuilder.toString());</span><br></pre></td></tr></table></figure>
<p>　　这样输出结果也是“abcde”和“abcde”，但是String的速度却比StringBuilder的反应速度要快很多，这是因为第1行中的操作和</p>
<p>　　String str=”abcde”;</p>
<p>　　是完全一样的，所以会很快，而如果写成下面这种形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 String str1=&quot;abc&quot;;</span><br><span class="line">2 String str2=&quot;de&quot;;</span><br><span class="line">3 String str=str1+str2;</span><br></pre></td></tr></table></figure>
<p>　　那么JVM就会像上面说的那样，不断的创建、回收对象来进行这个操作了。速度就会很慢。</p>
<ol>
<li>再来说线程安全</li>
</ol>
<p>　　<strong>在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的</strong></p>
<p>　　如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。</p>
<ol>
<li>总结一下<br><strong>String：适用于少量的字符串操作的情况</strong></li>
</ol>
<p>　　<strong>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况</strong></p>
<p>　　<strong>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</strong></p>
 

	    
</div>

<div class="center">
			

				<span class="post-meta">		
				<span class="iconfont icon-category"></span>
				<a class="category-link" href="/categories/java/">java</a>
				</span>
		
			

		
				
				<span class="post-meta">
				<span class="iconfont icon-tag"></span>
				<a class="tag-link" href="/tags/java/">java</a> <a class="tag-link" href="/tags/复习/">复习</a>
				</span>			
			


		

		<span class="post-words"><span class="iconfont icon-words"></span>
		1543
		</span>		
</div>		

		
    <a class="article-readmore" href="/2017/11/05/String、StringBuffer与StringBuilder的区别/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2017/04/12/安装 Ruby, Rails 运行环境/">安装 Ruby, Rails 运行环境</a>  
	       
		 

		 <time>2017-04-12 </time>    
	</div>


    <div class="article-excerpt">	
	
  	

	  

	  	<h2 id="步骤1-－-安装-RVM"><a href="#步骤1-－-安装-RVM" class="headerlink" title="步骤1 － 安装 RVM"></a>步骤1 － 安装 RVM</h2><p>直接以如下命令行安装可能会不成功，因为rvm.io站点有时会被墙：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.rvm.io | bash -s stable</span><br><span class="line">#或者</span><br><span class="line">curl -L https://rvm.io | bash -s stable</span><br></pre></td></tr></table></figure>
<p>没关系，我们可以直接从git仓库里下载并安装RVM，首先本地新建文件夹rvm:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir rvm</span><br><span class="line">cd rvm</span><br></pre></td></tr></table></figure>
<p>然后依次执行如下命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Install mpapis public key (might need `gpg2` and or `sudo`)</span><br><span class="line">gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3</span><br><span class="line"></span><br><span class="line"># Download the installer</span><br><span class="line">curl -O https://raw.githubusercontent.com/rvm/rvm/master/binscripts/rvm-installer</span><br><span class="line">curl -O https://raw.githubusercontent.com/rvm/rvm/master/binscripts/rvm-installer.asc</span><br><span class="line"></span><br><span class="line"># Verify the installer signature (might need `gpg2`), and if it validates...</span><br><span class="line">gpg --verify rvm-installer.asc &amp;&amp;</span><br><span class="line"></span><br><span class="line"># Run the installer</span><br><span class="line">bash rvm-installer stable</span><br></pre></td></tr></table></figure>
<p>如果gpg –keyserver命令失败，用如下命令代替:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://rvm.io/mpapis.asc | gpg --import -</span><br></pre></td></tr></table></figure>
<p>如果不出什么错误，RVM已经安装到系统上了，可以使用了。然后，载入 RVM 环境（新开 Termal 就不用这么做了，会自动重新载入的）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source ~/.rvm/scripts/rvm</span><br></pre></td></tr></table></figure>
<p>修改 RVM 下载 Ruby 的源，到 Ruby China 的镜像:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;ruby_url=https://cache.ruby-china.org/pub/ruby&quot; &gt; ~/.rvm/user/db</span><br></pre></td></tr></table></figure>
<p>检查一下是否安装正确</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rvm -v</span><br><span class="line">rvm 1.22.17 (stable) by Wayne E. Seguin &lt;wayneeseguin@gmail.com&gt;, Michal Papis &lt;mpapis@gmail.com&gt; [https://rvm.io/]</span><br></pre></td></tr></table></figure>
<h2 id="步骤2-－-用-RVM-安装-Ruby-环境"><a href="#步骤2-－-用-RVM-安装-Ruby-环境" class="headerlink" title="步骤2 － 用 RVM 安装 Ruby 环境"></a>步骤2 － 用 RVM 安装 Ruby 环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rvm requirements</span><br><span class="line">$ rvm install 2.3.0</span><br></pre></td></tr></table></figure>
<p>同样继续等待漫长的下载，编译过程，完成以后，Ruby, Ruby Gems 就安装好了。</p>
<h2 id="步骤3-－-设置-Ruby-版本"><a href="#步骤3-－-设置-Ruby-版本" class="headerlink" title="步骤3 － 设置 Ruby 版本"></a>步骤3 － 设置 Ruby 版本</h2><p>RVM 装好以后，需要执行下面的命令将指定版本的 Ruby 设置为系统默认版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm use 2.3.0 --default</span><br></pre></td></tr></table></figure>
<p>同样，也可以用其他版本号，前提是你有用 rvm install 安装过那个版本</p>
<p>这个时候你可以测试是否正确</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ruby -v</span><br><span class="line">ruby 2.3.0 ...</span><br><span class="line"></span><br><span class="line">$ gem -v</span><br><span class="line">2.1.6</span><br><span class="line"></span><br><span class="line">$ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/</span><br></pre></td></tr></table></figure>
<h3 id="安装-Bundler"><a href="#安装-Bundler" class="headerlink" title="安装 Bundler"></a>安装 Bundler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install bundler</span><br></pre></td></tr></table></figure>
<h2 id="步骤4-－-安装-Rails-环境"><a href="#步骤4-－-安装-Rails-环境" class="headerlink" title="步骤4 － 安装 Rails 环境"></a>步骤4 － 安装 Rails 环境</h2><p>上面 3 个步骤过后，Ruby 环境就安装好了，接下来安装 Rails</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install rails</span><br></pre></td></tr></table></figure>
<p>然后测试安装是否正确</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rails -v</span><br><span class="line">Rails 4.2.5</span><br></pre></td></tr></table></figure>
<p>转载：</p>
<p><a href="https://yq.aliyun.com/articles/24866" target="_blank" rel="noopener">inux下安装ruby版本管理器RVM</a></p>
<p><a href="https://ruby-china.org/wiki/install_ruby_guide" target="_blank" rel="noopener">如何快速正确的安装 Ruby, Rails 运行环境</a></p>
 

	    
</div>

<div class="center">
			

				<span class="post-meta">		
				<span class="iconfont icon-category"></span>
				<a class="category-link" href="/categories/redis/">redis</a>
				</span>
		
			

		
				
				<span class="post-meta">
				<span class="iconfont icon-tag"></span>
				<a class="tag-link" href="/tags/redis/">redis</a>
				</span>			
			


		

		<span class="post-words"><span class="iconfont icon-words"></span>
		1582
		</span>		
</div>		

		
    <a class="article-readmore" href="/2017/04/12/安装 Ruby, Rails 运行环境/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2017/01/11/jvm虚拟机/">jvm虚拟机</a>  
	       
		 

		 <time>2017-01-11 </time>    
	</div>


    <div class="article-excerpt">	
	
  	

	  

	  	<h1 id="jvm内存概况"><a href="#jvm内存概况" class="headerlink" title="jvm内存概况"></a>jvm内存概况</h1><p>JVM内存包含大致如下：<br><img src="http://i2.51cto.com/images/blog/201802/02/f157091262e858690f68ad993b01e44c.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="jvm内存详解-----详解------详解"></p>
<hr>
<p>Java内存≈Heap(堆内存)+PermGen(方法区)+Thrend(栈)<br>Heap（堆内存）=Young（年轻代）+Old（老年代）</p>
<p>Young（年轻代）=EdenSpace+From Survivor+To Survivor</p>
<h1 id="设置jvm内存关键字"><a href="#设置jvm内存关键字" class="headerlink" title="设置jvm内存关键字"></a>设置jvm内存关键字</h1><table>
<thead>
<tr>
<th>关键字</th>
<th>解释</th>
<th>关键字</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>-Xms</td>
<td>堆内存最小空间</td>
<td>-Xmx</td>
<td>堆内存最大空间</td>
</tr>
<tr>
<td>-XX:NewSize</td>
<td>新生代最小空间</td>
<td>-XX:MaxNewSize</td>
<td>新生代最大空间</td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>永久带最小空间(方法区)</td>
<td>–XX:MaxPermSize</td>
<td>永久带最大空间（方法区）</td>
</tr>
<tr>
<td>-Xss</td>
<td>设置每个线程栈的大小</td>
<td>-XX:SurvivorRatio</td>
<td>Eden和其中一个Survivor的比值</td>
</tr>
<tr>
<td>-XX:InitialTenuringThreshol</td>
<td>晋升到老年代的对象年龄的最小值</td>
<td>-XX:MaxTenuringThreshold</td>
<td>晋升到老年代的对象年龄的最大值</td>
</tr>
</tbody>
</table>
<p>没有直接设置老年代大小的参数，但是可以通过设置堆内存和新生代内存大大小来计算老年代的大小。jvm中新生代和From survivor和To survivor的比例是8：1：1所以<br>老年代内存大小=堆内存-新生代内存大小-（新生代 x 1/5）<br>从更高的维度来看内存之间的关系会得到如下结论，方法去和堆内存都是所有线程共享的内存区域。而java栈是线程私有的内存空间。</p>
<h1 id="Java堆内存（Heap）解释"><a href="#Java堆内存（Heap）解释" class="headerlink" title="Java堆内存（Heap）解释"></a>Java堆内存（Heap）解释</h1><p>对于大多数应用程序来说，Java堆是Java虚拟机所管理的虚拟内存中最大的一块内存，Java堆是被所有线程共享的一块内存区域。在虚拟机启动时创建，此内存唯一目的是存放对象实例。<br>Java对内存垃圾收集器（GC）的主要工作对象。<br>jvm堆内存的最大空间和最小空间的微妙之处</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-Xms指定堆内存初始化分配的空间，如果不指定默认是物理内存的1/64；</span><br><span class="line">-Xmx指定堆内存的最大分配空间，如果不指定默认是无内存的1/4；</span><br><span class="line">默认情况下堆内存可用空间小于40%时候，JVM会增加堆内存到最大内存或物理内存的1/4；</span><br><span class="line">默认情况下堆内存可用空间大于70%时候，JVM会减小堆内存到最小内存或物理内存的1/64;</span><br><span class="line">因此服务器设置的初始化内存和最大内存值为一样，是为了避免GC发生后不断调整堆的大小。建议堆的最大值是可用内存的80%</span><br></pre></td></tr></table></figure>
<p>Java Heap中包括年轻代和老年代，其实还包括一个Permanent。<br>年轻代保存实例化的对象，当该区被填满时，GC会将对象移动到old区。Permanent区负责保存反射对象。</p>
<h2 id="Eden、From-survivor、To-survivor"><a href="#Eden、From-survivor、To-survivor" class="headerlink" title="Eden、From survivor、To survivor"></a>Eden、From survivor、To survivor</h2><p>介绍下堆内存中的Eden、From survivor、To survivor直接微妙的联系</p>
<ol>
<li>我们先来屡屡，为什么需要把堆分代？不分代不能完成他所做的事情么？其实不分代完全可以，分代的唯一理由就是优化GC性能。你先想想，如果没有分代，那我们所有的对象都在一块，GC的时候我们要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而我们的很多对象都是朝生夕死的，如果分代的话，我们把新创建的对象放到某一地方，当GC的时候先把这块存“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</li>
<li>HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1,为啥默认会是这个比例，接下来我们会聊到。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。</li>
</ol>
<p>因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p>
<p>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。<img src="http://i2.51cto.com/images/blog/201802/02/de44f64c1c09f0c69af30571cf645626.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="jvm内存详解-----详解------详解"></p>
<h2 id="一个对象的这一辈子"><a href="#一个对象的这一辈子" class="headerlink" title="一个对象的这一辈子"></a>一个对象的这一辈子</h2><p>我是一个普通的Java对象，我出生在Eden区，在Eden区我还看到和我长的很像的小兄弟，我们在Eden区中玩了挺长时间。有一天Eden区中的人实在是太多了，我就被迫去了Survivor区的“From”区，自从去了Survivor区，我就开始漂了，有时候在Survivor的“From”区，有时候在Survivor的“To”区，居无定所。直到我18岁的时候，爸爸说我成人了，该去社会上闯闯了。于是我就去了年老代那边，年老代里，人很多，并且年龄都挺大的，我在这里也认识了很多人。在年老代里，我生活了20年(每次GC加一岁)，然后被回收。</p>
<h1 id="方法区（PermGen）解释"><a href="#方法区（PermGen）解释" class="headerlink" title="方法区（PermGen）解释"></a>方法区（PermGen）解释</h1><p>各个线程共享的内存区域，用于存储以备虚拟机加载的类信息，常量、静态变量、即时编译器、编译后的代码等数据。又名Non-Heap、永久代。并不是说数据进入永久代就永久存在了。<br>这个区域的回收主要是针对常量池的回收和对类型的写在，一般来说这个区域的回收成绩比较难以令人满意，尤其是类型的卸载条件相当苛刻。<br>jvm非堆内存的最大空间和最小空间的微妙感觉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法区用于存放Class和Meta信息，Class在被Load的时候被放入该区域。它和存放类实例的Heap区域不同，GC不会再主程序运行期间对方法去进行GC操作。</span><br><span class="line">-XX：PermSize设置非堆内存初始值，默认是物理内存的1/64;</span><br><span class="line">-XX:MaxPermSize设置非堆内存最大值，默认是物理内存的1/4;</span><br><span class="line">因为对PermGen区的GC回收条件比较苛刻，所以如果你的APP一次性会LOAD很多Class的话，可能会出现PermGen space错误的。</span><br></pre></td></tr></table></figure>
<h1 id="GC线程"><a href="#GC线程" class="headerlink" title="GC线程"></a>GC线程</h1><p>Jvm有2个GC线程，第一个线程负责回收Heap的Young区。第二个线程在Heap不足时，遍历Heap，使Young区升级为Older区，Older区的大小等于堆内存大小减去新生代大小。不能将堆内存最小值设置过大，因为第二个线程被迫运行会降低jvm的性能。<br>频繁发生GC的原因有如下几个原因：</p>
<ul>
<li><p>程序内调用了System.gc()或Runtime.gc()</p>
</li>
<li><p>一些中间件调用自己的GC方法，此时需要设置参数禁止这些GC。</p>
</li>
<li><p>Java的Heap太小，一般默认的Heap值都很小。</p>
</li>
<li><p>频繁实例化对象，Release对象 此时尽量保存并重用对象，例如使用StringBuffer()和String().<br>如果你发现每次GC后，Heap的剩余空间会是总空间的50%，这表示你的Heap处于健康状态，许多Server端的Java程序每次GC后最好能有65%的剩余空间。<br>——–以下是网友经验之谈——-<br>1.Server端Jvm最好将-Xms和-Xmx设为相同值。为了优化GC，最好让-Xmn（新生代）与等于堆最大内存的1/3。<br>2.一个GUI程序最好每10秒到20秒运行一次GC，每次在半秒之内完成。注意</p>
<p>1.增加Heap的大小虽然会降低GC频率，但也增加了每次GC的时间。并且GC运行时，所有的用户线程将暂停，也就是GC期间，Java应用程序不做任何工作。<br>2.Heap大小并不决定进程的内存使用量。进程的内存使用量要大于-Xmx定义的值，因为Java为其他任务分配内存，例如每个线程的Stack等</p>
<p> 内存溢出</p>
<p>弄java得程序员肯定对内存溢出这个不陌生吧，对我来说确实是一个挺无奈的关键字，之前出现这个问题，直接给jvm加内存，可是治标不治本，因为不知道原理，通过近期的研究算是吧jvm的基本机制弄得明白了，来看看jvm内存溢出的几种情况。</p>
<h2 id="OutOfMemoryError：Java-heap-space"><a href="#OutOfMemoryError：Java-heap-space" class="headerlink" title="OutOfMemoryError：Java heap space"></a>OutOfMemoryError：Java heap space</h2><p>这是jvm的堆内存溢出，在jvm中98%的内存都在等待GC回收，且Heap Size不足2%的可用空间时，将抛出此错误，对应的解决办法增加-xmx和-xms的大小。</p>
<ul>
<li><h2 id="OutOfMemoryError：PermGen-Space"><a href="#OutOfMemoryError：PermGen-Space" class="headerlink" title="OutOfMemoryError：PermGen Space"></a>OutOfMemoryError：PermGen Space</h2><p>这是jvm的非堆内存溢出，可能情况有如下几种</p>
</li>
<li><p>如果web app下用大量的第三方jar，其总大小超过非堆内存的最大值，会抛出此异常</p>
</li>
<li><p>项目拥有太多的class文件，恰好maxPermSize设置的小于class总大小，会抛出此异常</p>
</li>
<li><p>tomcat部署的时候，不会清理前面加载的环境，只会将context更改为新部署的代码，所以非堆内存越来越多OutOfMemoryError：unable to new native thread：</p>
<p>这是jvm无法创建新线程，这个错误比较少见，也比较奇怪。主要是jvm与内存的比例有关。这种怪事因为jvm已经被系统分配了大量的内存。并且它至少占用可用内存的一半空间。可以尝试重启tomcat或加大非堆内存对应的值。</p>
</li>
</ul>
</li>
</ul>
<p>转载：<a href="http://blog.51cto.com/xinsir/2068032" target="_blank" rel="noopener">http://blog.51cto.com/xinsir/2068032</a></p>
 

	    
</div>

<div class="center">
			

				<span class="post-meta">		
				<span class="iconfont icon-category"></span>
				<a class="category-link" href="/categories/java/">java</a>
				</span>
		
			

		
				
				<span class="post-meta">
				<span class="iconfont icon-tag"></span>
				<a class="tag-link" href="/tags/java/">java</a> <a class="tag-link" href="/tags/复习/">复习</a>
				</span>			
			


		

		<span class="post-words"><span class="iconfont icon-words"></span>
		4028
		</span>		
</div>		

		
    <a class="article-readmore" href="/2017/01/11/jvm虚拟机/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2017/01/11/j2ee详解/">j2ee详解</a>  
	       
		 

		 <time>2017-01-11 </time>    
	</div>


    <div class="article-excerpt">	
	
  	

	  

	  	<ol>
<li><p>九种基本数据类型的大小，以及他们的封装类。</p>
<p>| 基本类型 | 大小(字节) | 默认值       | 封装类  |<br>| ——– | ———- | ———— | ——- |<br>| byte     | 1          | (byte)0      | Byte    |<br>| short    | 2          | (short)0     | Short   |<br>| int      | 4          | 0            | Integer |<br>| long     | 8          | 0L           | Long    |<br>| float    | 4          | 0.0f         | Float   |<br>| double   | 8          | 0.0d         | Double  |<br>| boolean  | -          | false        | Boolean |<br>| char     | 2          | \u0000(null) |         |<br>| void     | -          | -            | Void    |</p>
</li>
</ol>
<ol>
<li><p>Switch能否用string做参数？</p>
<p>在jdk 7 之前，switch 只能支持 byte、short、char、int 这几个基本数据类型和其对应的封装类型。switch后面的括号里面只能放int类型的值，但由于byte，short，char类型，它们会 自动 转换为int类型（精精度小的向大的转化），所以它们也支持。</p>
<p>为什么jdk1.7后又可以用string类型作为switch参数呢？</p>
<p>其实，jdk1.7并没有新的指令来处理switch string，而是通过调用switch中string.hashCode,将string转换为int从而进行判断。</p>
</li>
</ol>
<ol>
<li><p>equals与==的区别。</p>
<p><strong>= 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。</strong></p>
<p>1、比较的是操作符两端的操作数是否是同一个对象。<br>2、两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。<br>3、比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如：<br>int a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。</p>
<h2 id="equals："><a href="#equals：" class="headerlink" title="equals："></a><strong>equals：</strong></h2><p>　　<strong>equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。</strong></p>
<p>　　String s=”abce”是一种非常特殊的形式,和new 有本质的区别。它是java中唯一不需要new 就可以产生对象的途径。以String s=”abce”;形式赋值在java中叫直接量,它是在常量池中而不是象new一样放在压缩堆中。这种形式的字符串，在JVM内部发生字符串拘留，即当声明这样的一个字符串后，JVM会在常量池中先查找有有没有一个值为”abcd”的对象,如果有,就会把它赋给当前引用.即原来那个引用和现在这个引用指点向了同一对象,如果没有,则在常量池中新创建一个”abcd”,下一次如果有String s1 = “abcd”;又会将s1指向”abcd”这个对象,即以这形式声明的字符串,只要值相等,任何多个引用都指向同一对象.<br>　　而String s = new String(“abcd”);和其它任何对象一样.每调用一次就产生一个对象，只要它们调用。</p>
<p>　　也可以这么理解: String str = “hello”; 先在内存中找是不是有”hello”这个对象,如果有，就让str指向那个”hello”.如果内存里没有”hello”，就创建一个新的对象保存”hello”. String str=new String (“hello”) 就是不管内存里是不是已经有”hello”这个对象，都新建一个对象保存”hello”。</p>
</li>
<li><p>Object有哪些公用方法？</p>
<p>Object是所有类的父类，任何类都默认继承Object。</p>
<h4 id="clone"><a href="#clone" class="headerlink" title="clone"></a><strong>clone</strong></h4><p>保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常</p>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a><strong>equals</strong></h4><p>在Object中与==是一样的，子类一般需要重写该方法</p>
<h4 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a><strong>hashCode</strong></h4><p>该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到</p>
<h4 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a><strong>getClass</strong></h4><p>final方法，获得运行时类型</p>
<h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a><strong>wait</strong></h4><p>使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。<br>调用该方法后当前线程进入睡眠状态，直到以下事件发生：<br>\1. 其他线程调用了该对象的notify方法<br>\2. 其他线程调用了该对象的notifyAll方法<br>\3. 其他线程调用了interrupt中断该线程<br>\4. 时间间隔到了<br>此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常</p>
<h4 id="notify"><a href="#notify" class="headerlink" title="notify"></a><strong>notify</strong></h4><p>唤醒在该对象上等待的某个线程</p>
<h4 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll"></a><strong>notifyAll</strong></h4><p>唤醒在该对象上等待的所有线程</p>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a><strong>toString</strong></h4><p>转换成字符串，一般子类都有重写，否则打印句柄</p>
</li>
</ol>
<ol>
<li>Java的四种引用，强弱软虚，用到的场景。</li>
</ol>
<p>   我们知道java语言提供了4种引用类型：强引用、软引用(SoftReference)、弱引用（WeakReference）和幽灵引用（PhantomReference），与引用密切相关的，还有一个引用队列ReferenceQueue。引用和引用队列的关系，对于垃圾回收来说非常重要，学习垃圾回收机制，必须要先了解引用和引用队列的使用方法。本文主要参考网上的一些理论，同时配合自己的一些测试代码，更好的理解这些概念。这篇博客也解决了 <strong>System.gc()和-XX:+DisableExplicitGC启动参数，以及DirectByteBuffer的内存释放</strong> 中遗留的幽灵引用的问题。</p>
<p>   <strong>1、强引用</strong></p>
<p>   强引用不会被GC回收，并且在java.lang.ref里也没有实际的对应类型，平时工作接触的最多的就是强引用。<br>   　 Object obj = new Object();这里的obj引用便是一个强引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，<strong>垃圾回收器绝不会回收它</strong>。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<p>   <strong>2、软引用</strong></p>
<p>   如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果<strong>内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存</strong>。只 要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p>   /<em>* </em> 只有当内存不够的时候，才回收这类内存，因此在内存足够的时候，它们通常不被回收 <em> </em></p>
<p>   * 无论是否发送GC,执行结果都是: <em> java.lang.Object@f9f9d8 </em> null <em> java.lang.Object@f9f9d8 </em> null *</p>
<p>   * <em> 可以看到:只有发送了GC,将对于从内存中释放的时候,JVM才会将reference假如引用队列 </em>/ public static void soft() throws Exception { Object obj = new Object(); ReferenceQueue refQueue = new ReferenceQueue(); SoftReference softRef = new SoftReference(obj, refQueue); System.out.println(softRef.get()); // java.lang.Object@f9f9d8 System.out.println(refQueue.poll());// null // 清除强引用,触发GC obj = null; System.gc(); System.out.println(softRef.get()); Thread.sleep(200); System.out.println(refQueue.poll()); }</p>
<p>   这里有几点需要说明：</p>
<p>   1、System.gc()告诉JVM这是一个执行GC的好时机，但具体执不执行由JVM决定（事实上这段代码一般都会执行GC)</p>
<p>   2、Thread.sleep(200); 这是因为从对象被回收到JVM将引用加入refQueue队列，需要一定的时间。而且poll并不是一个阻塞方法，如果没有数据会返回null，所以我们选择等待一段时间。</p>
<p>   <strong>3、弱引用</strong></p>
<p>   如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，<strong>一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存</strong>。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回 收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p>   /<em>* </em> 弱引用: 当发生GC的时候,Weak引用对象总是会内回收回收。因此Weak引用对象会更容易、更快被GC回收。 <em> Weak引用对象常常用于Map数据结构中，引用占用内存空间较大的对象 </em> *</p>
<p>   * 如果不发生垃圾回收： <em> java.lang.Object@f9f9d8 </em> null <em> java.lang.Object@f9f9d8 </em> null <em> </em> 如果发生垃圾回收: <em> java.lang.Object@f9f9d8 </em> null <em> null </em> java.lang.ref.WeakReference@422ede <em> </em></p>
<p>   */ public static void weak() throws Exception { Object obj = new Object(); ReferenceQueue refQueue = new ReferenceQueue(); WeakReference weakRef = new WeakReference(obj, refQueue); System.out.println(weakRef.get()); // java.lang.Object@f9f9d8 System.out.println(refQueue.poll());// null // 清除强引用,触发GC obj = null; System.gc(); System.out.println(weakRef.get()); // 这里特别注意:poll是非阻塞的,remove是阻塞的. // JVM将弱引用放入引用队列需要一定的时间,所以这里先睡眠一会儿 // System.out.println(refQueue.poll());// 这里有可能是null Thread.sleep(200); System.out.println(refQueue.poll()); // System.out.println(refQueue.poll());//这里一定是null,因为已经从队列中移除 // System.out.println(refQueue.remove()); }</p>
<p>   这里需要注意下：</p>
<p>   1、remove这是一个阻塞方法，类似于J.U.C并发包下的阻塞队列，如果没有队列没有数据，那么当前线程一直等待。<br>   2、如果队列有数据，那么remove和pool都会将第一个元素出队。</p>
<p>   <strong>4、幽灵引用(虚引用)</strong><br>   虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果<strong>发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列</strong>中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。由于Object.finalize()方法的不安全性、低效性，常常使用虚引用完成对象回收前的资源释放工作。参考我的另一篇博客：<strong>解释为什么finalize是不安全的，不建议使用</strong> </p>
<p>   /<em>* </em> 当GC一但发现了虚引用对象，将会将PhantomReference对象插入ReferenceQueue队列. <em> 而此时PhantomReference所指向的对象并没有被GC回收，而是要等到ReferenceQueue被你真正的处理后才会被回收. </em> *</p>
<p>   这里特别需要注意：当JVM将虚引用插入到引用队列的时候，虚引用执行的对象内存还是存在的。但是PhantomReference并没有暴露API返回对象。所以如果我想做清理工作，需要继承PhantomReference类，以便访问它指向的对象。如NIO直接内存的自动回收，就使用到了sun.misc.Cleaner</p>
<ol>
<li><p>Hashcode的作用。</p>
<p><strong>Hash</strong></p>
<p>先用一张图看下什么是Hash</p>
<p><img src="http://images2015.cnblogs.com/blog/801753/201509/801753-20150927112453678-436094926.jpg" alt="img"></p>
<p>Hash是散列的意思，就是把任意长度的输入，通过散列算法变换成固定长度的输出，该输出就是散列值。关于散列值，有以下几个关键结论：</p>
<p>1、如果散列表中存在和散列原始输入K相等的记录，那么K必定在f(K)的存储位置上</p>
<p>2、<strong>不同关键字经过散列算法变换后可能得到同一个散列地址，这种现象称为碰撞</strong></p>
<p>3、<strong>如果两个Hash值不同（前提是同一Hash算法），那么这两个Hash值对应的原始输入必定不同</strong></p>
<p><strong>HashCode</strong></p>
<p>然后讲下什么是HashCode，总结几个关键点：</p>
<p>1、HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的</p>
<p>2、如果两个对象equals相等，那么这两个对象的HashCode一定也相同</p>
<p>3、如果对象的equals方法被重写，那么对象的HashCode方法也尽量重写</p>
<p>4、如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置</p>
<p><strong>HashCode有什么用</strong></p>
<p>回到最关键的问题，HashCode有什么用？不妨举个例子：</p>
<p>1、假设内存中有0 1 2 3 4 5 6 7 8这8个位置，如果我有个字段叫做ID，那么我要把这个字段存放在以上8个位置之一，如果不用HashCode而任意存放，那么当查找时就需要到8个位置中去挨个查找</p>
<p>2、使用HashCode则效率会快很多，把ID的HashCode%8，然后把ID存放在取得余数的那个位置，然后每次查找该类的时候都可以通过ID的HashCode%8求余数直接找到存放的位置了</p>
<p>3、如果ID的HashCode%8算出来的位置上本身已经有数据了怎么办？这就取决于算法的实现了，比如ThreadLocal中的做法就是从算出来的位置向后查找第一个为空的位置，放置数据；HashMap的做法就是通过链式结构连起来。反正，只要保证放的时候和取的时候的算法一致就行了。</p>
<p>4、如果ID的HashCode%8相等怎么办（这种对应的是第三点说的链式结构的场景）？这时候就需要定义equals了。先通过HashCode%8来判断类在哪一个位置，再通过equals来在这个位置上寻找需要的类。对比两个类的时候也差不多，先通过HashCode比较，假如HashCode相等再判断equals。<strong>如果两个类的HashCode都不相同，那么这两个类必定是不同的</strong>。</p>
<p>举个实际的例子Set。我们知道Set里面的元素是不可以重复的，那么如何做到？Set是根据equals()方法来判断两个元素是否相等的。比方说Set里面已经有1000个元素了，那么第1001个元素进来的时候，最多可能调用1000次equals方法，如果equals方法写得复杂，对比的东西特别多，那么效率会大大降低。使用HashCode就不一样了，比方说HashSet，底层是基于HashMap实现的，先通过HashCode取一个模，这样一下子就固定到某个位置了，如果这个位置上没有元素，那么就可以肯定HashSet中必定没有和新添加的元素equals的元素，就可以直接存放了，都不需要比较；如果这个位置上有元素了，逐一比较，比较的时候先比较HashCode，HashCode都不同接下去都不用比了，肯定不一样，HashCode相等，再equals比较，没有相同的元素就存，有相同的元素就不存。如果原来的Set里面有相同的元素，只要HashCode的生成方式定义得好（不重复），不管Set里面原来有多少元素，只需要执行一次的equals就可以了。这样一来，实际调用equals方法的次数大大降低，提高了效率。</p>
</li>
</ol>
<ol>
<li><p>ArrayList、LinkedList、Vector的区别。</p>
<p>1.这三个类都实现了List接口（List接口继承了Collection接口），但是也有以下区别</p>
<p>ArrayList和Vector</p>
<p>1&gt;.他们都是有序集合，即存储在这两个集合中的元素的位置都是有顺序即连续的，相当于一种动态的数组，我们以后可以按位置索引号取出某个元素，，并且其中的数据是允许重复的。</p>
<p>2&gt;.简单的说是ArrayList 和Vector 的底层数据是数组的结构</p>
<p><strong>ArrayList**</strong>和<strong>**Vector、LinkList</strong></p>
<p>3&gt;.LinkList<strong>即存储在这两个集合中的元素的位置是不连续的，底层数据结构是列表结构</strong></p>
<p>4&gt;.ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，查询速度快，</p>
<p>但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢</p>
<p>5&gt;.LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入,修改，删除 速度较快.</p>
<p>6&gt;.Vector是同步处理,性能较低；ArrayList是使用异步处理，性能高。</p>
<p>7&gt;.Vector是线程安全的，ArrayList是非线程安全。<strong>LinkedList是非线程安全</strong></p>
<p><strong>8&gt;.</strong>一般情况都用ArrayList，ArrayList占据内存小</p>
<p>2.还有数据方面（<strong>但是很少用到</strong>）的区别：</p>
<p>1&gt;.ArrayList与Vector都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加ArrayList与Vector的存储空间(每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡);</p>
<p>2&gt;.Vector默认增长为原来两倍，而ArrayList的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的1.5倍）</p>
<p>3&gt;.ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法</p>
</li>
</ol>
<ol>
<li><p>String、StringBuffer与StringBuilder的区别。</p>
<ol>
<li>首先说运行速度，或者说是执行速度，<strong>在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String</strong></li>
</ol>
<p>　　<strong>String最慢的原因：</strong></p>
<p>　　<strong>String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。</strong>以下面一段代码为例：</p>
</li>
</ol>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 String str=&quot;abc&quot;;</span><br><span class="line">2 System.out.println(str);</span><br><span class="line">3 str=str+&quot;de&quot;;</span><br><span class="line">4 System.out.println(str);</span><br></pre></td></tr></table></figure>
<p>   　　如果运行这段代码会发现先输出“abc”，然后又输出“abcde”，好像是str这个对象被更改了，其实，这只是一种假象罢了，JVM对于这几行代码是这样处理的，首先创建一个String对象str，并把“abc”赋值给str，然后在第三行中，其实JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了，所以，str实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了。所以，Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。</p>
<p>   　　而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。</p>
<p>   　　另外，有时候我们会这样对字符串进行赋值</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 String str=&quot;abc&quot;+&quot;de&quot;;</span><br><span class="line">2 StringBuilder stringBuilder=new StringBuilder().append(&quot;abc&quot;).append(&quot;de&quot;);</span><br><span class="line">3 System.out.println(str);</span><br><span class="line">4 System.out.println(stringBuilder.toString());</span><br></pre></td></tr></table></figure>
<p>   　　这样输出结果也是“abcde”和“abcde”，但是String的速度却比StringBuilder的反应速度要快很多，这是因为第1行中的操作和</p>
<p>   　　String str=”abcde”;</p>
<p>   　　是完全一样的，所以会很快，而如果写成下面这种形式</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 String str1=&quot;abc&quot;;</span><br><span class="line">2 String str2=&quot;de&quot;;</span><br><span class="line">3 String str=str1+str2;</span><br></pre></td></tr></table></figure>
<p>   　　那么JVM就会像上面说的那样，不断的创建、回收对象来进行这个操作了。速度就会很慢。</p>
<p>   　　2. 再来说线程安全</p>
<p>   　　<strong>在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的</strong></p>
<p>   　　如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。</p>
<p>   　　3. 总结一下<br>   　　<strong>String：适用于少量的字符串操作的情况</strong></p>
<p>   　　<strong>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况</strong></p>
<p>   　　<strong>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</strong></p>
<ol>
<li><p>Map、Set、List、Queue、Stack的特点与用法。</p>
<ul>
<li>Map</li>
</ul>
<blockquote>
<p>键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。</p>
<p>某些映射实现可明确保证其顺序，如 TreeMap 类；另一些映射实现则不保证顺序，如 HashMap 类。</p>
<p>Map中元素，可以将key序列、value序列单独抽取出来。<br>使用keySet()抽取key序列，将map中的所有keys生成一个Set。<br>使用values()抽取value序列，将map中的所有values生成一个Collection。<br>为什么一个生成Set，一个生成Collection？那是因为，key总是独一无二的，value允许重复。</p>
</blockquote>
<ul>
<li>Set</li>
</ul>
<blockquote>
<p>一个不包含重复元素的 collection。更确切地讲，set 不包含满足 e1.equals(e2) 的元素对 e1 和 e2，并且最多包含一个 null 元素。</p>
<p>不可随机访问包含的元素</p>
<p>只能用Iterator实现单向遍历</p>
<p>Set 没有同步方法</p>
</blockquote>
<ul>
<li>List</li>
</ul>
<blockquote>
<p>可随机访问包含的元素<br>元素是有序的<br>可在任意位置增、删元素<br>不管访问多少次，元素位置不变<br>允许重复元素<br>用Iterator实现单向遍历，也可用ListIterator实现双向遍历</p>
</blockquote>
<ul>
<li>Queue</li>
</ul>
<blockquote>
<p>先进先出</p>
<p>Queue使用时要尽量避免Collection的add()和remove()方法，而是要使用offer()来加入元素，使用poll()来获取并移出元素。它们的优点是通过返回值可以判断成功与否，add()和remove()方法在失败的时候会抛出异常。 如果要使用前端而不移出该元素，使用element()或者peek()方法。<br>值得注意的是LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。</p>
<p>Queue 实现通常不允许插入 null 元素，尽管某些实现（如 LinkedList）并不禁止插入 null。即使在允许 null 的实现中，也不应该将 null 插入到 Queue 中，因为 null 也用作 poll 方法的一个特殊返回值，表明队列不包含元素。</p>
</blockquote>
<ul>
<li>Stack</li>
</ul>
<blockquote>
<p>后进先出</p>
<p>Stack继承自Vector（可增长的对象数组），也是同步的<br>它通过五个操作对类 Vector 进行了扩展 ，允许将向量视为堆栈。它提供了通常的 push 和 pop 操作，以及取堆栈顶点的 peek 方法、测试堆栈是否为空的 empty 方法、在堆栈中查找项并确定到<strong>堆栈顶</strong>距离的 search 方法。</p>
</blockquote>
<ul>
<li>用法</li>
</ul>
<blockquote>
<p>如果涉及到堆栈、队列等操作，应该考虑用List；</p>
<p>对于需要快速插入，删除元素，应该使用LinkedList；</p>
<p>如果需要快速随机访问元素，应该使用ArrayList。</p>
<p>如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高</p>
</blockquote>
</li>
<li><p>HashMap和HashTable的区别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashMap是Hashtable的轻量级实现(非线程安全的实现)，他们都完成了Map接口，主要区别在于HashMap允许空(null)键值(key),由于非线程安全，效率上可能高于Hashtable。</span><br><span class="line">HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。</span><br><span class="line">HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。</span><br><span class="line">Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。</span><br><span class="line">最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步(如果是ArrayList：List lst = Collections.synchronizedList(new ArrayList());如果是HashMap：Map map = Collections.synchronizedMap(new HashMap());)。</span><br><span class="line">Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异</span><br></pre></td></tr></table></figure>
</li>
<li><p>HashMap和ConcurrentHashMap的区别，HashMap的底层源码。</p>
<p>　　Hashmap本质是数组加链表。根据key取得hash值，然后计算出数组下标，如果多个key对应到同一个下标，就用链表串起来，新插入的在前面。</p>
<p>　　ConcurrentHashMap：在hashMap的基础上，ConcurrentHashMap将数据分为多个segment，默认16个（concurrency level），然后每次操作对一个segment加锁，避免多线程锁的几率，提高并发效率。</p>
<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><p><strong>一、HashMap概述</strong></p>
<h1 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h1><p>　　HashMap基于哈希表的 <code>Map</code> 接口的实现。此实现提供所有可选的映射操作，并允许使用 <code>null</code> 值和 <code>null</code> 键。（除了不同步和允许使用 null 之外，<code>HashMap</code> 类与 <code>Hashtable</code> 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<h1 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h1><p>　　值得注意的是HashMap不是线程安全的，如果想要线程安全的HashMap，可以通过Collections类的静态方法synchronizedMap获得线程安全的HashMap。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1  Map map = Collections.synchronizedMap(new HashMap());</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>**二、HashMap的数据结构**

　HashMap的底层主要是基于数组和链表来实现的，它之所以有相当快的查询速度主要是因为它是通过计算散列码来决定存储的位置，能够很快的计算出对象所存储的位置。HashMap中主要是通过key的hashCode来计算hash值的，只要hashCode相同，计算出来的hash值就一样。如果存储的对象对多了，就有可能不同的对象所算出来的hash值是相同的，这就出现了所谓的hash冲突。学过数据结构的同学都知道，解决hash冲突的方法有很多，HashMap底层是通过链表来解决hash冲突的。

​                                      **![技术分享](https://images2015.cnblogs.com/blog/679904/201510/679904-20151025192734520-1277367181.png)**

从上图中可以看出，HashMap底层就是一个数组结构，数组中存放的是一个Entry对象，如果产生的hash冲突，也就是说要存储的那个位置上面已经存储了对象了，这时候该位置存储的就是一个链表了。我们看看HashMap中Entry类的代码：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 1 static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line"> 2         final K key;</span><br><span class="line"> 3         V value;</span><br><span class="line"> 4         Entry&lt;K,V&gt; next;</span><br><span class="line"> 5         final int hash;</span><br><span class="line"> 6 </span><br><span class="line"> 7         /**</span><br><span class="line"> 8          * Creates new entry.</span><br><span class="line"> 9          */</span><br><span class="line">10         Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">11             value = v;</span><br><span class="line">12             next = n; //hash值冲突后存放在链表的下一个</span><br><span class="line">13             key = k;</span><br><span class="line">14             hash = h;</span><br><span class="line">15         &#125;</span><br><span class="line">16 </span><br><span class="line">17         .........</span><br><span class="line">18     &#125;</span><br></pre></td></tr></table></figure>

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

HashMap其实就是一个Entry数组，Entry对象中包含了键和值，其中next也是一个Entry对象，它就是用来处理hash冲突的，形成一个链表。

**三、HashMap源码分析**

　　先看看HashMap类中的一些关键属性：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 transient Entry[] table;//存储元素的实体数组</span><br><span class="line">2 </span><br><span class="line">3 transient int size;//存放元素的个数</span><br><span class="line">4 </span><br><span class="line">5 int threshold; //临界值   当实际大小超过临界值时，会进行扩容threshold = 加载因子*容量</span><br><span class="line">6 </span><br><span class="line">7 final float loadFactor; //加载因子</span><br><span class="line">8 </span><br><span class="line">9 transient int modCount;//被修改的次数</span><br></pre></td></tr></table></figure>

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　   其中加载因子是表示Hash表中元素的填满的程度.若:加载因子越大,填满的元素越多,好处是,空间利用率高了,但:冲突的机会加大了.反之,加载因子越小,填满的元素越少,
好处是:冲突的机会减小了,但:空间浪费多了.冲突的机会越大,则查找的成本越高.反之,查找的成本越小.因而,查找时间就越小.因此,必须在 &quot;冲突的机会&quot;与&quot;空间利用率&quot;之间寻找一种平衡与折衷. 这种平衡与折衷本质上是数据结构中有名的&quot;时-空&quot;矛盾的平衡与折衷.

　　如果机器内存足够，并且想要提高查询速度的话可以将加载因子设置小一点；相反如果机器内存紧张，并且对查询速度没有什么要求的话可以将加载因子设置大一点。不过一般我们都不用去设置它，让它取默认值0.75就好了。

　　下面看看HashMap的几个构造方法：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> 1 public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line"> 2         //确保数字合法</span><br><span class="line"> 3         if (initialCapacity &lt; 0)</span><br><span class="line"> 4             throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line"> 5                                                initialCapacity);</span><br><span class="line"> 6         if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line"> 7             initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"> 8         if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line"> 9             throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">10                                                loadFactor);</span><br><span class="line">11 </span><br><span class="line">12         // Find a power of 2 &gt;= initialCapacity</span><br><span class="line">13         int capacity = 1;   //初始容量</span><br><span class="line">14         while (capacity &lt; initialCapacity)   //确保容量为2的n次幂，使capacity为大于initialCapacity的最小的2的n次幂</span><br><span class="line">15             capacity &lt;&lt;= 1;</span><br><span class="line">16 </span><br><span class="line">17         this.loadFactor = loadFactor;</span><br><span class="line">18         threshold = (int)(capacity * loadFactor);</span><br><span class="line">19         table = new Entry[capacity];</span><br><span class="line">20         init();</span><br><span class="line">21     &#125;</span><br><span class="line">22 </span><br><span class="line">23     public HashMap(int initialCapacity) &#123;</span><br><span class="line">24         this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">25     &#125;</span><br><span class="line">26 </span><br><span class="line">27     public HashMap() &#123;</span><br><span class="line">28         this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">29         threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);</span><br><span class="line">30         table = new Entry[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">31         init();</span><br><span class="line">32     &#125;</span><br></pre></td></tr></table></figure>

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　我们可以看到在构造HashMap的时候如果我们指定了加载因子和初始容量的话就调用第一个构造方法，否则的话就是用默认的。默认初始容量为16，默认加载因子为0.75。我们可以看到上面代码中13-15行，这段代码的作用是确保容量为2的n次幂，使capacity为大于initialCapacity的最小的2的n次幂，至于为什么要把容量设置为2的n次幂，我们等下再看。

　　下面看看HashMap存储数据的过程是怎样的，首先看看HashMap的put方法：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> 1 public V put(K key, V value) &#123;</span><br><span class="line"> 2         if (key == null) //如果键为null的话，调用putForNullKey(value)</span><br><span class="line"> 3             return putForNullKey(value);</span><br><span class="line"> 4         int hash = hash(key.hashCode());//根据键的hashCode计算hash码</span><br><span class="line"> 5         int i = indexFor(hash, table.length);</span><br><span class="line"> 6         for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; //处理冲突的，如果hash值相同，则在该位置用链表存储</span><br><span class="line"> 7             Object k;</span><br><span class="line"> 8             if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; //如果key相同则覆盖并返回旧值</span><br><span class="line"> 9                 V oldValue = e.value;</span><br><span class="line">10                 e.value = value;</span><br><span class="line">11                 e.recordAccess(this);</span><br><span class="line">12                 return oldValue;</span><br><span class="line">13             &#125;</span><br><span class="line">14         &#125;</span><br><span class="line">15 </span><br><span class="line">16         modCount++;</span><br><span class="line">17         addEntry(hash, key, value, i);</span><br><span class="line">18         return null;</span><br><span class="line">19     &#125;</span><br></pre></td></tr></table></figure>

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

当我们往hashmap中put元素的时候，先根据key的hash值得到这个元素在数组中的位置（即下标），然后就可以把这个元素放到对应的位置中了。如果这个元素所在的位子上已经存放有其他元素了，那么在同一个位子上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。从hashmap中get元素时，首先计算key的hashcode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。

具体的实现是：

当你的key为null时，会调用**putForNullKey,HashMap允许key为null,这样的对像是放在table[0]中。**

如果不为空，则调用int hash = hash(key.hashCode());这是hashmap的一个自定义的hash,在key.hashCode()基础上进行二次hash

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 static int hash(int h) &#123;  </span><br><span class="line">2         h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);  </span><br><span class="line">3         return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);  </span><br><span class="line">4   &#125;</span><br></pre></td></tr></table></figure>

得到hash码之后就会通过hash码去计算出应该存储在数组中的索引，计算索引的函数如下：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 static int indexFor(int h, int length) &#123;  </span><br><span class="line">2        return h &amp; (length-1);  </span><br><span class="line">3    &#125;</span><br></pre></td></tr></table></figure>

　这个方法非常巧妙，它通过 h &amp; (table.length -1) 来得到该对象的保存位，而HashMap底层数组的长度总是 2 的n 次方，这是HashMap在速度上的优化。当length总是 2 的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。

下面我们继续回到put方法里面，前面已经计算出索引的值了，看到第6到14行，如果数组中该索引的位置的链表已经存在key相同的对象，则将其覆盖掉并返回原先的值。如果没有与key相同的键，则调用addEntry方法创建一个Entry对象，addEntry方法如下：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">2         Entry&lt;K,V&gt; e = table[bucketIndex]; //如果要加入的位置有值，将该位置原先的值设置为新entry的next,也就是新entry链表的下一个节点</span><br><span class="line">3         table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">4         if (size++ &gt;= threshold) //如果大于临界值就扩容</span><br><span class="line">5             resize(2 * table.length); //以2的倍数扩容</span><br><span class="line">6     &#125;</span><br></pre></td></tr></table></figure>

参数bucketIndex就是indexFor函数计算出来的索引值，第2行代码是取得数组中索引为bucketIndex的Entry对象，第3行就是用hash、key、value构建一个新的Entry对象放到索引为bucketIndex的位置，并且将该位置原先的对象设置为新对象的next构成链表。

　　第4行和第5行就是判断put后size是否达到了临界值threshold，如果达到了临界值就要进行扩容，HashMap扩容是扩为原来的两倍。resize()方法如下：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 1 void resize(int newCapacity) &#123;</span><br><span class="line"> 2         Entry[] oldTable = table;</span><br><span class="line"> 3         int oldCapacity = oldTable.length;</span><br><span class="line"> 4         if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line"> 5             threshold = Integer.MAX_VALUE;</span><br><span class="line"> 6             return;</span><br><span class="line"> 7         &#125;</span><br><span class="line"> 8 </span><br><span class="line"> 9         Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">10         transfer(newTable);//用来将原先table的元素全部移到newTable里面</span><br><span class="line">11         table = newTable;  //再将newTable赋值给table</span><br><span class="line">12         threshold = (int)(newCapacity * loadFactor);//重新计算临界值</span><br><span class="line">13     &#125;</span><br></pre></td></tr></table></figure>

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

扩容是需要进行数组复制的，上面代码中第10行为复制数组，复制数组是非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。
</code></pre><ol>
<li><p>TreeMap、HashMap、LindedHashMap的区别。</p>
<p>Map主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重复。<br>Hashmap 是一个最常用的Map,它根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。<br>Hashtable与 HashMap类似,它继承自Dictionary类，不同的是:它不允许记录的键或者值为空;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢。<br>LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。<br>TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。</p>
<p>一般情况下，我们用的最多的是HashMap,HashMap里面存入的键值对在取出的时候是随机的,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。<br>TreeMap取出来的是排序后的键值对。但如果您要<strong>按自然顺序或自定义顺序遍历键</strong>，那么TreeMap会更好。<br>LinkedHashMap 是HashMap的一个子类，如果需要<strong>输出的顺序和输入的相同</strong>,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列，像连接池中可以应用。</p>
</li>
</ol>
<pre><code>\1. HashSet是通过HashMap实现的,TreeSet是通过TreeMap实现的,只不过Set用的只是Map的key
\2. Map的key和Set都有一个共同的特性就是集合的唯一性.TreeMap更是多了一个排序的功能.
\3. hashCode和equal()是HashMap用的, 因为无需排序所以只需要关注定位和唯一性即可.
   a. hashCode是用来计算hash值的,hash值是用来确定hash表索引的.
   b. hash表中的一个索引处存放的是一张链表, 所以还要通过equal方法循环比较链上的每一个对象
       才可以真正定位到键值对应的Entry.
   c. put时,如果hash表中没定位到,就在链表前加一个Entry,如果定位到了,则更换Entry中的value,并返回旧value
\4. 由于TreeMap需要排序,所以需要一个Comparator为键值进行大小比较.当然也是用Comparator定位的.
   a. Comparator可以在创建TreeMap时指定
   b. 如果创建时没有确定,那么就会使用key.compareTo()方法,这就要求key必须实现Comparable接口.
   c. TreeMap是使用Tree数据结构实现的,所以使用compare接口就可以完成定位了.





注意： 
1、Collection没有get()方法来取得某个元素。只能通过iterator()遍历元素。 
2、Set和Collection拥有一模一样的接口。 
3、List，可以通过get()方法来一次取出一个元素。使用数字来选择一堆对象中的一个，get(0)...。(add/get) 
4、一般使用ArrayList。用LinkedList构造堆栈stack、队列queue。 
5、Map用 put(k,v) / get(k)，还可以使用containsKey()/containsValue()来检查其中是否含有某个key/value。 
      HashMap会利用对象的hashCode来快速找到key。 
    *     hashing 
          哈希码就是将对象的信息经过一些转变形成一个独一无二的int值，这个值存储在一个array中。 
          我们都知道所有存储结构中，array查找速度是最快的。所以，可以加速查找。 
          发生碰撞时，让array指向多个values。即，数组每个位置上又生成一个梿表。 
6、Map中元素，可以将key序列、value序列单独抽取出来。 
使用keySet()抽取key序列，将map中的所有keys生成一个Set。 
使用values()抽取value序列，将map中的所有values生成一个Collection。 
为什么一个生成Set，一个生成Collection？那是因为，key总是独一无二的，value允许重复。 
</code></pre><ol>
<li><p>Collection包结构，与Collections的区别。</p>
<p> Collection是集合类的一个顶级接口，其直接继承接口有List与Set</p>
<p>而Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</p>
<p>Collection是个java.util下的接口，它是各种集合结构的父接口。</p>
<p>Collections是个java.util下的类，它包含有各种有关集合操作的静态方法。</p>
<p>Collection 层次结构中的根接口。Collection 表示一组对象，这些对象也称为 collection的<em>元素</em>。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。JDK 不提供此接口的任何<em>直接</em> 实现：它提供更具体的子接口（如 <code>Set</code> 和 <code>List</code>）实现。此接口通常用来传递 collection，并在需要最大普遍性的地方操作这些 collection。</p>
<p>Collection<br>├List<br>│├LinkedList<br>│├ArrayList<br>│└Vector<br>│　└Stack<br>└Set </p>
<p>collections 此类完全由在 collection 上进行操作或返回 collection 的静态方法组成。它包含在 collection 上操作的多态算法，即“包装器”，包装器返回由指定 collection 支持的新 collection，以及少数其他内容。 如果为此类的方法所提供的 collection 或类对象为 null，则这些方法都会抛出 <code>NullPointerException</code>。</p>
</li>
</ol>
<ol>
<li><p>try catch finally，try里有return，finally还执行么？</p>
<p><strong>肯定会执行。finally{}块的代码只有在try{}块中包含遇到System.exit(0);之类的导致Java虚拟机直接退出的语句才会不执行。</strong></p>
<p><em>*当程序执行try{}遇到return时，程序会先执行return语句，但并不会立即返回——也就是把return语句要做的一切事情都准备好，也就是在将要返回、但并未返回的时候，程序把执行流程转去执行finally块，当finally块执行完成后就直接返回刚才return语句已经准备好的结果。</em></p>
</li>
</ol>
<ol>
<li><p>Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况。</p>
<p>Java异常架构图</p>
<p><img src="http://image.mamicode.com/info/201510/20180110170633684739.jpg" alt="技术分享"></p>
<p><strong>1. Throwable</strong><br>Throwable是 Java 语言中所有错误或异常的超类。<br>Throwable包含两个子类: <strong>Error</strong> 和 <strong>Exception</strong> 。它们通常用于指示发生了异常情况。<br>Throwable包含了其线程创建时线程执行堆栈的快照，它提供了printStackTrace()等接口用于获取堆栈跟踪数据等信息。</p>
<p><strong>2. Exception</strong><br>Exception及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。</p>
<p><strong>3. RuntimeException</strong><br>RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。<br>编译器不会检查RuntimeException异常。 例如，除数为零时，抛出ArithmeticException异常。RuntimeException是ArithmeticException的超类。当代码发生除数为零的情况时，倘若既”没有通过throws声明抛出ArithmeticException异常”，也”没有通过try…catch…处理该异常”，也能通过编译。这就是我们所说的”编译器不会检查RuntimeException异常”！<br>如果代码会产生RuntimeException异常，则需要通过修改代码进行避免。 例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！</p>
<p><strong>4. Error</strong><br>和Exception一样， Error也是Throwable的子类。 它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件。<br>和RuntimeException一样， 编译器也不会检查Error。</p>
<p>Java将可抛出(Throwable)的结构分为三种类型： <strong>被检查的异常(Checked Exception)，运行时异常(RuntimeException)和错误(Error)。</strong></p>
<p><strong>(01) 运行时异常</strong><br><strong>定义</strong> : RuntimeException及其子类都被称为运行时异常。<br><strong>特点</strong> : Java编译器不会检查它。 也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。例如，除数为零时产生的ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fail机制产生的ConcurrentModificationException异常等，都属于运行时异常。<br>虽然Java编译器不会检查运行时异常，但是我们也可以通过throws进行声明抛出，也可以通过try-catch对它进行捕获处理。<br>如果产生运行时异常，则需要通过修改代码来进行避免。 例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！</p>
<p><strong>(02) 被检查的异常</strong><br><strong>定义</strong> :  Exception类本身，以及Exception的子类中除了”运行时异常”之外的其它子类都属于被检查异常。<br><strong>特点</strong> : Java编译器会检查它。 此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。例如，CloneNotSupportedException就属于被检查异常。当通过clone()接口去克隆一个对象，而该对象对应的类没有实现Cloneable接口，就会抛出CloneNotSupportedException异常。<br>被检查异常通常都是可以恢复的。</p>
<p><strong>(03) 错误</strong><br><strong>定义</strong> : Error类及其子类。<br><strong>特点</strong> : 和运行时异常一样，编译器也不会对错误进行检查。<br>当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError就属于错误。<br>按照Java惯例，我们是不应该是实现任何新的Error子类的！</p>
<p>对于上面的3种结构，我们在抛出异常或错误时，到底该哪一种？《Effective Java》中给出的建议是： 对于可以恢复的条件使用被检查异常，对于程序错误使用运行时异常。</p>
</li>
</ol>
<pre><code>OOM：

1，   OutOfMemoryError异常

除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM)异常的可能，

Java Heap 溢出

一般的异常信息：java.lang.OutOfMemoryError:Java heap spacess

java堆用于存储对象实例，我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。

出现这种异常，一般手段是先通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。

如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象时通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收。

如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx与-Xms)的设置是否适当。

2，   虚拟机栈和本地方法栈溢出

如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。

如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常

这里需要注意当栈的大小越大可分配的线程数就越少。

3，   运行时常量池溢出

异常信息：java.lang.OutOfMemoryError:PermGen space

如果要向运行时常量池中添加内容，最简单的做法就是使用String.intern()这个Native方法。该方法的作用是：如果池中已经包含一个等于此String的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量。

4，   方法区溢出

方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。

异常信息：java.lang.OutOfMemoryError:PermGen space

方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛刻的。在经常动态生成大量Class的应用中，要特别注意这点。
</code></pre><ol>
<li><p>Java面向对象的三个特征与含义。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>属性的封装和方法的封装。把属性定义为私有的， get(),set()方法。 好处是信息隐藏和模块化，提高安全性。封装的主要作用在于对外隐藏内 部实现细节，增强程序的安全性。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>子类可以继承父类的成员变量和成员方法。继承可以提高代码的复用性。</p>
<p>继承的特性： </p>
<p>​        1.单一继承。 </p>
<p>​        2.子类只能继承父类的非私有成员变量和方法。 </p>
<p>​        3.成员变量的隐藏和方法的覆盖。 </p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>当同一个操作作用在不同对象时，会产生不同的结果。</p>
<p>有 2 种方式来实现多态，一种是编译时多态，另外一种是运行时多态；编译时多态是通过方法的重载来实现的，运行时多态是通过方法的重写来实现的。 方法的重载，指的是同一个类中有多个同名的方法，但这些方法有着不同 的参数。在编译时就可以确定到底调用哪个方法。 方法的重写，子类重写父类中的方法。父类的引用变量不仅可以指向父类 的实例对象，还可以指向子类的实例对象。当父类的引用指向子类的对象时， 只有在运行时才能确定调用哪个方法。 特别注意：只有类中的方法才有多态的概念，类中成员变量没有多态的概念。</p>
<p>Override（覆盖、重写）和 Overload（重载）的区别。 </p>
<p>重载和覆盖是 java 多态性的不同表现方式。 重载是在一个类中多态性的一种表现，是指在一个类中定义了多个同名的 方法，但是他们有不同的参数个数或有不同的参数类型。 在使用重载时要注意以下几点： </p>
<p>​        1.重载只能通过不同的方法参数来区分。例如不同的参数类型，不同的 参数个数，不同的参数顺序。 </p>
<p>​        2.不能通过访问权限、返回类型、抛出的异常进行重载。 </p>
<p>覆盖是指子类函数覆盖父类中的函数。 在覆盖时要注意以下几点（重点！！）： </p>
<p>​        1.覆盖的方法的函数名和参数必须要和被覆盖的方法的函数名和参数完全匹配，才能达到覆盖的效果；</p>
<p>​        2.覆盖的方法的返回值必须和被覆盖的方法的返回值类型一致； </p>
<p>​        3.覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者 是其子类； </p>
<p>​        4.被覆盖的方法不能为 private，否则在其子类中只是新定义了一个方法， 并没有对其进行覆盖。 </p>
<p>​        5. 子类函数的访问修饰权限要大于等于父类的 （public&gt;protected&gt;default&gt;private） 。（重要！！！） </p>
<p>​        特别注意：Java 中，子类无法覆盖父类的 static 方法或 private 方法。</p>
</li>
</ol>
<ol>
<li><p>Override和Overload的含义去区别。</p>
<p>重写(Override)也称覆盖，它是父类与子类之间多态性的一种表现，而重载(Overload)是一个类中多态性的一种表现。 override从字面就可以知道，它是覆盖了一个方法并且对其重写，以求达到不同的作用。overload它是指我们可以定义一些名称相同的方法，通过定义不同的输入参数来区分这些方法，然后再调用时，VM就会根据不同的参数样式，来选择合适的方法执行。</p>
<p>2、override（重写，覆盖）<br>（1）方法名、参数、返回值相同。<br>（2）子类方法不能缩小父类方法的访问权限。<br>（3）子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。<br>（4）存在于父类和子类之间。<br>（5）方法被定义为final不能被重写。<br>（6）被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</p>
<p>3、overload（重载，过载）<br>（1）参数类型、个数、顺序至少有一个不相同。<br>（2）不能重载只有返回值不同的方法名。<br>（3）针对于一个类而言。<br>（4）不能通过访问权限、返回类型、抛出的异常进行重载；<br>（5）方法的异常类型和数目不会对重载造成影响；</p>
<p>4、override应用：<br>（1）最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。<br>（2）除了这个典型的用法以外，我们在继承中也可能会在子类覆盖父类中的方法。</p>
<p>5、总结<br>　　override是在不同类之间的行为，overload是在同一个类中的行为。</p>
</li>
</ol>
<ol>
<li><p>Interface与abstract类的区别。</p>
<p>　　含有abstract修饰符的class即为抽象类，abstract 类不能创建的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。</p>
<p>　　接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。<strong>接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final</strong>。</p>
</li>
</ol>
<pre><code>下面比较一下两者的语法区别：

1.抽象类可以有构造方法，接口中不能有构造方法。

2.抽象类中可以有普通成员变量，接口中没有普通成员变量

3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。

\4. 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然

eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。

\5. 抽象类中可以包含静态方法，接口中不能包含静态方法

\6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。

\7. 一个类可以实现多个接口，但只能继承一个抽象类。



下面接着再说说两者在应用上的区别：

　　接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码。
</code></pre><ol>
<li><p>Static class 与non static class的区别。</p>
<p>| static class                                                 | non static class                                             |<br>| ———————————————————— | ———————————————————— |<br>| 1、用static修饰的是内部类，此时这个内部类变为静态内部类；对测试有用；2、内部静态类不需要有指向外部类的引用；3、静态类只能访问外部类的静态成员，不能访问外部类的非静态成员； | 1、非静态内部类需要持有对外部类的引用；2、非静态内部类能够访问外部类的静态和非静态成员；3、一个非静态内部类不能脱离外部类实体被创建；4、一个非静态内部类可以访问外部类的数据和方法； |</p>
</li>
<li><p>java多态的实现原理。</p>
<p><strong>1．Java多态概述</strong></p>
<p>多态是面向对象编程语言的重要特性，它允许基类的指针或引用指向派生类的对象，而在具体访问时实现方法的动态绑定。Java 对于方法调用动态绑定的实现主要依赖于方法表，但通过类引用调用(invokevitual)和接口引用调用(invokeinterface)的实现则有所不同。</p>
<p>类引用调用的大致过程为：Java编译器将Java源代码编译成class文件，在编译过程中，会根据静态类型将调用的符号引用写到class文件中。在执行时，JVM根据class文件找到调用方法的符号引用，然后在静态类型的方法表中找到偏移量，然后根据this指针确定对象的实际类型，使用实际类型的方法表，偏移量跟静态类型中方法表的偏移量一样，如果在实际类型的方法表中找到该方法，则直接调用，否则，认为没有重写父类该方法。按照继承关系从下往上搜索。 </p>
<p>接口引用调用后面再说吧。</p>
</li>
</ol>
<pre><code>从上图可以看出，当程序运行时，需要某个类时，类载入子系统会将相应的class文件载入到JVM中，并在内部建立该类的类型信息（这个类型信息其实就是class文件在JVM中存储的一种数据结构），包含java类定义的所有信息，包括方法代码，类变量、成员变量、以及本博文要重点讨论的方法表。这个类型信息就存储在方法区。 
注意，这个方法区中的类型信息跟在堆中存放的class对象是不同的。在方法区中，这个class的类型信息只有唯一的实例（所以是各个线程共享的内存区域），而在堆中可以有多个该class对象。可以通过堆中的class对象访问到方法区中类型信息。就像在java反射机制那样，通过class对象可以访问到该类的所有信息一样。

【重点】 

方法表是实现动态调用的核心。上面讲过方法表存放在方法区中的类型信息中。为了优化对象调用方法的速度，方法区的类型信息会增加一个指针，该指针指向一个记录该类方法的方法表，方法表中的每一个项都是对应方法的指针。
这些方法中包括从父类继承的所有方法以及自身重写（override）的方法。

【拓展】

方法区：方法区和JAVA堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 
运行时常量池：它是方法区的一部分，Class文件中除了有类的版本、方法、字段等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分信息在类加载时进入方法区的运行时常量池中。 
方法区的内存回收目标是针对常量池的回收及对类型的卸载。

**3****．****Java** **的方法调用方式（拓展知识，可以不看）**

Java 的方法调用有两类，动态方法调用与静态方法调用。

静态方法调用是指对于类的静态方法的调用方式，是静态绑定的；而动态方法调用需要有方法调用所作用的对象，是动态绑定的。

类调用 (invokestatic) 是在编译时就已经确定好具体调用方法的情况。

实例调用 (invokevirtual)则是在调用的时候才确定具体的调用方法，这就是动态绑定，也是多态要解决的核心问题。

JVM 的方法调用指令有四个，分别是 invokestatic，invokespecial，invokesvirtual 和 invokeinterface。前两个是静态绑定，后两个是动态绑定的。本文也可以说是对于JVM后两种调用实现的考察。

**4．方法表与方法调用**

如有类定义 Person, Girl, Boy

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public String toString()&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return &quot;I&apos;m a person.&quot;;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public void eat()&#123;&#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public void speak()&#123;&#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> class Boy extends Person&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public String toString()&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return &quot;I&apos;m a boy&quot;;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public void speak()&#123;&#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public void fight()&#123;&#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> class Girl extends Person&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public String toString()&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return &quot;I&apos;m a girl&quot;;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public void speak()&#123;&#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public void sing()&#123;&#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

当这三个类被载入到

 Java 

虚拟机之后，方法区中就包含了各自的类的信息。

Girl 

和

 Boy 

在方法区中的方法表可表示如下：

![img](https://img-blog.csdn.net/20160812143114843)

可以看到，Girl 和 Boy 的方法表包含继承自 Object 的方法，继承自直接父类 Person 的方法及各自新定义的方法。注意方法表条目指向的具体的方法地址，如 Girl 继承自 Object 的方法中，只有 toString() 指向自己的实现（Girl 的方法代码），其余皆指向 Object 的方法代码；其继承自于 Person 的方法 eat() 和 speak() 分别指向 Person 的方法实现和本身的实现。

如果子类改写了父类的方法，那么子类和父类的那些同名的方法共享一个方法表项。

因此，方法表的偏移量总是固定的。所有继承父类的子类的方法表中，其父类所定义的方法的偏移量也总是一个定值。
Person 或 Object中的任意一个方法，在它们的方法表和其子类 Girl 和 Boy 的方法表中的位置 (index) 是一样的。这样 JVM 在调用实例方法其实只需要指定调用方法表中的第几个方法即可。

如调用如下:

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Party&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void happyHour()&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person girl = new Girl();   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">girl.speak(); &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

当编译 Party 类的时候，生成 girl.speak()的方法调用假设为：

Invokevirtual #12

设该调用代码对应着 girl.speak(); #12 是 Party 类的常量池的索引。JVM 执行该调用指令的过程如下所示：



（1）

在常量池（这里有个错误，上图为ClassReference常量池而非Party的常量池）中找到方法

调用的符号引用



。

（2）查看

Person的方法表，

得到

speak

方法在该方法表的偏移量

（假设为15），这样就得到该方法的直接引用。 



（3）根据this指针得到

具体的对象

（即 girl 所指向的位于堆中的对象）。



（4）

根据对象得到该对象对应的方法表

，根据偏移量15查看有无重写（override）该方法，

如果重写，则可以直接调用（

Girl

的方法表的

speak

项指向自身的方法而非父类）；如果没有重写，则需要拿到按照继承关系从下往上的基类（这里是

Person

类）的方法表，同样按照这个偏移量

15

查看有无该方法。



**5．接口调用**

因为 Java 类是可以同时实现多个接口的，而当用接口引用调用某个方法的时候，情况就有所不同了。

Java 允许一个类实现多个接口，从某种意义上来说相当于多继承，这样同样的方法在基类和派生类的方法表的位置就可能不一样了

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">interface IDance&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   void dance();   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> class Person &#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public String toString()&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   return &quot;I&apos;m a person.&quot;;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public void eat()&#123;&#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public void speak()&#123;&#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> class Dancer extends Person   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> implements IDance &#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public String toString()&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   return &quot;I&apos;m a dancer.&quot;;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public void dance()&#123;&#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> class Snake implements IDance&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public String toString()&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   return &quot;A snake.&quot;;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public void dance()&#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> //snake dance   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

可以看到，由于接口的介入，继承自于接口 IDance 的方法 dance()在类 Dancer 和 Snake 的方法表中的位置已经不一样了，显然我们无法仅根据偏移量来进行方法的调用。

Java 对于接口方法的调用是采用搜索方法表的方式，如，要在Dancer的方法表中找到dance()方法，必须搜索Dancer的整个方法表。

因为每次接口调用都要搜索方法表，所以从效率上来说，接口方法的调用总是慢于类方法的调用的。
</code></pre><ol>
<li><p>实现多线程的两种方法：Thread与Runable。</p>
<ul>
<li>l 创建线程的第一种方式：继承Thread类。</li>
</ul>
<p>步骤：</p>
<p>1，定义类继承Thread。</p>
<p>2，复写Thread类中的run方法。</p>
<p>目的：将自定义代码存储在run方法。让线程运行。//run();仅仅是对象调用方法。而线程创建了，并没有运行。</p>
<p>3，调用线程的start方法，</p>
<p>该方法两个作用：启动线程，调用run方法。</p>
<p>Demo d = new Demo();//创建好一个线程。</p>
<p>//d.start();//开启线程并执行该线程的run方法。</p>
<p>d.run();//仅仅是对象调用方法。而线程创建了，并没有运行。</p>
<ul>
<li>l 创建线程的第二种方式：实现Runable接口</li>
</ul>
<p>步骤：</p>
<p>1，定义类实现Runnable接口</p>
<p>2，覆盖Runnable接口中的run方法。</p>
<p>将线程要运行的代码存放在该run方法中。</p>
<p>3，通过Thread类建立线程对象。</p>
<p>4，将Runnable接口的子类对象作为实际参数传递给Thread类的构造函数。</p>
<p>为什么要将Runnable接口的子类对象传递给Thread的构造函数。</p>
<p>因为，自定义的run方法所属的对象是Runnable接口的子类对象。</p>
<p>所以要让线程去指定指定对象的run方法。就必须明确该run方法所属对象。</p>
<p>5，调用Thread类的start方法开启线程并调用Runnable接口子类的run方法。</p>
</li>
</ol>
<pre><code>- l 实现方式和继承方式有什么区别呢？



实现方式好处：避免了单继承的局限性。

在定义线程时，建立使用实现方式。



两种方式区别：

继承Thread: 线程代码存放Thread子类run方法中。

实现Runnable，线程代码存在接口的子类的run方法。







实现Runnable接口相对于继承Thread类来说，有如下的显著优势：
   1.适合多个相同代码的线程去处理同一个资源的情况
   2.可以避免由于java的单继承特性带来的局限
   3.增强了程序的健壮性，代码能够被多个线程共享，代码与数据时独立的
给你个例子，你自己取运行就知道了，好好对比下

![复制代码](http://common.cnblogs.com/images/copycode.gif)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> 1 class MyThread extends Thread&#123;        // 继承Thread类，作为线程的实现类</span><br><span class="line"> 2         private int ticket = 5 ;                // 表示一共有5张票</span><br><span class="line"> 3         public void run()&#123;        // 覆写run()方法，作为线程 的操作主体</span><br><span class="line"> 4                 for(int i=0;i&lt;100;i++)&#123;</span><br><span class="line"> 5                         if(this.ticket&gt;0)&#123;</span><br><span class="line"> 6                                 System.out.println(&quot;卖票：ticket = &quot; + ticket--) ;</span><br><span class="line"> 7                         &#125;</span><br><span class="line"> 8                 &#125;</span><br><span class="line"> 9         &#125;</span><br><span class="line">10 &#125;;</span><br><span class="line">11 public class ThreadDemo0&#123;</span><br><span class="line">12         public static void main(String args[])&#123;</span><br><span class="line">13                 MyThread mt1 = new MyThread() ;         // 实例化对象</span><br><span class="line">14                 MyThread mt2 = new MyThread() ;         // 实例化对象</span><br><span class="line">15                 MyThread mt3 = new MyThread() ;         // 实例化对象</span><br><span class="line">16                 mt1.run() ;        // 调用线程主体</span><br><span class="line">17                 mt2.run() ;        // 调用线程主体</span><br><span class="line">18                 mt3.run() ;        // 调用线程主体</span><br><span class="line">19         &#125;</span><br><span class="line">20 &#125;;</span><br><span class="line">21 </span><br><span class="line">22 </span><br><span class="line">23 class MyThread implements Runnable&#123;        // 继承Thread类，作为线程的实现类</span><br><span class="line">24         private int ticket = 5 ;                // 表示一共有5张票</span><br><span class="line">25         public void run()&#123;        // 覆写run()方法，作为线程 的操作主体</span><br><span class="line">26                 for(int i=0;i&lt;100;i++)&#123;</span><br><span class="line">27                         if(this.ticket&gt;0)&#123;</span><br><span class="line">28                                 System.out.println(&quot;卖票：ticket = &quot; + ticket--) ;</span><br><span class="line">29                         &#125;</span><br><span class="line">30                 &#125;</span><br><span class="line">31         &#125;</span><br><span class="line">32 &#125;;</span><br><span class="line">33 public class RunnableDemo0&#123;</span><br><span class="line">34         public static void main(String args[])&#123;</span><br><span class="line">35                 MyThread mt = new MyThread() ;         // 实例化对象</span><br><span class="line">36                 new Thread(mt).run() ;        // 调用线程主体</span><br><span class="line">37                 new Thread(mt).run() ;        // 调用线程主体</span><br><span class="line">38                 new Thread(mt).run() ;        // 调用线程主体</span><br><span class="line">39         &#125;</span><br><span class="line">40 &#125;;</span><br></pre></td></tr></table></figure>

![复制代码](http://common.cnblogs.com/images/copycode.gif)

简单的来说，就是继承和实现接口的区别。
1、当使用继承的时候，主要是为了不必重新开发，并且在不必了解实现细节的情况下拥有了父类我所需要的特征。它也有一个很大的缺点，那就是如果我们的类已经从一个类继承（如小程序必须继承自 Applet 类），则无法再继承 Thread 类，
2、java只能单继承，因此如果是采用继承Thread的方法，那么在以后进行代码重构的时候可能会遇到问题，因为你无法继承别的类了，在其他的方面，两者之间并没什么太大的区别。
3、implement Runnable是面向接口，扩展性等方面比extends Thread好。
4、使用 Runnable 接口来实现多线程使得我们能够在一个类中包容所有的代码，有利于封装，它的缺点在于，我们只能使用一套代码，若想创建多个线程并使各个线程执行不同的代码，则仍必须额外创建类，如果这样的话，在大多数情况下也许还不如直接用多个类分别继承 Thread 来得紧凑。
</code></pre><ol>
<li><p>线程同步的方法：sychronized、lock、reentrantLock等。</p>
<p>当使用多线程访问同一个资源时，非常容易出现线程安全问题（例如，当多个线程同时对一个数据进行修改时，会导致某些线程对数据的修改丢失）。因此，需要采用同步机制来解决这个问题。同步方法如下：</p>
<p><strong>1.  Synchronized关键字</strong></p>
<p>在Java语言中，每个对象都有一个对象锁与之相关联，该锁表明对象在任何时候只允许被一个线程所拥有，当一个线程调用对象的一段Synchronized代码时，需要首先获取这个锁，然后去执行相应的代码，执行结束后，释放锁。</p>
<p>Synchronized关键字主要有两种用法（Synchronized方法和Synchronized块），此外该关键字还可以作用于静态方法（此时如果调用该静态方法，将会锁住整个类。）、类或者某个实例，但这都对程序的效率有着很大的影响。</p>
<p>1)  Synchronized方法。该方法在声明前加入了Synchronized关键字。把需要被同步的资源放到该方法中，就能保证这个方法在同一时刻只能被一个线程所访问，从而保证了多线程访问的安全性。然而，当一个方法的方法体规模非常大时，把该方法声明为Synchronized会大大影响程序的执行效率。为了提高程序的执行效率，java提供了Synchronized块。线程在执行同步方法时是具有排它性的。当任意一个线程进入到一个对象的任意一个同步方法时，这个对象的所有同步方法都被锁定了，在此期间，其他任何线程都不能访问这个对象的任意一个同步方法，直到这个线程执行完它所调用的同步方法并从中退出，从而导致它释放了该对象的同步锁之后。在一个对象被某个线程锁定之后，其他线程是可以访问这个对象的所有非同步方法的。</p>
<p>2)  Synchronized块。Synchronized块既可以把任意的代码段声明为Synchronized，也可以指定上锁的对象，有非常高的灵活性。如果一个对象既有同步方法，又有同步块，那么当其中任意一个同步方法或者同步块被某个线程执行时，这个对象就被锁定了，其他线程无法在此时访问这个对象的同步方法，也不能执行同步块。</p>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/java/s0.png" alt="img"></p>
<p><strong>2.  wait与notify</strong></p>
<p>当使用Synchronized来修饰某个共享资源时，如果线程A1在执行Synchronized代码，另外一个线程A2也要同时执行同一对象的同一Synchronized代码时，线程A2将要等到线程A1执行完成后，才能继续执行。在这种情况下可以使用wait和notify方法。</p>
<p>在Synchronized代码被执行期间，线程可以调用对象的wait方法，释放对象锁，进入等待状态，并且可以调用notify方法或者notifyAll方法通知正在等待的其他线程。notify方法仅唤醒一个线程（等待队列中的第一个线程）并允许他去获得锁。notifyAll方法唤醒所有等待这个对象的线程并允许他们去获得锁（并不是让所有被唤醒的线程去获得锁，而是让他们去竞争）。</p>
<p><strong>3.  Lock</strong></p>
<p>Jdk5新增了Lock接口以及他的一个实现类ReentrantLock（重入锁），以及ReadWriteLock接口和他的唯一实现类ReentrantReadWriteLock.这个类有两个锁，一个是读操作锁，一个是写操作锁。使用读操作锁时可以允许多个线程同时访问，使用写操作锁时只允许一个线程进行。在一个线程执行写操作时，其他线程不能够执行读操作。Lock也可以用来实现多线程的同步，具体而言，他提供了如下一些方法来实现多线程的同步：</p>
<p>1)  lock()。以阻塞方式来获取锁，如果获取到了锁，立即返回；如果别的线程持有锁，则当前线程等待，直到获取锁后返回。</p>
<p>2)  tryLock()。以非阻塞的方式获取锁。只是尝试性的去获取一下锁，如果获取到锁，立即返回true，立即否则返回false。</p>
<p>3)  tryLock(longtimeout,TimeUnit unit)。如果获取到了锁，立即返回true，否则会等待参数给定的时间单元，在等待的过程中，如果获取到了锁，就立即返回true。如果等待超时，返回false。</p>
<p>4)  lockInterruptibly（）。如果获取到了锁，立即返回；如果没有获取到锁，当前线程处于休眠状态，或者当前线程会被别的线程中断（会受到InterruptedException异常）。他与lock()方法的区别在于lock优先考虑获取锁，如果没有获取到锁，会一直处于阻塞状态，忽略interrupt（）方法，待获取锁成功后，才响应中断。lockInterruptibly 优先考虑响应中断，而不是响应锁的普通获取或重入获取。</p>
<p>5)  ReentrantLock()。创建一个ReentrantLock实例。</p>
<p>6)  Unlock()。释放锁</p>
<p>前面讲到了可重入锁，可重入锁就是当前持有该锁的线程能够多次获取该锁，无需等待。下面介绍一下可重入锁。举个例子：村里面有一口井，村民都想到井里面打水，村里人太多，要制定一个打水的规则。井边安排一个看井人，维护打水的秩序。打水时，以家庭为单位，哪个家庭任何人先到井边，就可以先打水，而且如果一个家庭占到了打水权，其家人这时候过来打水不用排队。而那些没有抢占到打水权的人，一个一个挨着在井边排成一队，先到的排在前面。打水示意图如下：</p>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/java/s1.png" alt="img"></p>
</li>
</ol>
<pre><code>是不是感觉很和谐，如果打水的人打完了，他会跟看井人报告，看井人会让第二个人接着打水。这样大家总都能够打到水。是不是看起来挺公平的，先到的人先打水，当然不是绝对公平的，自己看看下面这个场景 :

 ![img](https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/java/s2.png)

看着，一个有娃的父亲正在打水，他的娃也到井边了，所以女凭父贵直接排到最前面打水，羡煞旁人了。

以上这个故事模型就是所谓的公平锁模型，当一个人想到井边打水，而现在打水的人又不是自家人，这时候就得乖乖在队列后面排队。

然而总有些人不想排队，新来打水的人，他们看到有人排队打水的时候，他们不会那么乖巧的就排到最后面去排队，反之，他们会看看现在有没有人正在打水，如果有人在打水，没辄了，只好排到队列最后面，但如果这时候前面打水的人刚刚打完水，正在交接中，排在队头的人还没有完成交接工作，这时候，新来的人可以尝试抢打水权，如果抢到了，呵呵，其他人也只能睁一只眼闭一只眼，因为大家都默认这个规则了。这就是所谓的非公平锁模型。新来的人不一定总得乖乖排队，这也就造成了原来队列中排队的人可能要等很久很久。这就是所谓的非公平锁模型。

ReentrantLock支持两种获取锁的方式，一种是公平模型，一种是非公平模型。我们先把故事元素转换为程序元素。

![img](https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/java/s3.png)

首先说说**公平模型**：初始化时，state=0，表示无人抢占了打水权。这时候，村民A来打水(A线程请求锁)，占了打水权，把state+1，如下所示：

![img](https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/java/s4.png)

线程A取得了锁，把 state原子性+1,这时候state被改为1，A线程继续执行其他任务，然后来了村民B也想打水（线程B请求锁），线程B无法获取锁，生成节点进行排队，如下图所示：

 ![img](https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/java/s5.png)



初始化的时候，会生成一个空的头节点，然后才是B线程节点，这时候，如果线程A又请求锁，是否需要排队？答案当然是否定的，否则就直接死锁了。当A再次请求锁，就相当于是打水期间，同一家人也来打水了，是有特权的，这时候的状态如下图所示：

![img](https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/java/s6.png)

这就可重入锁。就是一个线程在获取了锁之后，再次去获取了同一个锁，这时候仅仅是把状态值进行累加。如果线程A释放了一次锁，就成这样了：

![img](https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/java/s7.png)

仅仅是把状态值减了，只有线程A把此锁全部释放了，状态值减到0了，其他线程才有机会获取锁。当A把锁完全释放后，state恢复为0，然后会通知队列唤醒B线程节点，使B可以再次竞争锁。当然，如果B线程后面还有C线程，C线程继续休眠，除非B执行完了，通知了C线程。注意，当一个线程节点被唤醒然后取得了锁，对应节点会从队列中删除。

**非公平锁模型**：当线程A执行完之后，要唤醒线程B是需要时间的，而且线程B醒来后还要再次竞争锁，所以如果在切换过程当中，来了一个线程C，那么线程C是有可能获取到锁的，如果C获取到了锁，B就只能继续乖乖休眠了。

代码如下：

![img](https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/java/s8.png)

ReentrantLock（CAS,AQS,java内存可见性（voliate））是可重入的独占锁或者叫排他锁。同时只能有一个线程获取该锁，其实现分为公平实现和非公平实现。读写锁解决了ReentrantLock同时只有一个线程可以获取该锁的缺点，我们实际情况下会有写少读多的场景，显然ReentrantLock满足不了要求需求，读写锁应运而生。

java5中添加了一个并发包， java.util.concurrent，里面提供了各种并发的工具类，通过此工具包，可以在java当中实现功能非常强大的多线程并发操作。

**4.  使用特殊域变量(volatile)实现线程同步**

在java语言编写的程序中，有时为了提高程序的运行效率，编译器会自动对其进行优化，把经常被访问的变量缓存起来，程序在读取这个变量时有可能会直接从缓存中（例如寄存器）来读取这个值，而不会去内存中读取。这样做的一个好处是提高了程序的运行效率，但当遇到多线程编程时，变量的值可能因为别的线程而改变了，而缓存里面的值不会相应改变，从而造成应用程序读取的值和实际的变量值不一致。

Volatile是一个类型修饰符，它是用来修饰被不同线程访问和修改的变量。被Volatile类型定义的变量，系统每次用他的时候都是直接从对应的内存中提取，而不会利用缓存。在使用了Volatile修饰成员变量后，所有线程在任何时候所看到的的变量的值都是相同的。

由于Volatile不能保证操作的原子性，因此，一般情况下，Volatile不能代替Synchronized。此外，使用Volatile会阻止编译器对代码的优化，因此会降低程序的执行效率。除非迫不得已，一般能不用就不要用。

Volatile为什么不能保证操作的原子性：当需要使用被volatile修饰的变量时，线程会从主内存中重新获取该变量的值，但当该线程修改完该变量的值写入主内存的时候，并没有判断主内存内该变量是否已经变化，故可能出现非预期的结果。如主内存内有被volatile修饰变量 a，值为3，某线程使用该变量时，重新从主存内读取该变量的值，为3，然后对其进行+1操作，此时该线程内a变量的副本值为4。但此时该线程的时间片时间到了，等该线程再次获得时间片的时候，主存内a的值已经是另外的值，如5，但是该线程并不知道，该线程继续完成其未完成的工作，将线程内的a副本的值4写入主存，这时，主存内a的值就是4了。这样，之前修改a的值为5的操作就相当于没有发生了，a的值出现了意料之外的结果。

被synchronize修饰的变量则可以保证变量操作的原子性，因为当某线程使用变量a时，其他线程无法使用变量a，只能等该线程对a操作结束，释放a的锁后才能对a进行操作。

![img](https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/java/s9.png)

**5.  使用局部变量实现线程同步**

如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。ThreadLocal 类的常用方法：

ThreadLocal() : 创建一个线程本地变量

get() : 返回此线程局部变量的当前线程副本中的值

initialValue() : 返回此线程局部变量的当前线程的&quot;初始值&quot;

set(T value) : 将此线程局部变量的当前线程副本中的值设置为value

![img](https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/java/s10.png) 

**6.  使用阻塞队列实现线程同步**

前面5种同步方式都是在底层实现的线程同步，但是我们在实际开发当中，应当尽量远离底层结构。使用java5版本中新增的java.util.concurrent包将有助于简化开发。使用LinkedBlockingQueue&lt;E&gt;来实现线程的同步，BlockingQueue通常用于一个线程生产对象，而另外一个线程消费这些对象的场景。LinkedBlockingQueue&lt;E&gt;是一个基于已连接节点的，范围任意的blockingqueue。 队列是先进先出的顺序（FIFO），LinkedBlockingQueue类常用方法 LinkedBlockingQueue() : 创建一个容量为Integer.MAX_VALUE的LinkedBlockingQueue，put(E e) : 在队尾添加一个元素，如果队列满则阻塞，size() : 返回队列中的元素个数，take() : 移除并返回队头元素，如果队列空则阻塞代码实例： 实现商家生产商品和买卖商品的同步。

**7.  使用原子变量实现线程同步**

需要使用线程同步的根本原因在于对普通变量的操作不是原子的。

那么什么是原子操作呢？原子操作就是指将读取变量值、修改变量值、保存变量值看成一个整体来操作。这几种行为要么同时完成，要么都不完成。在java的util.concurrent.atomic包中提供了创建原子类型变量的工具类，使用该类可以简化线程同步。其中AtomicInteger 表可以用原子方式更新int的值，可用在应用程序中(如以原子方式增加的计数器)，但不能用于替换Integer。 AtomicInteger类常用方法：AtomicInteger(int initialValue) : 创建具有给定初始值的变量。AtomicIntegeraddAddGet(int dalta) : 以原子方式将给定值与当前值相加。get() : 获取当前值。

 ![img](https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/java/s11.png)
</code></pre><ol>
<li><p>锁的等级：方法锁、对象锁、类锁。</p>
<p>对象锁(方法锁)，是针对一个对象的，它只在该对象的某个内存位置声明一个标识该对象是否拥有锁，所有它只会锁住当前的对象，一般一个对象锁是对一个非静态成员变量进行synchronized修饰，或者对一个非静态成员方法进行synchronized进行修饰，对于对象锁，不同对象访问同一个被synchronized修饰的方法的时候不会阻塞</p>
<p>类锁是锁住整个类，当有多个线程来声明这个类的对象时候将会被阻塞，直到拥有这个类锁的对象呗销毁或者主动释放了类锁，这个时候在被阻塞的线程被挑选出一个占有该类锁，声明该类的对象。其他线程继续被阻塞住。</p>
<p>无论是类锁还是对象锁，父类和子类之间是否阻塞没有直接关系。当对一个父类加了类锁，子类是不会受到影响的，相反也是如此。因为synchronized关键字并不是方法签名的一部分，它是对方法进行修饰的。当子类覆写父类中的同步方法或是接口中声明的同步方法的时候，synchronized修饰符是不会被自动继承的，所以相应的阻塞问题不会出现。</p>
<p>注意：这里的阻塞问题是指的按照正常情况下应该阻塞，而因为synchronized是父类与子类之间不可传递导致不会阻塞。那正常情况下阻塞是什么那，下面会详细介绍。但是，当一个子类没有覆盖父类的方法的时候，这时候通过子类访问方法则会产生阻塞。</p>
<p>插入一句：构造方法不可能是真正同步的（尽管可以在构造方法中使用同步块）。下面截图给出了如何声明一个对象锁和如何声明一个类锁：</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 void myMethod()&#123;</span><br><span class="line"> 2     synchronized(this)&#123;</span><br><span class="line"> 3         //code</span><br><span class="line"> 4     &#125;</span><br><span class="line"> 5 &#125;</span><br><span class="line"> 6 </span><br><span class="line"> 7 /*is equvilant to*/</span><br><span class="line"> 8 void synchronized myMethod()&#123;</span><br><span class="line"> 9     //code</span><br><span class="line">10 &#125;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>当同一个对象在线程1中访问一个方法，在线程2中再去访问另外一个加锁方法，则同样也会被阻塞.</p>
<p>对于类锁，则会把整个类锁住，也就说只能有一个对象拥有当前类的锁。当一个对象拥有了类锁之后，另外一个对象还想竞争锁的话则会被阻塞。两个对象A，B，如果A正在访问一个被类锁修饰的方法function，那么B则不能访问。因为类锁只能在同一时刻被一个对象拥有。相对于对象锁，则是不同。还是A，B两个对象，如果A正在访问对象锁修饰的function，那么这个时候B也可以同时访问。</p>
<p>对于对象锁，当一个对象拥有锁之后，访问一个加了对象锁的方法，而该方法中又调用了该类中其他加了对象锁的方法，那么这个时候是不会阻塞住的。这是java通过可重入锁机制实现的。可重入锁指的是当一个对象拥有对象锁之后，可以重复获取该锁。因为synchronized块是可重入的，所以当你访问一个对象锁的方法的时候，在该方法中继续访问其他对象锁方法是不会被阻塞的。</p>
</li>
</ol>
<ol>
<li><p>写出生产者消费者模式。</p>
<h2 id="生产者消费者模式说明："><a href="#生产者消费者模式说明：" class="headerlink" title="生产者消费者模式说明："></a>生产者消费者模式说明：</h2><ol>
<li>生产者只在仓库未满时进行生产，仓库满时生产者进程被阻塞；</li>
<li>消费者只在仓库非空时进行消费，仓库为空时消费者进程被阻塞；</li>
<li>当消费者发现仓库为空时会通知生产者生产；</li>
<li>当生产者发现仓库满时会通知消费者消费；</li>
</ol>
<h2 id="实现的关键："><a href="#实现的关键：" class="headerlink" title="实现的关键："></a>实现的关键：</h2><p>共享内存中的两个同步方法，及同步方法中wait()方法的调用。</p>
<ul>
<li>synchronized 保证了对象只能被一个线程占用。</li>
<li>wait 保证了当线程在等待过程中释放锁，使得其他对象有机会获得锁。</li>
</ul>
<blockquote>
<p><a href="https://link.jianshu.com?t=http://www.2cto.com/kf/ware/Java/" target="_blank" rel="noopener">Java</a>中有一个同步模型-监视器，负责管理线程对对象中的同步方法的访问，它的原理是：赋予该对象唯一一把’钥匙’，当多个线程进入对象，只有取得该对象钥匙的线程才可以访问同步方法，其它线程在该对象中等待，直到该线程用wait()方法放弃这把钥匙，其它等待的线程抢占该钥匙，抢占到钥匙的线程后才可得以执行，而没有取得钥匙的线程仍被阻塞在该对象中等待。 总而言之，synchonized使得只有一个线程能进入临界代码区。</p>
<p>由于wait( )所等待的对象必须先锁住，因此，它只能用在同步化程序段或者同步化方法内，否则，会抛出异常java.lang.IllegalMonitorStateException.</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul>
<li>仓库（缓冲区），用于管理产品的生产、消费和存储</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 仓库类，用于管理产品的生产、消费和存储。</span><br><span class="line"> */</span><br><span class="line">public class Storage&lt;T&gt; &#123;</span><br><span class="line">    private int index = 0;</span><br><span class="line">    private static final int MAX = 10;//最大容量</span><br><span class="line">    private List&lt;T&gt; storages = new ArrayList&lt;T&gt;(MAX);//存储集合</span><br><span class="line"></span><br><span class="line">    public synchronized void produce(T item) &#123;</span><br><span class="line">        while (index &gt;= MAX) &#123;// 判断仓库满了，则等待。</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;仓库满了，等待中...&quot;);</span><br><span class="line">                this.wait();</span><br><span class="line">                System.out.println(&quot;仓库不满了，开始生产&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;生产&gt;&gt;&quot; + item.toString());</span><br><span class="line">        storages.add(item);</span><br><span class="line">        index++;   //先添加item，在进行加1操作</span><br><span class="line">        notify();  //唤醒在此对象监视器上等待的单个线程，即消费者线程</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized T consume() &#123;</span><br><span class="line">        while (index &lt;= 0) &#123;// 判断仓库空了，则等待。</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;仓库为空，等待中...&quot;);</span><br><span class="line">                this.wait();</span><br><span class="line">                System.out.println(&quot;仓库不为空，开始消费&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        index--;//先进行减1操作，再remove</span><br><span class="line">        T item = storages.remove(index);</span><br><span class="line">        System.out.println(&quot;消费&gt;&gt;&quot; + item.toString());</span><br><span class="line">        notify();</span><br><span class="line">        return item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>产品</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Phone &#123;</span><br><span class="line"></span><br><span class="line">    private int id;// 手机编号</span><br><span class="line"></span><br><span class="line">    public Phone(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;手机编号：&quot; + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>生产者</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Producer implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private Storage&lt;Phone&gt; storage;</span><br><span class="line">    </span><br><span class="line">    public Producer(Storage&lt;Phone&gt; storage) &#123;</span><br><span class="line">        this.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int i = 0;i&lt;20;i++)&#123;</span><br><span class="line">            storage.produce(new Phone(i));</span><br><span class="line">            </span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(10);//每隔10毫秒生产一个产品</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                // TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>消费者</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Consumer implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private Storage&lt;Phone&gt; storage;</span><br><span class="line">    </span><br><span class="line">    public Consumer(Storage&lt;Phone&gt; storage) &#123;</span><br><span class="line">        this.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int i = 0;i&lt;20;i++)&#123;</span><br><span class="line">            storage.consume();</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(100);//每隔100毫秒消费一个</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>客户端</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ProducerAndConsumer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Storage&lt;Phone&gt; storage = new Storage&lt;Phone&gt;();</span><br><span class="line">        </span><br><span class="line">        new Thread(new Producer(storage)).start();</span><br><span class="line">        new Thread(new Consumer(storage)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li>ThreadLocal的设计理念与作用。</li>
</ol>
<ol>
<li>ThreadPool用法与优势。</li>
</ol>
<ol>
<li>Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。</li>
</ol>
<ol>
<li>wait()和sleep()的区别。</li>
</ol>
<ol>
<li><p>foreach与正常for循环效率对比。</p>
</li>
<li><p>Java IO与NIO。</p>
</li>
<li><p>反射的作用于原理。</p>
</li>
<li><p>泛型常用特点，List<string>能否转为List<object>。</object></string></p>
</li>
<li><p>解析XML的几种方式的原理与特点：DOM、SAX、PULL。</p>
</li>
<li><p>Java与C++对比。</p>
</li>
<li><p>Java1.7与1.8新特性。</p>
</li>
<li><p><a href="http://www.amazon.cn/gp/product/B001130JN8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=importnew-23&amp;linkCode=as2&amp;camp=536&amp;creative=3200&amp;creativeASIN=B001130JN8" target="_blank" rel="noopener">设计模式</a>：单例、工厂、适配器、责任链、观察者等等。</p>
</li>
<li><p>JNI的使用。</p>
</li>
</ol>
 

	    
</div>

<div class="center">
			

				<span class="post-meta">		
				<span class="iconfont icon-category"></span>
				<a class="category-link" href="/categories/java/">java</a>
				</span>
		
			

		
				
				<span class="post-meta">
				<span class="iconfont icon-tag"></span>
				<a class="tag-link" href="/tags/java/">java</a> <a class="tag-link" href="/tags/复习/">复习</a>
				</span>			
			


		

		<span class="post-words"><span class="iconfont icon-words"></span>
		43773
		</span>		
</div>		

		
    <a class="article-readmore" href="/2017/01/11/j2ee详解/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2016/10/05/mongoDB文档数据库/">mongoDB文档数据库</a>  
	       
		 

		 <time>2016-10-05 </time>    
	</div>


    <div class="article-excerpt">	
	
  	

	  

	  	<h1 id="1-MongoDB简介"><a href="#1-MongoDB简介" class="headerlink" title="1.MongoDB简介"></a>1.MongoDB简介</h1><h2 id="1-1什么是MongoDB"><a href="#1-1什么是MongoDB" class="headerlink" title="1.1什么是MongoDB"></a>1.1什么是MongoDB</h2><p>​        MongoDB 是一个跨平台的，面向文档的数据库，是当前 NoSQL 数据库产品中最热门的一种。它介于关系数据库和非关系数据库之间，是非关系数据库当中功能最丰富，最像关系数据库的产品。它支持的数据结构非常松散，是类似JSON  的 BSON 格式，因此可以存储比较复杂的数据类型。</p>
<p>MongoDB 的官方网站地址是：<a href="http://www.mongodb.org/" target="_blank" rel="noopener">http://www.mongodb.org/</a></p>
<h2 id="1-2-MongoDB特点"><a href="#1-2-MongoDB特点" class="headerlink" title="1.2 MongoDB特点"></a>1.2 MongoDB特点</h2><p>​       MongoDB 最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。它是一个面向集合的,模式自由的文档型数据库。</p>
<p>具体特点总结如下：</p>
<p>（1）面向集合存储，易于存储对象类型的数据</p>
<p>（2）模式自由</p>
<p>（3）支持动态查询</p>
<p>（4）支持完全索引，包含内部对象</p>
<p>（5）支持复制和故障恢复</p>
<p>（6）使用高效的二进制数据存储，包括大型对象（如视频等）</p>
<p>（7）自动处理碎片，以支持云计算层次的扩展性</p>
<p>（8）支持 Python，PHP，Ruby，Java，C，C#，Javascript，Perl 及 C++语言的驱动程序，社区中也提供了对 Erlang 及.NET 等平台的驱动程序</p>
<p>（9） 文件存储格式为 BSON（一种 JSON 的扩展）</p>
<h2 id="1-3-MongoDB体系结构"><a href="#1-3-MongoDB体系结构" class="headerlink" title="1.3 MongoDB体系结构"></a>1.3 MongoDB体系结构</h2><p>MongoDB 的逻辑结构是一种层次结构。主要由：</p>
<p>文档(document)、集合(collection)、数据库(database)这三部分组成的。逻辑结构是面向用户</p>
<p>的，用户使用 MongoDB 开发应用程序使用的就是逻辑结构。</p>
<p>（1）MongoDB 的文档（document），相当于关系数据库中的一行记录。</p>
<p>（2）多个文档组成一个集合（collection），相当于关系数据库的表。</p>
<p>（3）多个集合（collection），逻辑上组织在一起，就是数据库（database）。</p>
<p>（4）一个 MongoDB 实例支持多个数据库（database）。</p>
<p>文档(document)、集合(collection)、数据库(database)的层次结构如下图:</p>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image4.png" alt="image4"></p>
<p>下表是MongoDB与MySQL数据库逻辑结构概念的对比</p>
<table>
<thead>
<tr>
<th>MongoDb</th>
<th>关系型数据库Mysql</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据库(databases)</td>
<td>数据库(databases)</td>
</tr>
<tr>
<td>集合(collections)</td>
<td>表(table)</td>
</tr>
<tr>
<td>文档(document)</td>
<td>行(row)</td>
</tr>
</tbody>
</table>
<h1 id="2-基本增删改查操作"><a href="#2-基本增删改查操作" class="headerlink" title="2.基本增删改查操作"></a>2.基本增删改查操作</h1><h2 id="2-1选择或创建数据库"><a href="#2-1选择或创建数据库" class="headerlink" title="2.1选择或创建数据库"></a>2.1选择或创建数据库</h2><p>使用use 数据库名称即可选择数据库，如果该数据库不存在会自动创建</p>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image12.png" alt="image12"></p>
<h2 id="2-2插入文档"><a href="#2-2插入文档" class="headerlink" title="2.2插入文档"></a>2.2插入文档</h2><p>文档相当于关系数据库中的记录</p>
<p>首先我们定义一个文档变量，格式为变量名称={}; 例如：</p>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image13.png" alt="image13"></p>
<p>接下来就是将这个变量存入MongoDB </p>
<p>格式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.集合名称.save(变量);</span><br></pre></td></tr></table></figure>
<p>这里的集合就相当于关系数据库中的表。例如：</p>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image14.png" alt="image14"></p>
<p>这样就在student集合中存入文档。如果这个student集合不存在，就会自动创建。</p>
<p>当然，你也可以不用定义变量，直接把变量值放入save方法中也是可以地。</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image15.png" alt="image15"></p>
<p>为了方便后期测试，我们再多加点数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.student.save(&#123;name:<span class="string">"沙和尚"</span>,sex:<span class="string">"男"</span>,age:<span class="number">25</span>,address:<span class="string">"流沙河路11号"</span>&#125;);</span><br><span class="line">db.student.save(&#123;name:<span class="string">"唐僧"</span>,sex:<span class="string">"男"</span>,age:<span class="number">35</span>,address:<span class="string">"东土大唐"</span>&#125;);</span><br><span class="line">db.student.save(&#123;name:<span class="string">"白骨精"</span>,sex:<span class="string">"女"</span>,age:<span class="number">18</span>,address:<span class="string">"白骨洞"</span>&#125;);</span><br><span class="line">db.student.save(&#123;name:<span class="string">"白龙马"</span>,sex:<span class="string">"男"</span>,age:<span class="number">20</span>,address:<span class="string">"西海"</span>&#125;);</span><br><span class="line">db.student.save(&#123;name:<span class="string">"哪吒"</span>,sex:<span class="string">"男"</span>,age:<span class="number">15</span>,address:<span class="string">"莲花湾小区"</span>&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="2-3查询集合"><a href="#2-3查询集合" class="headerlink" title="2.3查询集合"></a>2.3查询集合</h2><p>我们要查询某集合的所有文档，使用find()方法。语法格式为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.集合名称.find();</span><br></pre></td></tr></table></figure>
<p>例如，我们要查询student集合中的所有文档：</p>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image16.png" alt="image16"> </p>
<p>这里你会发现每条文档会有一个叫_id的字段，这个相当于我们原来关系数据库中表的主键，当你在插入文档记录时没有指定该字段，MongDB会自动创建，其类型是ObjectID类型。</p>
<p>如果我们在插入文档记录时指定该字段也可以，其类型可以使ObjectID类型，也可以是MongoDB支持的任意类型. 例如：</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image17.png" alt="image17"></p>
<p>我们再次查询</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image18.png" alt="image18"></p>
<p>如果我想按一定条件来查询，比如我想查询性别为“女”的记录，怎么办？很简单！</p>
<p>只要在find()中添加参数即可，参数也是json格式，如下： </p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image19.png" alt="image19"></p>
<p>为了避免游标可能带来的开销，MongoDB还提供了一个叫findOne()的方法，用来返回结果集的第一条记录。</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image20.png" alt="image20"></p>
<p>性别为男的有很多条，这里只返回了第一条记录。</p>
<p>当我们需要返回查询结果的前几条记录时，可以使用limit方法，例如：</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image21.png" alt="image21"></p>
<h2 id="2-4修改文档"><a href="#2-4修改文档" class="headerlink" title="2.4修改文档"></a>2.4修改文档</h2><p>我们要想修改记录，可以使用update方法 .</p>
<p>例如：我向将姓名为孙悟空的学员文档中的age字段值改为31，执行下列语句，看会发生什么？</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image22.png" alt="image22"></p>
<p>再次查询：</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image23.png" alt="image23"></p>
<p>哦，悲剧了~~ 原来的孙悟空的文档只剩下_id 和age两个字段了。</p>
<p>那如何保留其它字段值呢？</p>
<p>我们需要使用MongoDB提供的修改器$set 来实现，请看下列代码。</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image24.png" alt="image24"></p>
<p>再次查询，会发现“猪八戒”文档中原有的其它字段还保留下来，而更新age字段也成功了。</p>
<h2 id="2-5删除文档"><a href="#2-5删除文档" class="headerlink" title="2.5删除文档"></a>2.5删除文档</h2><p>删除文档使用remove()方法，格式为：</p>
<p>请慎用remove({}), 它会一条不剩地把你的集合所有文档删的干干净净。</p>
<p>我们现在演示一下，删除name为“哪吒”的记录：</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image25.png" alt="image25"></p>
<p>再次查询，会发现哪吒的文档不见了。</p>
<h1 id="3-高级查询"><a href="#3-高级查询" class="headerlink" title="3.高级查询"></a>3.高级查询</h1><h2 id="3-1模糊查询"><a href="#3-1模糊查询" class="headerlink" title="3.1模糊查询"></a>3.1模糊查询</h2><p>MongoDB的模糊查询是通过正则表达式的方式实现的。格式为：</p>
<p>  /模糊查询字符串/</p>
<p>例如，我要查询student集合中address字段中含有“洞”的所有文档，代码如下：</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image26.png" alt="image26"></p>
<p>如果要查询name字段中以“白”开头的，代码如下：</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image27.png" alt="image27"></p>
<h2 id="3-2-Null值处理"><a href="#3-2-Null值处理" class="headerlink" title="3.2 Null值处理"></a>3.2 Null值处理</h2><p>如果我们想找出集合中某字段值为空的文档，如何查询呢？其实和我们之前的条件查询是一样的，条件值写为null就可以了。</p>
<p>我们现在集合中的文档都是没有空值的，为了方便测试，现在我们将数据做些修改：</p>
<p>将“唐僧”的address改为空</p>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image28.png" alt="image28"> </p>
<p>再次查询：</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image29.png" alt="image29"></p>
<p>我们会发现不仅会显示“唐僧”这条文档，之前因为修改导致address字段丢失的那条记录也出现了。也就是说，这种查询会查询出该字段为null的以及不存在该字段的文档记录。</p>
<h2 id="3-3大于小于"><a href="#3-3大于小于" class="headerlink" title="3.3大于小于"></a>3.3大于小于</h2><p>&lt;, &lt;=, &gt;, &gt;= 这个操作符也是很常用的，格式如下</p>
<p>db.collection.find({ “field” : { $gt: value } } ); // 大于: field &gt; value</p>
<p>db.collection.find({ “field” : { $lt: value } } ); // 小于: field &lt; value</p>
<p>db.collection.find({ “field” : { $gte: value } } ); // 大于等于: field &gt;= value</p>
<p>db.collection.find({ “field” : { $lte: value } } ); // 小于等于: field &lt;= value</p>
<p>示例：查询年龄大于等于20岁的学员记录</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image30.png" alt="image30"></p>
<h2 id="3-4不等于"><a href="#3-4不等于" class="headerlink" title="3.4不等于"></a>3.4不等于</h2><p>不等于使用$ne操作符。</p>
<p>示例：查询sex字段不为“男”的文档</p>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image31.png" alt="image31"> </p>
<h2 id="3-5判断字段是否存在"><a href="#3-5判断字段是否存在" class="headerlink" title="3.5判断字段是否存在"></a>3.5判断字段是否存在</h2><p>判断字段是否存在使用$exists操作符。</p>
<p>示例：查询所有含有address字符的文档。</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image32.png" alt="image3"></p>
<p>示例：查询所有不含有address字符的文档。</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image33.png" alt="image33"></p>
<h2 id="3-6包含与不包含"><a href="#3-6包含与不包含" class="headerlink" title="3.6包含与不包含"></a>3.6包含与不包含</h2><p>包含使用$in操作符。</p>
<p>示例：查询student集合中age字段包含20,25,30的文档</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image34.png" alt="image34"></p>
<p>示例：查询student集合中age字段不包含20,25,30的文档</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image35.png" alt="image35"></p>
<h2 id="3-7统计记录条数"><a href="#3-7统计记录条数" class="headerlink" title="3.7统计记录条数"></a>3.7统计记录条数</h2><p>统计记录条件使用count()方法。</p>
<p>示例：查询student集合的文档条数。</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image36.png" alt="image36"></p>
<p>示例：查询student集合中age字段小于等于20的文档条数。</p>
<p><img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image37.png" alt="image37"> </p>
<h2 id="3-8条件连接–并且"><a href="#3-8条件连接–并且" class="headerlink" title="3.8条件连接–并且"></a>3.8条件连接–并且</h2><p>我们如果需要查询同时满足两个以上条件，需要使用$and操作符将条件进行关联。（相当于SQL的and）</p>
<p>格式为：$and:[ {  },{  },{   } ]</p>
<p>示例：查询student集合中age大于等于20 并且age小于30的文档</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image38.png" alt="image38"></p>
<h2 id="3-9-条件连接–或者"><a href="#3-9-条件连接–或者" class="headerlink" title="3.9 条件连接–或者"></a>3.9 条件连接–或者</h2><p>如果两个以上条件之间是或者的关系，我们使用$or操作符进行关联，与前面$and的使用方式相同</p>
<p>格式为：$or:[ {  },{  },{   } ]</p>
<p>示例：查询student集合中sex为女，或者年龄小于20的文档记录</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image39.png" alt="image39"></p>
<h1 id="4-java连接MongoDB"><a href="#4-java连接MongoDB" class="headerlink" title="4.java连接MongoDB"></a>4.java连接MongoDB</h1><h2 id="4-1查询文档"><a href="#4-1查询文档" class="headerlink" title="4.1查询文档"></a>4.1查询文档</h2><h2 id="4-1-1查询全部记录"><a href="#4-1-1查询全部记录" class="headerlink" title="4.1.1查询全部记录"></a>4.1.1查询全部记录</h2><p>（1）创建maven工程mongoDBDemo ，引入依赖。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mongodb&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.4.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>（2）编写代码，遍历student集合所有数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MongoClient client=<span class="keyword">new</span> MongoClient();<span class="comment">//创建连接对象</span></span><br><span class="line">MongoDatabase database = client.getDatabase(<span class="string">"itcastdb"</span>);<span class="comment">//获取数据库		</span></span><br><span class="line">MongoCollection&lt;Document&gt; collection = database.getCollection(<span class="string">"student"</span>);<span class="comment">//获取集合</span></span><br><span class="line">		</span><br><span class="line">FindIterable&lt;Document&gt; list = collection.find();<span class="comment">//获取文档集合</span></span><br><span class="line"><span class="keyword">for</span>( Document doc: list)&#123;<span class="comment">//遍历集合中的文档输出数据</span></span><br><span class="line">	System.out.println(<span class="string">"name:"</span>+ doc.getString(<span class="string">"name"</span>) );</span><br><span class="line">	System.out.println(<span class="string">"sex:"</span>+ doc.getString(<span class="string">"sex"</span>) );</span><br><span class="line">	System.out.println(<span class="string">"age:"</span>+ doc.getDouble(<span class="string">"age"</span>) );<span class="comment">//默认为浮点型</span></span><br><span class="line">	System.out.println(<span class="string">"address:"</span>+ doc.getString(<span class="string">"address"</span>) );</span><br><span class="line">	System.out.println(<span class="string">"--------------------------"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MongoDB的数字类型默认使用64位浮点型数值。{“x”：3.14}或{“x”：3}。对于整型值，可以使用NumberInt（4字节符号整数），{“x”:NumberInt(“3”)}  或NumberLong（8字节符号整数）{“x”:NumberLong(“3”)}</p>
<h2 id="4-1-2匹配查询"><a href="#4-1-2匹配查询" class="headerlink" title="4.1.2匹配查询"></a>4.1.2匹配查询</h2><p>MongoDB使用BasicDBObject类型封装查询条件，构造方法的参数为key 和value .</p>
<p>示例：查询student集合中name为猪八戒的文档</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建查询条件</span></span><br><span class="line">BasicDBObject bson=<span class="keyword">new</span> BasicDBObject(<span class="string">"name"</span>, <span class="string">"猪八戒"</span>);		</span><br><span class="line">FindIterable&lt;Document&gt; list = collection.find(bson);<span class="comment">//获取文档集合</span></span><br><span class="line"><span class="comment">//....遍历集合</span></span><br></pre></td></tr></table></figure>
<h2 id="4-1-3模糊查询"><a href="#4-1-3模糊查询" class="headerlink" title="4.1.3模糊查询"></a>4.1.3模糊查询</h2><p>构建模糊查询条件是通过正则表达式的方式来实现的</p>
<p>（1）完全匹配Pattern pattern = Pattern.compile(“^name$”);</p>
<p>（2）右匹配Pattern pattern = Pattern.compile(“^.*name$”);</p>
<p>（3）左匹配Pattern pattern = Pattern.compile(“^name.*$”);</p>
<p>（4）模糊匹配Pattern pattern = Pattern.compile(“^.<em>name.</em>$”);</p>
<p>示例：模糊查询student集合中address 中含有洞的文档记录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模糊查询：like %洞%</span></span><br><span class="line">Pattern queryPattern = Pattern.compile(<span class="string">"^.*洞.*$"</span>);</span><br><span class="line">BasicDBObject bson=<span class="keyword">new</span> BasicDBObject(<span class="string">"address"</span>, queryPattern);	</span><br><span class="line">FindIterable&lt;Document&gt; list = collection.find(bson);<span class="comment">//获取文档集合</span></span><br><span class="line"><span class="comment">//....遍历集合</span></span><br></pre></td></tr></table></figure>
<h2 id="4-1-4大于小于"><a href="#4-1-4大于小于" class="headerlink" title="4.1.4大于小于"></a>4.1.4大于小于</h2><p>在MongoDB提示符下条件json字符串为{ age: { $lt :20 } } ，对应的java代码也是BasicDBObject 的嵌套。</p>
<p>示例：查询student集合中age小于20的文档记录 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询年龄小于20的		</span></span><br><span class="line">BasicDBObject bson=<span class="keyword">new</span> BasicDBObject(<span class="string">"age"</span>, <span class="keyword">new</span> BasicDBObject(<span class="string">"$lt"</span>,<span class="number">20</span>));</span><br><span class="line">FindIterable&lt;Document&gt; list = collection.find(bson);<span class="comment">//获取文档集</span></span><br><span class="line"><span class="comment">//....遍历集合</span></span><br></pre></td></tr></table></figure>
<h2 id="4-1-5条件连接–并且"><a href="#4-1-5条件连接–并且" class="headerlink" title="4.1.5条件连接–并且"></a>4.1.5条件连接–并且</h2><p>示例：查询年龄大于等于20并且小于30的文档记录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询年龄大于等于20的			</span></span><br><span class="line">BasicDBObject bson1=<span class="keyword">new</span> BasicDBObject(<span class="string">"age"</span>, <span class="keyword">new</span> BasicDBObject(<span class="string">"$gte"</span>,<span class="number">20</span>));</span><br><span class="line"><span class="comment">//查询年龄小于30的</span></span><br><span class="line">BasicDBObject bson2=<span class="keyword">new</span> BasicDBObject(<span class="string">"age"</span>, <span class="keyword">new</span> BasicDBObject(<span class="string">"$lt"</span>,<span class="number">30</span>));</span><br><span class="line"><span class="comment">//构建查询条件and</span></span><br><span class="line">BasicDBObject bson=<span class="keyword">new</span>  BasicDBObject(<span class="string">"$and"</span>, Arrays.asList(bson1,bson2)  );</span><br></pre></td></tr></table></figure>
<h2 id="4-1-6条件连接–或者"><a href="#4-1-6条件连接–或者" class="headerlink" title="4.1.6条件连接–或者"></a>4.1.6条件连接–或者</h2><p>示例：查询年龄小于等于20或者性别为女的文档记录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BasicDBObject bson1=<span class="keyword">new</span> BasicDBObject(<span class="string">"age"</span>, <span class="keyword">new</span> BasicDBObject(<span class="string">"$lte"</span>,<span class="number">20</span>));		</span><br><span class="line">BasicDBObject bson2=<span class="keyword">new</span> BasicDBObject(<span class="string">"sex"</span>, <span class="string">"女"</span>);</span><br><span class="line"><span class="comment">//构建查询条件or</span></span><br><span class="line">BasicDBObject bson=<span class="keyword">new</span> BasicDBObject(<span class="string">"$or"</span>, Arrays.asList( bson1, bson2 )  );</span><br></pre></td></tr></table></figure>
<h2 id="4-2增加文档"><a href="#4-2增加文档" class="headerlink" title="4.2增加文档"></a>4.2增加文档</h2><p>我们使用insertOne方法来插入文档。</p>
<p>示例：添加文档记录–名称：铁扇公主  性别:女 年龄：28   地址：芭蕉洞</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取连接</span></span><br><span class="line">MongoClient client=<span class="keyword">new</span> MongoClient();</span><br><span class="line"><span class="comment">//得到数据库</span></span><br><span class="line">MongoDatabase database = client.getDatabase(<span class="string">"itcastdb"</span>);</span><br><span class="line"><span class="comment">//得到集合封装对象</span></span><br><span class="line">MongoCollection&lt;Document&gt; collection = database.getCollection(<span class="string">"student"</span>);</span><br><span class="line">Map&lt;String, Object&gt; map=<span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">"name"</span>, <span class="string">"铁扇公主"</span>);</span><br><span class="line">map.put(<span class="string">"sex"</span>, <span class="string">"女"</span>);</span><br><span class="line">map.put(<span class="string">"age"</span>, <span class="number">35.0</span>);</span><br><span class="line">map.put(<span class="string">"address"</span>, <span class="string">"芭蕉洞"</span>);		</span><br><span class="line">Document doc=<span class="keyword">new</span> Document(map);		</span><br><span class="line">collection.insertOne(doc);<span class="comment">//插入一条记录</span></span><br><span class="line"><span class="comment">//collection.insertMany(documents);//一次性插入多条文档</span></span><br></pre></td></tr></table></figure>
<h2 id="4-3删除文档"><a href="#4-3删除文档" class="headerlink" title="4.3删除文档"></a>4.3删除文档</h2><p>示例：将名称为铁扇公主的文档删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取连接</span></span><br><span class="line">MongoClient client=<span class="keyword">new</span> MongoClient();</span><br><span class="line"><span class="comment">//得到数据库</span></span><br><span class="line">MongoDatabase database = client.getDatabase(<span class="string">"itcastdb"</span>);</span><br><span class="line"><span class="comment">//得到集合封装对象</span></span><br><span class="line">MongoCollection&lt;Document&gt; collection = database.getCollection(<span class="string">"student"</span>);</span><br><span class="line">BasicDBObject bson=<span class="keyword">new</span> BasicDBObject(<span class="string">"name"</span>, <span class="string">"铁扇公主"</span>);</span><br><span class="line">collection.deleteOne(bson);<span class="comment">//删除记录（符合条件的第一条记录）</span></span><br><span class="line"><span class="comment">//collection.deleteMany(bson);//删除符合条件的全部记录</span></span><br></pre></td></tr></table></figure>
<h2 id="4-4修改文档"><a href="#4-4修改文档" class="headerlink" title="4.4修改文档"></a>4.4修改文档</h2><p>示例：将红孩儿的地址修改为“南海”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取连接</span></span><br><span class="line">MongoClient client=<span class="keyword">new</span> MongoClient();</span><br><span class="line"><span class="comment">//得到数据库</span></span><br><span class="line">MongoDatabase database = client.getDatabase(<span class="string">"itcastdb"</span>);</span><br><span class="line"><span class="comment">//得到集合封装对象</span></span><br><span class="line">MongoCollection&lt;Document&gt; collection = database.getCollection(<span class="string">"student"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改的条件</span></span><br><span class="line">BasicDBObject bson= <span class="keyword">new</span> BasicDBObject(<span class="string">"name"</span>, <span class="string">"红孩儿"</span>);</span><br><span class="line"><span class="comment">//修改后的值</span></span><br><span class="line">BasicDBObject bson2 = <span class="keyword">new</span> BasicDBObject(<span class="string">"$set"</span>,<span class="keyword">new</span> BasicDBObject(<span class="string">"address"</span>, <span class="string">"南海"</span>));</span><br><span class="line"><span class="comment">//参数1：修改条件  参数2：修改后的值</span></span><br><span class="line">collection.updateOne(bson, bson2);</span><br><span class="line"><span class="comment">//collection.updateMany(filter, update);//修改符合条件的所有记录</span></span><br></pre></td></tr></table></figure>
<p>updateMany方法用于修改符合条件的所有记录</p>
<p>updateOne方法用于修改符合条件的第一条记录</p>
<h1 id="5-MongoDB连接池"><a href="#5-MongoDB连接池" class="headerlink" title="5.MongoDB连接池"></a>5.MongoDB连接池</h1><h2 id="5-1代码实现"><a href="#5-1代码实现" class="headerlink" title="5.1代码实现"></a>5.1代码实现</h2><p>MongoClient 被设计为线程安全的类，也就是我们在使用该类时不需要考虑并发的情况，这样我们可以考虑把MongoClient 做成一个静态变量，为所有线程公用，不必每次都销毁。这样可以极大提高执行效率。实际上，这是MongoDB提供的内置的连接池来实现的。    </p>
<p>​    首先我们先创建一个“管理类”，相当于我们原来的BaseDao </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.haha.demo;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.MongoClient;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.MongoClientOptions;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.MongoClientOptions.Builder;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.WriteConcern;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.client.MongoDatabase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> MongoClient mongoClient=<span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//对mongoClient初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;		</span><br><span class="line">		mongoClient=<span class="keyword">new</span> MongoClient();	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MongoDatabase <span class="title">getDatabase</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(mongoClient==<span class="keyword">null</span>)&#123;</span><br><span class="line">			init();</span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="keyword">return</span> mongoClient.getDatabase(<span class="string">"itcastdb"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    然后我们创建一个StudentDao</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.haha.demo;</span><br><span class="line"><span class="keyword">import</span> org.bson.Document;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.client.MongoCollection;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.client.MongoDatabase;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学员数据访问层</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(String name,String sex,<span class="keyword">double</span> age,String address)</span></span>&#123;</span><br><span class="line">		MongoDatabase database = MongoManager.getDatabase();</span><br><span class="line">		MongoCollection&lt;Document&gt; collection = database.getCollection(<span class="string">"student2"</span>);</span><br><span class="line">		Document docment=<span class="keyword">new</span> Document();</span><br><span class="line">		docment.put(<span class="string">"name"</span>, name);</span><br><span class="line">		docment.put(<span class="string">"sex"</span>, sex);		</span><br><span class="line">		docment.put(<span class="string">"age"</span>, age);</span><br><span class="line">		docment.put(<span class="string">"address"</span>, address);</span><br><span class="line">		collection.insertOne(docment);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在做个测试，循环插入2万条数据，看看执行时间是多长时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.haha.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> startTime = <span class="keyword">new</span> Date().getTime();<span class="comment">//开始时间</span></span><br><span class="line">		</span><br><span class="line">		StudentDao studentDao=<span class="keyword">new</span> StudentDao();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20000</span>;i++)&#123;</span><br><span class="line">			studentDao.save(<span class="string">"测试"</span>+i, <span class="string">"男"</span>, <span class="number">25.0</span>, <span class="string">"测试地址"</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = <span class="keyword">new</span> Date().getTime();<span class="comment">//完成时间</span></span><br><span class="line">		System.out.println(<span class="string">"完成时间："</span>+(endTime-startTime)+<span class="string">"毫秒"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过测试：所用毫秒数为3589 </p>
<h2 id="5-2参数设置"><a href="#5-2参数设置" class="headerlink" title="5.2参数设置"></a>5.2参数设置</h2><p>我们在刚才的代码基础上进行连接池参数的设置</p>
<p>修改MongoManager的init方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对mongoClient初始化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//连接池选项</span></span><br><span class="line">		Builder builder = <span class="keyword">new</span> MongoClientOptions.Builder();<span class="comment">//选项构建者	</span></span><br><span class="line">		builder.connectTimeout(<span class="number">5000</span>);<span class="comment">//设置连接超时时间</span></span><br><span class="line">		builder.socketTimeout(<span class="number">5000</span>);<span class="comment">//读取数据的超时时间</span></span><br><span class="line">		builder.connectionsPerHost(<span class="number">30</span>);<span class="comment">//每个地址最大请求数		</span></span><br><span class="line">		builder.writeConcern(WriteConcern.NORMAL);<span class="comment">//写入策略，仅抛出网络异常</span></span><br><span class="line">		MongoClientOptions options = builder.build();</span><br><span class="line">		mongoClient=<span class="keyword">new</span> MongoClient(<span class="string">"127.0.0.1"</span>,options);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次进行测试：所用的毫秒1544</p>
<p>下面是写入策略。</p>
<p>WriteConcern.NONE:没有异常抛出</p>
<p>WriteConcern.NORMAL:仅抛出网络错误异常，没有服务器错误异常</p>
<p>WriteConcern.SAFE:抛出网络错误异常、服务器错误异常；并等待服务器完成写操作。</p>
<p>WriteConcern.MAJORITY: 抛出网络错误异常、服务器错误异常；并等待一个主服务器完成写操作。</p>
<p>WriteConcern.FSYNC_SAFE: 抛出网络错误异常、服务器错误异常；写操作等待服务器将数据刷新到磁盘。</p>
<p>WriteConcern.JOURNAL_SAFE:抛出网络错误异常、服务器错误异常；写操作等待服务器提交到磁盘的日志文件。</p>
<p>WriteConcern.REPLICAS_SAFE:抛出网络错误异常、服务器错误异常；等待至少2台服务器完成写操作。</p>
<h1 id="6-综合案例-《网站点击日志分析组件》"><a href="#6-综合案例-《网站点击日志分析组件》" class="headerlink" title="6.综合案例-《网站点击日志分析组件》"></a>6.综合案例-《网站点击日志分析组件》</h1><h1 id="6-1需求分析"><a href="#6-1需求分析" class="headerlink" title="6.1需求分析"></a>6.1需求分析</h1><p>《花生二手车》交易网站日访问IP高达2万+ ，每秒点击频率在2000次左右。为了能够对访问用户的行为做进一步的分析，产品部提出需求，用户每次点击浏览二手车都要记录该用户ID、访问IP、访问时间、点击车型、点击商品ID、价格等信息。</p>
<p> <img src="https://mrblogimgs.oss-cn-qingdao.aliyuncs.com/img/MongoDB/image40.png" alt="image40"></p>
<h2 id="6-2数据库设计"><a href="#6-2数据库设计" class="headerlink" title="6.2数据库设计"></a>6.2数据库设计</h2><p>浏览日志browseLog</p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>字段类型</th>
<th>字段含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>userid</td>
<td>字符</td>
<td>用户ID</td>
</tr>
<tr>
<td>ip</td>
<td>字符</td>
<td>访问IP</td>
</tr>
<tr>
<td>browseTime</td>
<td>时间</td>
<td>访问时间</td>
</tr>
<tr>
<td>model</td>
<td>字符</td>
<td>点击车型</td>
</tr>
<tr>
<td>goodsid</td>
<td>字符</td>
<td>点击商品ID</td>
</tr>
<tr>
<td>price</td>
<td>数值</td>
<td>价格</td>
</tr>
<tr>
<td>remark</td>
<td>字符</td>
<td>备注</td>
</tr>
</tbody>
</table>
<h2 id="6-3日志写入"><a href="#6-3日志写入" class="headerlink" title="6.3日志写入"></a>6.3日志写入</h2><p>（1）创建工程sitelog ，在pom.xml中引入依赖。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.mongodb&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt;</span><br><span class="line">       &lt;version&gt;3.4.1&lt;/version&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line"> &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>（2）在src/main/resources 添加配置文件sitelog.properties</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">host=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">port=<span class="number">27017</span></span><br></pre></td></tr></table></figure>
<p>这个配置文件用于配置主机地址和端口</p>
<p>（3）创建包com.huasheng.sitelog，建立Config 类，用于读取配置文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.huasheng.sitelog;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span>&#123;			</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Properties p=<span class="keyword">new</span> Properties();</span><br><span class="line">			InputStream input=Config.class.getResourceAsStream(<span class="string">"/sitelog.propertis"</span>);</span><br><span class="line">			p.load(input);</span><br><span class="line">			host=p.getProperty(<span class="string">"host"</span>);</span><br><span class="line">			port=Integer.parseInt( p.getProperty(<span class="string">"port"</span>));</span><br><span class="line">			input.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="comment">//加载		</span></span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String host;<span class="comment">//主机地址</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> port;<span class="comment">//端口</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> host;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> port;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）创建管理类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.huasheng.sitelog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mongodb.MongoClient;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.MongoClientOptions;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.MongoClientOptions.Builder;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.ServerAddress;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.WriteConcern;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.client.MongoDatabase;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mongo数据库连接管理类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoManager</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> MongoClient mongoClient=<span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//创建一个选项构造器</span></span><br><span class="line">		Builder builder = <span class="keyword">new</span> MongoClientOptions.Builder();</span><br><span class="line">		builder.connectTimeout(<span class="number">5000</span>);<span class="comment">//设置连接超时时间</span></span><br><span class="line">		builder.socketTimeout(<span class="number">5000</span>);<span class="comment">//读取数据的超时时间</span></span><br><span class="line">		builder.connectionsPerHost(<span class="number">30</span>);<span class="comment">//设置每个地址最大连接数</span></span><br><span class="line">		builder.writeConcern(WriteConcern.NORMAL);<span class="comment">//设置写入策略  ,只有网络异常才会抛出</span></span><br><span class="line">		<span class="comment">//得到选项封装</span></span><br><span class="line">		MongoClientOptions options = builder.build();		</span><br><span class="line">		mongoClient=<span class="keyword">new</span> MongoClient(<span class="keyword">new</span> ServerAddress(Config.getHost(), Config.getPort()),options);		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MongoDatabase <span class="title">getDatabase</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(mongoClient==<span class="keyword">null</span>)&#123;</span><br><span class="line">			init();</span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="keyword">return</span> mongoClient.getDatabase(<span class="string">"itcastdb"</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（5）日志工具类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.huasheng.sitelog;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> org.bson.Document;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.client.MongoCollection;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.client.MongoDatabase;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 站点日志数据工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SiteLogUtil</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 写入日志</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> logname 日志名称</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> map 日志数据</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(String logname,Map&lt;String, Object&gt; map)</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		MongoDatabase database = MongoManager.getDatabase();</span><br><span class="line">		MongoCollection&lt;Document&gt; collection = database.getCollection(logname);</span><br><span class="line">		Document doc=<span class="keyword">new</span> Document(map);		</span><br><span class="line">		collection.insertOne(doc);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（6）编写测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map map=<span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">"userid"</span>, <span class="string">"8888"</span>);</span><br><span class="line">map.put(<span class="string">"ip"</span>, <span class="string">"188.188.200.2"</span>);</span><br><span class="line">map.put(<span class="string">"browseTime"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">map.put(<span class="string">"model"</span>, <span class="string">"大众"</span>);</span><br><span class="line">map.put(<span class="string">"goodsid"</span>, <span class="string">"123123"</span>);</span><br><span class="line">map.put(<span class="string">"price"</span>, <span class="number">15.3</span>);</span><br><span class="line">map.put(<span class="string">"remark"</span>, <span class="string">"八成新，贱卖了"</span>);</span><br><span class="line">SiteLogUtil.save(<span class="string">"browseLog"</span>, map);<span class="comment">//存入日志</span></span><br></pre></td></tr></table></figure>
<h2 id="6-4日志查询"><a href="#6-4日志查询" class="headerlink" title="6.4日志查询"></a>6.4日志查询</h2><h2 id="6-4-1条件查询"><a href="#6-4-1条件查询" class="headerlink" title="6.4.1条件查询"></a>6.4.1条件查询</h2><p>（1）在SiteLogUtil类中添加方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 按条件查询</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> logName</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> map</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FindIterable&lt;Document&gt; <span class="title">list</span><span class="params">(String logName,Map&lt;String, Object&gt; map)</span></span>&#123;</span><br><span class="line">		MongoDatabase database = MongoManager.getDatabase();</span><br><span class="line">		MongoCollection&lt;Document&gt; collection = database.getCollection(logName);</span><br><span class="line">		BasicDBObject bson=<span class="keyword">new</span> BasicDBObject(map);<span class="comment">//构建查询条件			</span></span><br><span class="line">		<span class="keyword">return</span> collection.find(bson);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>（2）编写测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map =<span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">"userid"</span>, <span class="string">"8888"</span>);		</span><br><span class="line">FindIterable&lt;Document&gt; list = SiteLogUtil.list(<span class="string">"browseLog"</span>, map);</span><br><span class="line">String json = JSON.serialize(list);</span><br><span class="line">System.out.println(json);</span><br></pre></td></tr></table></figure>
<h2 id="6-4-2分页查询"><a href="#6-4-2分页查询" class="headerlink" title="6.4.2分页查询"></a>6.4.2分页查询</h2><p>（1）在SiteLogUtil类中添加方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分页查询日志</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> logName 日志名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map 条件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pageIndex 页码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pageSize 页大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,Object&gt; <span class="title">listPage</span><span class="params">(String logName,Map&lt;String, Object&gt; map,<span class="keyword">int</span> pageIndex,<span class="keyword">int</span> pageSize)</span></span>&#123;</span><br><span class="line">	MongoDatabase database = MongoManager.getDatabase();</span><br><span class="line">	MongoCollection&lt;Document&gt; collection = database.getCollection(logName);		</span><br><span class="line">	BasicDBObject bson=<span class="keyword">new</span> BasicDBObject(map);<span class="comment">//构建查询条件			</span></span><br><span class="line">	FindIterable&lt;Document&gt; find = collection.find(bson);</span><br><span class="line">	<span class="keyword">int</span> skip= (pageIndex-<span class="number">1</span>)*pageSize;</span><br><span class="line">	find.skip( skip);<span class="comment">//跳过记录数</span></span><br><span class="line">	find.limit(pageSize);<span class="comment">//一页查询记录数</span></span><br><span class="line">	<span class="comment">//&#123; total:x,rows:[]  &#125;</span></span><br><span class="line">	<span class="keyword">long</span> count = collection.count(bson);</span><br><span class="line">	Map&lt;String,Object&gt; m=<span class="keyword">new</span> HashMap();</span><br><span class="line">	m.put(<span class="string">"total"</span>, count);</span><br><span class="line">	m.put(<span class="string">"rows"</span>, find);</span><br><span class="line">	<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）添加测试数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">	</span><br><span class="line">	Map&lt;String, Object&gt; map=<span class="keyword">new</span> HashMap();</span><br><span class="line">	map.put(<span class="string">"userid"</span>, <span class="string">"900"</span>+i);<span class="comment">//用户ID</span></span><br><span class="line">	map.put(<span class="string">"ip"</span>, <span class="string">"121.211.112.212"</span>);</span><br><span class="line">	map.put(<span class="string">"browseTime"</span>, <span class="keyword">new</span> Date());<span class="comment">//浏览时间</span></span><br><span class="line">	map.put(<span class="string">"model"</span>, <span class="string">"大众"</span>+i);<span class="comment">//型号</span></span><br><span class="line">	map.put(<span class="string">"goodsid"</span>, <span class="string">"123456"</span>);<span class="comment">//商品ID</span></span><br><span class="line">	map.put(<span class="string">"price"</span>, <span class="number">11.8</span>);<span class="comment">//价格</span></span><br><span class="line">	map.put(<span class="string">"remark"</span>, <span class="string">"八成新，快来买吧"</span>);</span><br><span class="line">	</span><br><span class="line">	SiteLogUtil.save(<span class="string">"browseLog"</span>, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）编写测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map=<span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">"goodsid"</span>, <span class="string">"123456"</span>);</span><br><span class="line">Map&lt;String, Object&gt; m = SiteLogUtil.listPage(<span class="string">"browseLog"</span>, map, <span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">String json = JSON.serialize(m);</span><br><span class="line">System.out.println(json);</span><br></pre></td></tr></table></figure>
<p>使用Maven 的package命令进行打包。</p>
<p>创建WEB工程，引入jar包，调用此方法即可实现日志查询。代码略。</p>
 

	    
</div>

<div class="center">
			

				<span class="post-meta">		
				<span class="iconfont icon-category"></span>
				<a class="category-link" href="/categories/数据库/">数据库</a>
				</span>
		
			

		
				
				<span class="post-meta">
				<span class="iconfont icon-tag"></span>
				<a class="tag-link" href="/tags/mongoDB/">mongoDB</a>
				</span>			
			


		

		<span class="post-words"><span class="iconfont icon-words"></span>
		15463
		</span>		
</div>		

		
    <a class="article-readmore" href="/2016/10/05/mongoDB文档数据库/">阅读更多</a> 
    	
</article>     
     	
  

 

  <nav class="paginator">
    <a class="extend prev" rel="prev" href="/page/4/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>
  

</section> 

    </div>        

    
    <div class="mask"> </div>
    <div class="back-to-top iconfont icon-backtotop fadeIn"></div> 

    


<script src="/js/search.js"></script>     
          
          <div class="search-container sildeUpMin">
            <input type="text" placeholder="输入你想搜索的" id="search-input" class="search-input">  
              <span class="search-cancel iconfont icon-cancel"></span>
              <div id="search-result" class="search-result"></div>
          </div>
 

     <div class="mobile-menu">      

      
      <img class="mobile-menu-icon no-gallery" src= /img/favicon.png >   
      

         
            

            <a class="mobile-menu-link" href="/">首页
            </a>
            
         
            

            <a class="mobile-menu-link" href="/archives">归档
            </a>
            
         
            

            <a class="mobile-menu-link" href="/categories">分类
            </a>
            
         
            

            <a class="mobile-menu-link" href="/tags">标签
            </a>
            
         
            

            <a class="mobile-menu-link" href="/about">关于
            </a>
            
         
                          

            <a class="mobile-menu-link mobile-menu-search" href="#">搜索 </a>                 
            
         
</div>     
    

<footer id="footer">
	   
   	 <div>	
	   	    	
   	 </div>
   
   	 
	 <div>
	 	&copy;
		2018
		Rui Min	 

	 </div>


   
   	 <div>
	
	 <a href="http://hexo.io/" target="_blank">Hexo</a>

	 Theme

	 <a href="https://github.com/Lemonreds/hexo-theme-Nayo" target="_blank">Nayo</a> 

	 </div>	


	
	
</footer> 
    

<!-- Baidu Analytics -->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?636802045446222199ae541e32c8133e"; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




 
  </body>   
  <script src="/js/animation.js"></script>   
</html>